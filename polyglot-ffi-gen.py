#!/usr/bin/env python3
"""
Polyglot FFI Generator - Prototype
Generates OCaml ctypes bindings and Python wrappers from .mli files
"""

import re
import argparse
from pathlib import Path
from typing import List, Dict, Tuple
from dataclasses import dataclass


@dataclass
class FunctionSignature:
    """Represents a parsed OCaml function signature"""
    name: str
    params: List[Tuple[str, str]]  # [(param_name, ocaml_type), ...]
    return_type: str
    doc: str = ""


class MLIParser:
    """Parse OCaml .mli interface files"""
    
    def __init__(self, content: str):
        self.content = content
        self.functions = []
    
    def parse(self) -> List[FunctionSignature]:
        """Extract function signatures from .mli file"""
        lines = self.content.split('\n')
        i = 0
        
        while i < len(lines):
            line = lines[i].strip()
            
            # Look for 'val function_name : type'
            if line.startswith('val '):
                func_sig, doc, lines_consumed = self._parse_function(lines[i:])
                if func_sig:
                    self.functions.append(func_sig)
                i += lines_consumed
            else:
                i += 1
        
        return self.functions
    
    def _parse_function(self, lines: List[str]) -> Tuple[FunctionSignature, str, int]:
        """Parse a single function signature"""
        # Combine lines until we find the full signature
        full_sig = ""
        doc = ""
        lines_consumed = 0
        
        for j, line in enumerate(lines):
            stripped = line.strip()
            full_sig += " " + stripped
            lines_consumed += 1
            
            # Check for documentation
            if '(**' in stripped:
                doc_match = re.search(r'\(\*\*\s*(.*?)\s*\*\)', stripped)
                if doc_match:
                    doc = doc_match.group(1)
            
            # Function signature ends when we don't have continuation
            if not stripped.endswith('->') and '(**' not in stripped:
                if 'val' in full_sig:
                    break
        
        # Parse the signature
        match = re.match(r'val\s+(\w+)\s*:\s*(.+)', full_sig.strip())
        if not match:
            return None, "", lines_consumed
        
        name = match.group(1)
        type_sig = match.group(2).strip()
        
        # Split by '->' to get params and return type
        parts = [p.strip() for p in type_sig.split('->')]
        
        if len(parts) < 2:
            return None, "", lines_consumed
        
        # Parameters are all parts except the last
        params = [(f"arg{i}", ptype) for i, ptype in enumerate(parts[:-1])]
        return_type = parts[-1]
        
        return FunctionSignature(name, params, return_type, doc), doc, lines_consumed


class CtypesGenerator:
    """Generate OCaml ctypes binding code"""
    
    TYPE_MAP = {
        'string': 'string',
        'int': 'int',
        'float': 'double',
        'bool': 'bool',
        'unit': 'void',
    }
    
    @staticmethod
    def generate_type_description(functions: List[FunctionSignature]) -> str:
        """Generate type_description.ml"""
        return """(* Generated by polyglot-ffi *)
open Ctypes

module Types (F : Ctypes.TYPE) = struct
  (* Type descriptions go here if needed for complex types *)
end
"""
    
    @staticmethod
    def generate_function_description(functions: List[FunctionSignature]) -> str:
        """Generate function_description.ml"""
        code = """(* Generated by polyglot-ffi *)
open Ctypes

module Functions (F : Ctypes.FOREIGN) = struct
"""
        
        for func in functions:
            # Build ctypes function signature
            params_ctypes = []
            for _, ptype in func.params:
                ctype = CtypesGenerator.TYPE_MAP.get(ptype, 'string')
                params_ctypes.append(ctype)
            
            return_ctype = CtypesGenerator.TYPE_MAP.get(func.return_type, 'string')
            
            # Generate the foreign declaration
            code += f'  let {func.name} = \n'
            code += f'    F.foreign "ml_{func.name}"\n'
            code += f'      ('
            
            if params_ctypes:
                code += ' @-> '.join(params_ctypes)
                code += ' @-> '
            
            code += f'returning {return_ctype})\n\n'
        
        code += "end\n"
        return code


class CStubGenerator:
    """Generate C stub code"""
    
    C_TYPE_MAP = {
        'string': 'char*',
        'int': 'int',
        'float': 'double',
        'bool': 'int',
        'unit': 'void',
    }
    
    @staticmethod
    def generate_stubs(functions: List[FunctionSignature], module_name: str) -> str:
        """Generate C stub code"""
        code = f"""/* Generated by polyglot-ffi */
/* {module_name}_stubs.c */

#include <string.h>
#include <caml/mlvalues.h>
#include <caml/memory.h>
#include <caml/alloc.h>
#include <caml/callback.h>

"""
        
        for func in functions:
            # Determine C return type
            c_return = CStubGenerator.C_TYPE_MAP.get(func.return_type, 'char*')
            
            # Generate function signature
            params_str = ', '.join([
                f"{CStubGenerator.C_TYPE_MAP.get(ptype, 'char*')} {pname}"
                for pname, ptype in func.params
            ])
            
            code += f"/* Wrapper for OCaml {func.name} function */\n"
            code += f"{c_return} ml_{func.name}({params_str}) {{\n"
            code += f"    CAMLparam0();\n"
            
            # Declare local variables
            num_locals = len(func.params) + 1
            code += f"    CAMLlocal{num_locals}("
            code += ", ".join([f"ml_{p[0]}" for p in func.params] + ["ml_result"])
            code += ");\n\n"
            
            # Convert C params to OCaml values
            for pname, ptype in func.params:
                if ptype == 'string':
                    code += f"    ml_{pname} = caml_copy_string({pname});\n"
                elif ptype == 'int':
                    code += f"    ml_{pname} = Val_int({pname});\n"
                elif ptype == 'float':
                    code += f"    ml_{pname} = caml_copy_double({pname});\n"
                elif ptype == 'bool':
                    code += f"    ml_{pname} = Val_bool({pname});\n"
            
            # Call OCaml function
            code += f'    ml_result = caml_callback(*caml_named_value("{func.name}"), '
            code += ", ".join([f"ml_{p[0]}" for p in func.params])
            code += ");\n\n"
            
            # Convert result back to C
            if func.return_type == 'string':
                code += f"    {c_return} result = strdup(String_val(ml_result));\n"
                code += f"    CAMLreturnT({c_return}, result);\n"
            elif func.return_type == 'int':
                code += f"    {c_return} result = Int_val(ml_result);\n"
                code += f"    CAMLreturnT({c_return}, result);\n"
            elif func.return_type == 'float':
                code += f"    {c_return} result = Double_val(ml_result);\n"
                code += f"    CAMLreturnT({c_return}, result);\n"
            elif func.return_type == 'bool':
                code += f"    {c_return} result = Bool_val(ml_result);\n"
                code += f"    CAMLreturnT({c_return}, result);\n"
            elif func.return_type == 'unit':
                code += f"    CAMLreturn0;\n"
            
            code += "}\n\n"
        
        return code
    
    @staticmethod
    def generate_header(functions: List[FunctionSignature], module_name: str) -> str:
        """Generate C header file"""
        code = f"""/* Generated by polyglot-ffi */
/* {module_name}_stubs.h */

#ifndef {module_name.upper()}_STUBS_H
#define {module_name.upper()}_STUBS_H

"""
        
        for func in functions:
            c_return = CStubGenerator.C_TYPE_MAP.get(func.return_type, 'char*')
            params_str = ', '.join([
                f"{CStubGenerator.C_TYPE_MAP.get(ptype, 'char*')} {pname}"
                for pname, ptype in func.params
            ])
            code += f"{c_return} ml_{func.name}({params_str});\n"
        
        code += f"\n#endif /* {module_name.upper()}_STUBS_H */\n"
        return code


class DuneGenerator:
    """Generate Dune build configuration"""
    
    @staticmethod
    def generate_dune(module_name: str) -> str:
        """Generate dune file"""
        return f"""; Generated by polyglot-ffi
(library
 (name {module_name}_bindings)
 (public_name {module_name}_bindings)
 (libraries ctypes ctypes.foreign)
 (ctypes
  (external_library_name {module_name})
  (build_flags_resolver
   (vendored (c_flags :standard) (c_library_flags :standard)))
  (headers (include "{module_name}_stubs.h"))
  (type_description
   (instance Type)
   (functor Type_description))
  (function_description
   (concurrency sequential)
   (instance Function)
   (functor Function_description))
  (generated_types Types_generated)
  (generated_entry_point C)))

(rule
 (targets lib{module_name}_stubs.a dll{module_name}_stubs.so)
 (deps {module_name}_stubs.c {module_name}_stubs.h)
 (action
  (run ocamlmklib -o {module_name}_stubs %{{deps}})))
"""
    
    @staticmethod
    def generate_dune_project(module_name: str) -> str:
        """Generate dune-project file"""
        return f"""; Generated by polyglot-ffi
(lang dune 3.16)
(using ctypes 0.3)

(name {module_name}_bindings)

(generate_opam_files true)

(package
 (name {module_name}_bindings)
 (synopsis "OCaml-Python bindings for {module_name}")
 (description "Auto-generated FFI bindings")
 (depends
  (ocaml (>= 4.14))
  (dune (>= 3.16))
  (ctypes (>= 0.20.0))
  (ctypes-foreign (>= 0.20.0))))
"""


class PythonWrapperGenerator:
    """Generate Python wrapper code"""
    
    PY_TYPE_MAP = {
        'string': 'str',
        'int': 'int',
        'float': 'float',
        'bool': 'bool',
        'unit': 'None',
    }
    
    CTYPES_MAP = {
        'string': 'ctypes.c_char_p',
        'int': 'ctypes.c_int',
        'float': 'ctypes.c_double',
        'bool': 'ctypes.c_bool',
        'unit': 'None',
    }
    
    @staticmethod
    def generate_wrapper(functions: List[FunctionSignature], module_name: str) -> str:
        """Generate Python wrapper module"""
        code = f"""# Generated by polyglot-ffi
# {module_name}_py.py

import ctypes
from pathlib import Path
from typing import Optional

# Load the shared library
_lib_path = Path(__file__).parent / "lib{module_name}.so"
_lib = ctypes.CDLL(str(_lib_path))

class {module_name.capitalize()}Error(Exception):
    \"\"\"Raised when {module_name} operations fail\"\"\"
    pass

"""
        
        # Configure each function
        for func in functions:
            code += f"# Configure {func.name}\n"
            
            # Set argtypes
            if func.params:
                argtypes = [PythonWrapperGenerator.CTYPES_MAP.get(ptype, 'ctypes.c_char_p') 
                           for _, ptype in func.params]
                code += f"_lib.ml_{func.name}.argtypes = [{', '.join(argtypes)}]\n"
            
            # Set restype
            restype = PythonWrapperGenerator.CTYPES_MAP.get(func.return_type, 'ctypes.c_char_p')
            code += f"_lib.ml_{func.name}.restype = {restype}\n\n"
        
        # Generate wrapper functions
        for func in functions:
            # Build parameter list
            params = [f"{pname}: {PythonWrapperGenerator.PY_TYPE_MAP.get(ptype, 'str')}" 
                     for pname, ptype in func.params]
            params_str = ', '.join(params) if params else ''
            
            return_type = PythonWrapperGenerator.PY_TYPE_MAP.get(func.return_type, 'str')
            
            code += f"def {func.name}({params_str}) -> {return_type}:\n"
            
            # Add docstring
            if func.doc:
                code += f'    """{func.doc}"""\n'
            else:
                code += f'    """Call OCaml {func.name} function"""\n'
            
            code += "    try:\n"
            
            # Convert Python args to C types
            call_args = []
            for pname, ptype in func.params:
                if ptype == 'string':
                    call_args.append(f"{pname}.encode('utf-8')")
                else:
                    call_args.append(pname)
            
            # Make the call
            call_str = ', '.join(call_args) if call_args else ''
            code += f"        result = _lib.ml_{func.name}({call_str})\n"
            
            # Handle return value
            if func.return_type == 'string':
                code += "        if result is None:\n"
                code += f"            raise {module_name.capitalize()}Error(\"{func.name} returned NULL\")\n"
                code += "        return result.decode('utf-8')\n"
            elif func.return_type == 'unit':
                code += "        return None\n"
            else:
                code += "        return result\n"
            
            code += "    except Exception as e:\n"
            code += f"        raise {module_name.capitalize()}Error(f\"{func.name} failed: {{e}}\")\n\n"
        
        return code


def main():
    parser = argparse.ArgumentParser(
        description='Generate OCaml-Python FFI bindings from .mli files'
    )
    parser.add_argument('mli_file', help='OCaml .mli interface file')
    parser.add_argument('-o', '--output-dir', default='generated', 
                       help='Output directory (default: generated)')
    parser.add_argument('-n', '--name', help='Module name (default: derived from filename)')
    
    args = parser.parse_args()
    
    # Read the .mli file
    mli_path = Path(args.mli_file)
    if not mli_path.exists():
        print(f"Error: File {args.mli_file} not found")
        return 1
    
    content = mli_path.read_text()
    
    # Determine module name
    module_name = args.name or mli_path.stem
    
    # Parse the .mli file
    print(f"Parsing {args.mli_file}...")
    parser = MLIParser(content)
    functions = parser.parse()
    
    if not functions:
        print("No functions found in .mli file")
        return 1
    
    print(f"Found {len(functions)} function(s):")
    for func in functions:
        print(f"  - {func.name}: {' -> '.join([p[1] for p in func.params])} -> {func.return_type}")
    
    # Create output directory
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Generate all files
    print(f"\nGenerating bindings in {output_dir}/...")
    
    # OCaml ctypes files
    (output_dir / 'type_description.ml').write_text(
        CtypesGenerator.generate_type_description(functions)
    )
    print("  ✓ type_description.ml")
    
    (output_dir / 'function_description.ml').write_text(
        CtypesGenerator.generate_function_description(functions)
    )
    print("  ✓ function_description.ml")
    
    # C stubs
    (output_dir / f'{module_name}_stubs.c').write_text(
        CStubGenerator.generate_stubs(functions, module_name)
    )
    print(f"  ✓ {module_name}_stubs.c")
    
    (output_dir / f'{module_name}_stubs.h').write_text(
        CStubGenerator.generate_header(functions, module_name)
    )
    print(f"  ✓ {module_name}_stubs.h")
    
    # Dune files
    (output_dir / 'dune').write_text(
        DuneGenerator.generate_dune(module_name)
    )
    print("  ✓ dune")
    
    (output_dir / 'dune-project').write_text(
        DuneGenerator.generate_dune_project(module_name)
    )
    print("  ✓ dune-project")
    
    # Python wrapper
    (output_dir / f'{module_name}_py.py').write_text(
        PythonWrapperGenerator.generate_wrapper(functions, module_name)
    )
    print(f"  ✓ {module_name}_py.py")
    
    print("\n✨ Generation complete!")
    print(f"\nNext steps:")
    print(f"1. Copy the generated files to your project")
    print(f"2. Implement your OCaml functions in {module_name}.ml")
    print(f"3. Register functions with Callback.register in your OCaml code")
    print(f"4. Build with: dune build")
    print(f"5. Use in Python: from {module_name}_py import *")
    
    return 0


if __name__ == '__main__':
    exit(main())