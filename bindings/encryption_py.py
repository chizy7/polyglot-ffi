# Generated by polyglot-ffi
# encryption_py.py

import ctypes
from pathlib import Path
from typing import Optional

# Load the shared library
_lib_path = Path(__file__).parent / "libencryption.so"
_lib = ctypes.CDLL(str(_lib_path))

class EncryptionError(Exception):
    """Raised when encryption operations fail"""
    pass

# Configure encrypt
_lib.ml_encrypt.argtypes = [ctypes.c_char_p]
_lib.ml_encrypt.restype = ctypes.c_char_p

# Configure decrypt
_lib.ml_decrypt.argtypes = [ctypes.c_char_p]
_lib.ml_decrypt.restype = ctypes.c_char_p

# Configure hash
_lib.ml_hash.argtypes = [ctypes.c_char_p]
_lib.ml_hash.restype = ctypes.c_char_p

# Configure validate
_lib.ml_validate.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
_lib.ml_validate.restype = ctypes.c_bool

def encrypt(arg0: str) -> str:
    """Call OCaml encrypt function"""
    try:
        result = _lib.ml_encrypt(arg0.encode('utf-8'))
        if result is None:
            raise EncryptionError("encrypt returned NULL")
        return result.decode('utf-8')
    except Exception as e:
        raise EncryptionError(f"encrypt failed: {e}")

def decrypt(arg0: str) -> str:
    """Call OCaml decrypt function"""
    try:
        result = _lib.ml_decrypt(arg0.encode('utf-8'))
        if result is None:
            raise EncryptionError("decrypt returned NULL")
        return result.decode('utf-8')
    except Exception as e:
        raise EncryptionError(f"decrypt failed: {e}")

def hash(arg0: str) -> str:
    """Call OCaml hash function"""
    try:
        result = _lib.ml_hash(arg0.encode('utf-8'))
        if result is None:
            raise EncryptionError("hash returned NULL")
        return result.decode('utf-8')
    except Exception as e:
        raise EncryptionError(f"hash failed: {e}")

def validate(arg0: str, arg1: str) -> bool:
    """Call OCaml validate function"""
    try:
        result = _lib.ml_validate(arg0.encode('utf-8'), arg1.encode('utf-8'))
        return result
    except Exception as e:
        raise EncryptionError(f"validate failed: {e}")

