{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Polyglot FFI Documentation","text":"<p>Welcome to Polyglot FFI! This tool automatically generates FFI (Foreign Function Interface) bindings between programming languages, eliminating the tedious boilerplate of manual ctypes, C stubs, and wrapper code.</p>"},{"location":"#what-is-polyglot-ffi","title":"What is Polyglot FFI?","text":"<p>Polyglot FFI is a code generator that bridges programming languages by:</p> <ol> <li>Parsing source language interface files (e.g., OCaml <code>.mli</code>)</li> <li>Analyzing function signatures and types</li> <li>Generating complete FFI bindings automatically:</li> <li>OCaml ctypes declarations</li> <li>Memory-safe C wrapper code</li> <li>Type-safe target language wrappers (Python, Rust, etc.)</li> <li>Build system configurations (Dune, Cargo, etc.)</li> </ol>"},{"location":"#the-problem-we-solve","title":"The Problem We Solve","text":"<p>Building multi-language projects is powerful but painful. Traditionally, you'd write:</p> <pre><code>(* 50+ lines of manual ctypes boilerplate *)\nopen Ctypes\nmodule Types (F : Ctypes.TYPE) = struct\n  (* ... manual type descriptions ... *)\nend\nmodule Functions (F : Ctypes.FOREIGN) = struct\n  (* ... manual foreign declarations ... *)\nend\n</code></pre> <pre><code>/* 30+ lines of C stubs with tricky memory management *)\nchar* ml_encrypt(char* input) {\n    CAMLparam0();\n    CAMLlocal2(ml_input, ml_result);\n    // ... manual conversions and callbacks ...\n    CAMLreturnT(char*, result);\n}\n</code></pre> <pre><code># 20+ lines of ctypes configuration\nimport ctypes\n_lib = ctypes.CDLL(\"libencryption.so\")\n_lib.ml_encrypt.argtypes = [ctypes.c_char_p]\n# ... manual error handling ...\n</code></pre> <p>Plus: Dune configuration, debugging version mismatches, memory leaks...</p>"},{"location":"#with-polyglot-ffi","title":"With Polyglot FFI","text":"<pre><code>polyglot-ffi generate encryption.mli\n</code></pre> <p>Done! All 100+ lines of boilerplate generated automatically, type-safe, and memory-safe.</p>"},{"location":"#status","title":"Status","text":""},{"location":"#what-works-now","title":"What Works Now","text":"<p>Supported Types: - <code>string</code> - String type - <code>int</code> - Integer type - <code>float</code> - Floating point type - <code>bool</code> - Boolean type - <code>unit</code> - Unit/void type</p> <p>Function Signatures: - Single parameter: <code>val f : string -&gt; string</code> - Multiple parameters: <code>val add : int -&gt; int -&gt; int</code> - No parameters: <code>val get : unit -&gt; string</code> - Documentation comment preservation</p> <p>Generated Code: - OCaml ctypes bindings (<code>type_description.ml</code>, <code>function_description.ml</code>) - Memory-safe C stubs with proper CAMLparam/CAMLreturn - Python wrappers with type hints and error handling - Dune build configuration (correct versions, no mismatches)</p> <p>CLI Commands: - <code>polyglot-ffi init</code> - Initialize new projects - <code>polyglot-ffi generate</code> - Generate bindings - <code>polyglot-ffi check</code> - Validate configuration - <code>polyglot-ffi clean</code> - Clean generated files - <code>polyglot-ffi watch</code> - Watch for changes</p> <p>Complex Types: - Option types (<code>'a option</code>) - List types (<code>'a list</code>) - Tuple types (<code>'a * 'b</code>) - Record types - Variant/sum types - Custom type mappings</p> <p>Developer Experience: - Watch mode (auto-regenerate) - Better error messages - Configuration file support - Build system integration</p> <p>Future Features (v1.0+): - Rust target support - Go target support - Bidirectional bindings - Plugin system</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Quickstart Guide - Get started in 5 minutes</li> <li>Architecture - How Polyglot FFI works</li> <li>Type Mapping - Type system reference</li> <li>Configuration - Configure your project</li> <li>Contributing - Join development</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install polyglot-ffi\n</code></pre> <p>Or from source:</p> <pre><code>git clone https://github.com/chizy7/polyglot-ffi\ncd polyglot-ffi\npip install -e \".[dev]\"\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>1. Write OCaml interface:</p> <pre><code>(* crypto.mli *)\nval encrypt : string -&gt; string\n(** Encrypt a string *)\n\nval hash : string -&gt; int\n(** Hash a string to integer *)\n</code></pre> <p>2. Generate bindings:</p> <pre><code>polyglot-ffi generate crypto.mli -o generated/ -n crypto\n</code></pre> <p>3. Use from Python:</p> <pre><code>from generated.crypto_py import encrypt, hash\n\nencrypted = encrypt(\"secret\")\nhash_val = hash(\"data\")\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#zero-boilerplate","title":"Zero Boilerplate","text":"<p>One command generates everything: - OCaml ctypes declarations - C wrapper functions - Python wrapper module - Build configuration - Type conversions - Error handling</p>"},{"location":"#type-safe","title":"Type Safe","text":"<p>Preserves type information across languages: - Python type hints - OCaml type constraints - C type declarations - Compile-time type checking</p>"},{"location":"#memory-safe","title":"Memory Safe","text":"<p>Proper memory management: - CAMLparam/CAMLreturn macros - No memory leaks - String ownership handled - GC-safe conversions</p>"},{"location":"#release-highlights-v040","title":"Release Highlights (v0.4.0)","text":"<ul> <li>Comprehensive test suite (75% coverage, 262 tests)</li> <li>Shell completions (Bash, Zsh, Fish)</li> <li>Rich error messages with suggestions</li> <li>CLI with progress indicators</li> <li>Dry run mode and force regeneration</li> <li>Watch mode for auto-regeneration</li> <li>Configuration validation</li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>flowchart TD\n    A[\".mli file\"] --&gt; B[\"Parser&lt;br/&gt;&lt;i&gt;Parse OCaml interface&lt;/i&gt;\"]\n    B --&gt; C[\"IR&lt;br/&gt;&lt;i&gt;Language-agnostic representation&lt;/i&gt;\"]\n    C --&gt; D[\"Generators&lt;br/&gt;- Ctypes&lt;br/&gt;- C Stubs&lt;br/&gt;- Python&lt;br/&gt;- Dune&lt;br/&gt;&lt;i&gt;Generate target code&lt;/i&gt;\"]\n    D --&gt; E[\"Output&lt;br/&gt;&lt;i&gt;Ready-to-use bindings&lt;/i&gt;\"]</code></pre>"},{"location":"#use-cases","title":"Use Cases","text":"<p>Cryptography Libraries - OCaml for correctness-critical crypto - Python for easy integration</p> <p>Data Processing Pipelines - OCaml for business logic - Python for data science ecosystem</p> <p>Financial Systems - OCaml for trading algorithms - Python for analysis and reporting</p> <p>ML Infrastructure - OCaml for type-safe pipelines - Python for model training</p>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Read the guides in this directory</li> <li>GitHub Issues: https://github.com/chizy7/polyglot-ffi/issues</li> <li>Examples: See <code>examples/</code> directory in the repo</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - See LICENSE file for details.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ol> <li>New users: Start with the Quickstart Guide</li> <li>Developers: Read Architecture and Contributing</li> <li>Type system: Check Type Mapping reference</li> <li>Configuration: See Configuration guide</li> </ol> <p>Stop writing FFI boilerplate. Start building amazing things.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to Polyglot FFI will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#added","title":"Added","text":""},{"location":"CHANGELOG/#changed","title":"Changed","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":""},{"location":"CHANGELOG/#043-2025-01-30","title":"0.4.3 - 2025-01-30","text":""},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Build System (Critical):</li> <li>Fixed dune-project format error - moved comment after required <code>(lang dune 3.16)</code> declaration</li> <li>Removed incorrect manual ocamlmklib rule that conflicted with dune's ctypes extension</li> <li>Fixed include path for local headers - changed from <code>(include ...)</code> to <code>(preamble ...)</code> directive</li> <li> <p>Fixed C type const correctness - updated string parameters from <code>char*</code> to <code>const char*</code></p> </li> <li> <p>Code Generation:</p> </li> <li>Fixed ctypes function signature type mismatch - added <code>open F</code> in functor body</li> <li>Fixed unused open warning in type_description.ml</li> <li> <p>Comprehensive module name sanitization - hyphens now converted to underscores throughout</p> </li> <li> <p>Name Sanitization:</p> </li> <li>Project names with hyphens (e.g., <code>my-crypto-lib</code>) now work correctly</li> <li>Created centralized naming utility for consistent sanitization</li> <li>All generators now use sanitized names for files, libraries, and identifiers</li> <li>Applies to: Dune configs, C stubs, Python wrappers, all generated filenames</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>C stub generator now uses <code>const char*</code> for string types (improved const correctness)</li> <li>Dune generator uses preamble directive for local headers instead of include</li> <li>All generators import and use centralized <code>sanitize_module_name()</code> function</li> </ul>"},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li>Prerequisites: Added OCaml build dependencies (dune, ctypes, ctypes-foreign) to README, quickstart, and man pages</li> <li>Hyphenated Names: Documented automatic sanitization and file renaming requirements</li> <li>Troubleshooting: Added FAQ entries for common build errors:</li> <li>\"Library ctypes not found\" error and solution</li> <li>\"Invalid module name\" error with hyphenated projects</li> <li>File renaming guidance when copying sources to generated/</li> <li>Man Pages: Enhanced polyglot-ffi-generate(1) NOTES section with prerequisites and naming guidance</li> <li>Examples: Updated all examples to show correct file naming with underscores</li> </ul>"},{"location":"CHANGELOG/#technical-details","title":"Technical Details","text":"<ul> <li>End-to-end build now works successfully with no errors or warnings</li> <li>Generated bindings compile cleanly with dune</li> <li>All build artifacts (<code>.a</code>, <code>.cma</code>, <code>.cmxa</code>, <code>.so</code>) created correctly</li> <li>Full compatibility with OCaml module naming requirements</li> </ul>"},{"location":"CHANGELOG/#042-2025-01-29","title":"0.4.2 - 2025-01-29","text":""},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Verbose flag (-v/--verbose) now works in both positions for better UX</li> <li>Can now use: <code>polyglot-ffi generate file.mli -v</code> (standard position after command)</li> <li>Still works: <code>polyglot-ffi -v generate file.mli</code> (global position before command)</li> <li>Applies to all commands: init, generate, watch, check, clean</li> </ul>"},{"location":"CHANGELOG/#documentation_1","title":"Documentation","text":"<ul> <li>Updated all man pages to document verbose flag for each command</li> <li>Added verbose option to OPTIONS section in all command man pages</li> <li>Fixed verbose usage examples in FAQ documentation</li> </ul>"},{"location":"CHANGELOG/#041-2025-10-28","title":"0.4.1 - 2025-10-28","text":""},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Updated documentation URL from <code>https://chizy7.github.io/polyglot-ffi/</code> to <code>https://polyglotffi.com/</code> across all files</li> </ul>"},{"location":"CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li>Typo in ROADMAP.md (\"Ocotber\" \u2192 \"October\")</li> </ul>"},{"location":"CHANGELOG/#040-2025-10-25","title":"0.4.0 - 2025-10-25","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Testing &amp; Quality:</li> <li>262 tests (100% passing, 0 failures)</li> <li>75% code coverage across all modules</li> <li> <p>Test refactoring to use public APIs</p> </li> <li> <p>CI/CD Pipeline:</p> </li> <li>GitHub Actions workflows (CI, Release, Docs)</li> <li>Automated testing on 3 platforms \u00d7 5 Python versions</li> <li>Security scanning (safety, bandit)</li> <li>Code quality checks (black, flake8, mypy)</li> <li>Automated PyPI publishing on release</li> <li> <p>Dependabot for dependency updates</p> </li> <li> <p>Developer Experience:</p> </li> <li>Shell completions (bash, zsh, fish)</li> <li>Man pages for all commands</li> <li>Performance benchmarks (~15,000 generations/second)</li> <li>Enhanced error messages with suggestions</li> <li>Rich console output with progress indicators</li> </ul>"},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Migrated from Pydantic V1 to V2</li> <li>Updated version display in CLI to show \"polyglot-ffi\" instead of \"python -m polyglot_ffi\"</li> <li>Improved Python identifier sanitization (handles hyphens)</li> </ul>"},{"location":"CHANGELOG/#fixed_4","title":"Fixed","text":"<ul> <li>Config template mismatch between generator and validator</li> <li>Bash/fish completion installer improvements</li> <li>Better error handling in clean command</li> <li>CodeRabbit analysis issues resolved</li> </ul>"},{"location":"CHANGELOG/#030-2025-10-22","title":"[0.3.0] - 2025-10-22","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Watch Mode:</li> <li>Auto-regenerate bindings on file changes</li> <li>Optional auto-build after regeneration</li> <li> <p>Configurable watch paths</p> </li> <li> <p>Project Validation:</p> </li> <li><code>check</code> command to validate project configuration</li> <li>Dependency checking</li> <li> <p>Language-specific validation</p> </li> <li> <p>Clean Command:</p> </li> <li>Remove generated files</li> <li>Dry-run mode to preview deletions</li> <li> <p>Clean all option for directories</p> </li> <li> <p>Configuration:</p> </li> <li><code>polyglot.toml</code> configuration file support</li> <li>Project-level settings</li> <li> <p>Target language configuration</p> </li> <li> <p>Enhanced CLI:</p> </li> <li>Rich console output with colors</li> <li>Progress indicators for long operations</li> <li>Detailed error messages with suggestions</li> </ul>"},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Improved error handling across all commands</li> <li>Better user feedback during operations</li> </ul>"},{"location":"CHANGELOG/#020-2025-10-19","title":"[0.2.0] - 2025-10-19","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Complex Types Support:</li> <li>Option types (<code>'a option</code>, <code>string option</code>, <code>int option</code>)</li> <li>List types (<code>'a list</code>, <code>int list</code>, <code>string list</code>)</li> <li>Tuple types (<code>'a * 'b</code>, <code>int * string * float</code>)</li> <li>Record types (<code>type user = { name: string; age: int }</code>)</li> <li>Variant types (<code>type result = Ok of string | Error of string</code>)</li> <li>Type variables (<code>'a</code>, <code>'b</code> for polymorphic types)</li> <li>Custom type references</li> <li> <p>Nested &amp; combined types (<code>(int * string) list option</code>)</p> </li> <li> <p>Type Registry System:</p> </li> <li>Extensible type mappings</li> <li>Support for OCaml, Python, C, and Rust type mappings</li> <li>Custom type converters</li> <li> <p>Type validation and resolution</p> </li> <li> <p>Testing:</p> </li> <li>176 new tests for complex types</li> <li>65% \u2192 75% coverage increase</li> </ul>"},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>Enhanced parser to handle complex type expressions</li> <li>Improved code generation for nested types</li> <li>Better memory management for complex types in C stubs</li> </ul>"},{"location":"CHANGELOG/#010-2025-10-15","title":"[0.1.0] - 2025-10-15","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Core Functionality:</li> <li>Parse OCaml <code>.mli</code> interface files</li> <li>Generate OCaml ctypes bindings</li> <li>Generate memory-safe C stubs</li> <li>Generate Python wrapper modules with type hints</li> <li> <p>Generate Dune build configurations</p> </li> <li> <p>Primitive Types:</p> </li> <li><code>string</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>unit</code></li> <li>Multi-parameter functions</li> <li> <p>Documentation preservation</p> </li> <li> <p>CLI Commands:</p> </li> <li><code>init</code> - Initialize new project</li> <li><code>generate</code> - Generate FFI bindings</li> <li> <p><code>--help</code> - Comprehensive help system</p> </li> <li> <p>Build System:</p> </li> <li>Automatic Dune configuration generation</li> <li>OCaml build integration</li> <li> <p>Python packaging support</p> </li> <li> <p>Documentation:</p> </li> <li>README with quick start</li> <li>Architecture documentation</li> <li>Type mapping guide</li> <li>Contributing guidelines</li> </ul>"},{"location":"CHANGELOG/#technical-details_1","title":"Technical Details","text":"<ul> <li>Python 3.8+ support</li> <li>OCaml 4.14+ compatibility</li> <li>Proper CAMLparam/CAMLreturn macros</li> <li>GC-safe memory management</li> <li>Type-safe Python wrappers</li> </ul>"},{"location":"CHANGELOG/#release-categories","title":"Release Categories","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":"<p>New features or capabilities</p>"},{"location":"CHANGELOG/#changed_6","title":"Changed","text":"<p>Changes in existing functionality</p>"},{"location":"CHANGELOG/#deprecated","title":"Deprecated","text":"<p>Soon-to-be removed features</p>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<p>Removed features</p>"},{"location":"CHANGELOG/#fixed_5","title":"Fixed","text":"<p>Bug fixes</p>"},{"location":"CHANGELOG/#security","title":"Security","text":"<p>Security vulnerability fixes</p>"},{"location":"CHANGELOG/#links","title":"Links","text":"<ul> <li>PyPI</li> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant 3.0 Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We pledge to make our community welcoming, safe, and equitable for all.</p> <p>We are committed to fostering an environment that respects and promotes the dignity, rights, and contributions of all individuals, regardless of characteristics including race, ethnicity, caste, color, age, physical characteristics, neurodiversity, disability, sex or gender, gender identity or expression, sexual orientation, language, philosophy or religion, national or social origin, socio-economic position, level of education, or other status. The same privileges of participation are extended to everyone who participates in good faith and in accordance with this Covenant.</p>"},{"location":"CODE_OF_CONDUCT/#encouraged-behaviors","title":"Encouraged Behaviors","text":"<p>While acknowledging differences in social norms, we all strive to meet our community's expectations for positive behavior. We also understand that our words and actions may be interpreted differently than we intend based on culture, background, or native language.</p> <p>With these considerations in mind, we agree to behave mindfully toward each other and act in ways that center our shared values, including:</p> <ol> <li>Respecting the purpose of our community, our activities, and our ways of gathering.</li> <li>Engaging kindly and honestly with others.</li> <li>Respecting different viewpoints and experiences.</li> <li>Taking responsibility for our actions and contributions.</li> <li>Gracefully giving and accepting constructive feedback.</li> <li>Committing to repairing harm when it occurs.</li> <li>Behaving in other ways that promote and sustain the well-being of our community.</li> </ol>"},{"location":"CODE_OF_CONDUCT/#restricted-behaviors","title":"Restricted Behaviors","text":"<p>We agree to restrict the following behaviors in our community. Instances, threats, and promotion of these behaviors are violations of this Code of Conduct.</p> <ol> <li>Harassment. Violating explicitly expressed boundaries or engaging in unnecessary personal attention after any clear request to stop.</li> <li>Character attacks. Making insulting, demeaning, or pejorative comments directed at a community member or group of people.</li> <li>Stereotyping or discrimination. Characterizing anyone's personality or behavior on the basis of immutable identities or traits.</li> <li>Sexualization. Behaving in a way that would generally be considered inappropriately intimate in the context or purpose of the community.</li> <li>Violating confidentiality. Sharing or acting on someone's personal or private information without their permission.</li> <li>Endangerment. Causing, encouraging, or threatening violence or other harm toward any person or group.</li> <li>Behaving in other ways that threaten the well-being of our community.</li> </ol>"},{"location":"CODE_OF_CONDUCT/#other-restrictions","title":"Other Restrictions","text":"<ol> <li>Misleading identity. Impersonating someone else for any reason, or pretending to be someone else to evade enforcement actions.</li> <li>Failing to credit sources. Not properly crediting the sources of content you contribute.</li> <li>Promotional materials. Sharing marketing or other commercial content in a way that is outside the norms of the community.</li> <li>Irresponsible communication. Failing to responsibly present content which includes, links or describes any other restricted behaviors.</li> </ol>"},{"location":"CODE_OF_CONDUCT/#reporting-an-issue","title":"Reporting an Issue","text":"<p>Tensions can occur between community members even when they are trying their best to collaborate. Not every conflict represents a code of conduct violation, and this Code of Conduct reinforces encouraged behaviors and norms that can help avoid conflicts and minimize harm.</p> <p>When an incident does occur, it is important to report it promptly. To report a possible violation:</p> <p>Report via GitHub Issues: - Create a private issue at: https://github.com/chizy7/polyglot-ffi/issues - Label it as \"code-of-conduct\" - Provide details of the incident</p> <p>Report via Email: - Contact the project maintainer at: chizy@chizyhub.com - Include \"Code of Conduct Violation\" in the subject line</p> <p>Community Moderators take reports of violations seriously and will make every effort to respond in a timely manner. They will investigate all reports of code of conduct violations, reviewing messages, logs, and recordings, or interviewing witnesses and other participants. Community Moderators will keep investigation and enforcement actions as transparent as possible while prioritizing safety and confidentiality. In order to honor these values, enforcement actions are carried out in private with the involved parties, but communicating to the whole community may be part of a mutually agreed upon resolution.</p>"},{"location":"CODE_OF_CONDUCT/#addressing-and-repairing-harm","title":"Addressing and Repairing Harm","text":"<p>If an investigation by the Community Moderators finds that this Code of Conduct has been violated, the following enforcement ladder may be used to determine how best to repair harm, based on the incident's impact on the individuals involved and the community as a whole. Depending on the severity of a violation, lower rungs on the ladder may be skipped.</p>"},{"location":"CODE_OF_CONDUCT/#1-warning","title":"1) Warning","text":"<p>Event: A violation involving a single incident or series of incidents.</p> <p>Consequence: A private, written warning from the Community Moderators.</p> <p>Repair: Examples of repair include a private written apology, acknowledgement of responsibility, and seeking clarification on expectations.</p>"},{"location":"CODE_OF_CONDUCT/#2-temporarily-limited-activities","title":"2) Temporarily Limited Activities","text":"<p>Event: A repeated incidence of a violation that previously resulted in a warning, or the first incidence of a more serious violation.</p> <p>Consequence: A private, written warning with a time-limited cooldown period designed to underscore the seriousness of the situation and give the community members involved time to process the incident. The cooldown period may be limited to particular communication channels or interactions with particular community members.</p> <p>Repair: Examples of repair may include making an apology, using the cooldown period to reflect on actions and impact, and being thoughtful about re-entering community spaces after the period is over.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-suspension","title":"3) Temporary Suspension","text":"<p>Event: A pattern of repeated violation which the Community Moderators have tried to address with warnings, or a single serious violation.</p> <p>Consequence: A private written warning with conditions for return from suspension. In general, temporary suspensions give the person being suspended time to reflect upon their behavior and possible corrective actions.</p> <p>Repair: Examples of repair include respecting the spirit of the suspension, meeting the specified conditions for return, and being thoughtful about how to reintegrate with the community when the suspension is lifted.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4) Permanent Ban","text":"<p>Event: A pattern of repeated code of conduct violations that other steps on the ladder have failed to resolve, or a violation so serious that the Community Moderators determine there is no way to keep the community safe with this person as a member.</p> <p>Consequence: Access to all community spaces, tools, and communication channels is removed. In general, permanent bans should be rarely used, should have strong reasoning behind them, and should only be resorted to if working through other remedies has failed to change the behavior.</p> <p>Repair: There is no possible repair in cases of this severity.</p> <p>This enforcement ladder is intended as a guideline. It does not limit the ability of Community Managers to use their discretion and judgment, in keeping with the best interests of our community.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public or other spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 3.0, available at https://www.contributor-covenant.org/version/3/0/code_of_conduct.html.</p> <p>Contributor Covenant is stewarded by the Organization for Ethical Source and licensed under CC BY-SA 4.0.</p> <p>For answers to common questions about Contributor Covenant, see the FAQ at https://www.contributor-covenant.org/faq. Translations are provided at https://www.contributor-covenant.org/translations. Additional enforcement and community guideline resources can be found at https://www.contributor-covenant.org/resources. The enforcement ladder was inspired by the work of Mozilla's code of conduct team.</p>"},{"location":"DOCUMENTATION/","title":"Documentation Guide","text":"<p>This guide explains how to build, test, and deploy the Polyglot FFI documentation.</p>"},{"location":"DOCUMENTATION/#overview","title":"Overview","text":"<p>Our documentation is built with: - MkDocs - Static site generator - Material Theme - Modern, responsive design - mkdocstrings - Auto-generate API docs from Python docstrings - GitHub Pages - Hosting platform</p> <p>Live Documentation: https://polyglotffi.com/</p>"},{"location":"DOCUMENTATION/#quick-start","title":"Quick Start","text":""},{"location":"DOCUMENTATION/#install-dependencies","title":"Install Dependencies","text":"<pre><code># Install documentation dependencies\npip install mkdocs mkdocs-material mkdocstrings[python]\n\n# Or install all dev dependencies\npip install -e \".[dev]\"\npip install mkdocs mkdocs-material mkdocstrings[python]\n</code></pre>"},{"location":"DOCUMENTATION/#build-documentation","title":"Build Documentation","text":"<pre><code># Build documentation\nmkdocs build\n\n# Output: site/ directory with HTML files\n</code></pre>"},{"location":"DOCUMENTATION/#serve-locally","title":"Serve Locally","text":"<pre><code># Start local server with live reload\nmkdocs serve\n\n# Open in browser: http://127.0.0.1:8000\n</code></pre>"},{"location":"DOCUMENTATION/#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md                    # Homepage\n\u251c\u2500\u2500 quickstart.md              # Quick start guide\n\u251c\u2500\u2500 installation.md            # Installation instructions\n\u251c\u2500\u2500 configuration.md           # Configuration reference\n\u251c\u2500\u2500 quick_reference.md         # CLI quick reference\n\u251c\u2500\u2500 architecture.md            # Architecture overview\n\u251c\u2500\u2500 type-mapping.md            # Type system guide\n\u251c\u2500\u2500 contributing.md            # Contributing guidelines\n\u251c\u2500\u2500 faq.md                     # Frequently asked questions\n\u251c\u2500\u2500 CHANGELOG.md \u2192 ../         # Symlink to root\n\u251c\u2500\u2500 SECURITY.md \u2192 ../          # Symlink to root\n\u251c\u2500\u2500 CODE_OF_CONDUCT.md \u2192 ../   # Symlink to root\n\u251c\u2500\u2500 LICENSE.md \u2192 ../LICENSE    # Symlink to root\n\u2514\u2500\u2500 api/                       # API reference (auto-generated)\n    \u251c\u2500\u2500 index.md\n    \u251c\u2500\u2500 parser.md\n    \u251c\u2500\u2500 generators.md\n    \u251c\u2500\u2500 type-system.md\n    \u251c\u2500\u2500 ir-types.md\n    \u2514\u2500\u2500 config.md\n\nmkdocs.yml                     # MkDocs configuration\n</code></pre>"},{"location":"DOCUMENTATION/#file-purposes","title":"File Purposes","text":"File Purpose <code>index.md</code> Homepage with project overview <code>installation.md</code> Detailed installation instructions <code>quickstart.md</code> 5-minute getting started guide <code>configuration.md</code> Configuration file reference <code>architecture.md</code> System architecture and design <code>type-mapping.md</code> Type system mappings <code>contributing.md</code> Contribution guidelines <code>faq.md</code> Common questions and answers <code>api/*.md</code> Python API documentation"},{"location":"DOCUMENTATION/#building-documentation","title":"Building Documentation","text":""},{"location":"DOCUMENTATION/#standard-build","title":"Standard Build","text":"<pre><code># Build documentation\nmkdocs build\n\n# Output location\nls site/\n\n# Check for errors\necho $?  # Should be 0\n</code></pre>"},{"location":"DOCUMENTATION/#strict-mode","title":"Strict Mode","text":"<p>Build with warnings treated as errors:</p> <pre><code># Fail on any warnings\nmkdocs build --strict\n\n# Useful for CI/CD\n</code></pre>"},{"location":"DOCUMENTATION/#clean-build","title":"Clean Build","text":"<pre><code># Remove old build\nrm -rf site/\n\n# Clean build\nmkdocs build --clean\n</code></pre>"},{"location":"DOCUMENTATION/#serving-documentation","title":"Serving Documentation","text":""},{"location":"DOCUMENTATION/#local-development","title":"Local Development","text":"<pre><code># Start development server\nmkdocs serve\n\n# Custom port\nmkdocs serve -a 127.0.0.1:8080\n\n# Custom address (allow remote access)\nmkdocs serve -a 0.0.0.0:8000\n</code></pre> <p>Features: - Live reload on file changes - Automatic browser refresh - Fast rebuild times - Error messages in terminal</p>"},{"location":"DOCUMENTATION/#testing-changes","title":"Testing Changes","text":"<ol> <li> <p>Start server: <pre><code>mkdocs serve\n</code></pre></p> </li> <li> <p>Open browser: <pre><code>http://127.0.0.1:8000\n</code></pre></p> </li> <li> <p>Edit docs: <pre><code>vim docs/index.md\n</code></pre></p> </li> <li> <p>See changes immediately - browser auto-refreshes!</p> </li> </ol>"},{"location":"DOCUMENTATION/#configuration","title":"Configuration","text":""},{"location":"DOCUMENTATION/#mkdocsyml","title":"mkdocs.yml","text":"<p>Main configuration file:</p> <pre><code>site_name: Polyglot FFI Documentation\nsite_url: https://polyglotffi.com/\nrepo_url: https://github.com/chizy7/polyglot-ffi\n\ntheme:\n  name: material\n  palette:\n    - scheme: default      # Light mode\n    - scheme: slate        # Dark mode\n  features:\n    - navigation.tabs\n    - navigation.sections\n    - search.suggest\n    - content.code.copy\n\nplugins:\n  - search\n  - mkdocstrings\n\nnav:\n  - Home: index.md\n  - Getting Started: ...\n  - API Reference: ...\n</code></pre>"},{"location":"DOCUMENTATION/#theme-customization","title":"Theme Customization","text":"<p>Edit <code>mkdocs.yml</code> to customize:</p> <pre><code>theme:\n  name: material\n  palette:\n    primary: indigo      # Primary color\n    accent: indigo       # Accent color\n  font:\n    text: Roboto        # Body font\n    code: Roboto Mono   # Code font\n  logo: assets/logo.png # Custom logo\n  favicon: assets/favicon.ico\n</code></pre>"},{"location":"DOCUMENTATION/#api-documentation","title":"API Documentation","text":""},{"location":"DOCUMENTATION/#auto-generated-api-docs","title":"Auto-Generated API Docs","text":"<p>We use <code>mkdocstrings</code> to generate API docs from Python docstrings:</p> <pre><code>&lt;!-- In docs/api/parser.md --&gt;\n\n::: polyglot_ffi.parsers.ocaml.parse_mli_file\n    options:\n      show_source: true\n      show_root_heading: true\n</code></pre>"},{"location":"DOCUMENTATION/#writing-docstrings","title":"Writing Docstrings","text":"<p>Good docstring example:</p> <pre><code>def parse_mli_file(file_path: Path) -&gt; IRModule:\n    \"\"\"\n    Parse an OCaml interface file (.mli) into an IR module.\n\n    Args:\n        file_path: Path to the .mli file to parse\n\n    Returns:\n        IRModule: Parsed module containing functions and types\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ParseError: If the file has syntax errors\n\n    Example:\n        ```python\n        from pathlib import Path\n        from polyglot_ffi.parsers import parse_mli_file\n\n        module = parse_mli_file(Path(\"crypto.mli\"))\n        print(f\"Found {len(module.functions)} functions\")\n        ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"DOCUMENTATION/#updating-api-docs","title":"Updating API Docs","text":"<p>API docs are auto-generated from code:</p> <ol> <li>Update Python docstrings in source code</li> <li>Rebuild docs: <code>mkdocs build</code></li> <li>API docs update automatically!</li> </ol> <p>No need to manually edit <code>docs/api/*.md</code> files for docstring changes.</p>"},{"location":"DOCUMENTATION/#testing-documentation","title":"Testing Documentation","text":""},{"location":"DOCUMENTATION/#check-for-broken-links","title":"Check for Broken Links","text":"<pre><code># Build first\nmkdocs build\n\n# Install link checker\npip install linkchecker\n\n# Check for broken links\nlinkchecker site/\n\n# Or specific page\nlinkchecker site/index.html\n</code></pre>"},{"location":"DOCUMENTATION/#validate-markdown","title":"Validate Markdown","text":"<pre><code># Install markdown linter\nnpm install -g markdownlint-cli\n\n# Check markdown files\nmarkdownlint docs/**/*.md\n\n# Fix automatically\nmarkdownlint --fix docs/**/*.md\n</code></pre>"},{"location":"DOCUMENTATION/#spell-check","title":"Spell Check","text":"<pre><code># Install spell checker\npip install pyspelling\n\n# Create .pyspelling.yml config\n# Run spell check\npyspelling\n</code></pre>"},{"location":"DOCUMENTATION/#test-locally-before-push","title":"Test Locally Before Push","text":"<p>Checklist:</p> <pre><code># 1. Clean build\nrm -rf site/\nmkdocs build --strict\n\n# 2. Check for errors\necho $?  # Should be 0\n\n# 3. Serve locally\nmkdocs serve\n\n# 4. Test in browser\n# - Navigation works\n# - Search works\n# - Code highlighting works\n# - Links work\n\n# 5. Check specific pages\n# - Homepage\n# - Installation\n# - API docs\n# - FAQ\n\n# 6. Test responsiveness\n# - Desktop view\n# - Mobile view (browser dev tools)\n</code></pre>"},{"location":"DOCUMENTATION/#deployment","title":"Deployment","text":""},{"location":"DOCUMENTATION/#automatic-deployment-github-actions","title":"Automatic Deployment (GitHub Actions)","text":"<p>Documentation is automatically deployed when you push to <code>master</code>:</p> <pre><code># .github/workflows/docs.yml\n- Push to master with doc changes\n  \u2193\n- GitHub Actions triggers\n  \u2193\n- mkdocs build\n  \u2193\n- mkdocs gh-deploy\n  \u2193\n- Published to GitHub Pages!\n</code></pre> <p>URL: https://polyglotffi.com/</p>"},{"location":"DOCUMENTATION/#manual-deployment","title":"Manual Deployment","text":"<p>If you need to deploy manually:</p> <pre><code># Build and deploy to gh-pages branch\nmkdocs gh-deploy\n\n# With custom commit message\nmkdocs gh-deploy -m \"Update documentation for v0.5.0\"\n\n# Force push (use with caution)\nmkdocs gh-deploy --force\n</code></pre> <p>What this does: 1. Builds documentation to <code>site/</code> 2. Pushes to <code>gh-pages</code> branch 3. GitHub Pages automatically publishes</p>"},{"location":"DOCUMENTATION/#deployment-with-versioning","title":"Deployment with Versioning","text":"<p>For versioned docs (on releases):</p> <pre><code># Install mike (version manager)\npip install mike\n\n# Deploy version 0.4.0 as 'latest'\nmike deploy 0.4.0 latest\n\n# Set default version\nmike set-default latest\n\n# Deploy and push\nmike deploy 0.4.0 latest --push\n</code></pre> <p>Result: - <code>/latest/</code> \u2192 points to 0.4.0 - <code>/0.4.0/</code> \u2192 version 0.4.0 - <code>/0.3.0/</code> \u2192 version 0.3.0 (previous)</p>"},{"location":"DOCUMENTATION/#common-tasks","title":"Common Tasks","text":""},{"location":"DOCUMENTATION/#add-a-new-page","title":"Add a New Page","text":"<ol> <li> <p>Create markdown file: <pre><code>vim docs/new-page.md\n</code></pre></p> </li> <li> <p>Add to navigation: <pre><code># mkdocs.yml\nnav:\n  - Home: index.md\n  - New Page: new-page.md  # Add here\n</code></pre></p> </li> <li> <p>Build and test: <pre><code>mkdocs serve\n</code></pre></p> </li> </ol>"},{"location":"DOCUMENTATION/#add-images","title":"Add Images","text":"<ol> <li> <p>Create assets directory: <pre><code>mkdir -p docs/assets/images\n</code></pre></p> </li> <li> <p>Add image: <pre><code>cp screenshot.png docs/assets/images/\n</code></pre></p> </li> <li> <p>Reference in markdown: <pre><code>![Screenshot](assets/images/screenshot.png)\n</code></pre></p> </li> </ol>"},{"location":"DOCUMENTATION/#add-code-examples","title":"Add Code Examples","text":"<pre><code>```python\n# Python code\nfrom polyglot_ffi import parse_mli_file\n\nmodule = parse_mli_file(\"api.mli\")\n```\n\n```ocaml\n(* OCaml code *)\nval greet : string -&gt; string\n```\n</code></pre>"},{"location":"DOCUMENTATION/#add-admonitions","title":"Add Admonitions","text":"<pre><code>!!! note\n    This is a note\n\n!!! warning\n    This is a warning\n\n!!! tip\n    This is a helpful tip\n\n!!! danger\n    This is dangerous!\n</code></pre>"},{"location":"DOCUMENTATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"DOCUMENTATION/#build-fails","title":"Build Fails","text":"<p>Error: <code>Module 'polyglot_ffi' not found</code></p> <p>Solution: <pre><code># Install package in editable mode\npip install -e .\n\n# Then build\nmkdocs build\n</code></pre></p>"},{"location":"DOCUMENTATION/#links-not-working","title":"Links Not Working","text":"<p>Error: <code>WARNING - Doc file contains broken link</code></p> <p>Solution: <pre><code># Check the link path\n# Relative to current file:\n[Link](../other-page.md)\n\n# Or absolute from docs/:\n[Link](/installation.md)\n</code></pre></p>"},{"location":"DOCUMENTATION/#theme-not-loading","title":"Theme Not Loading","text":"<p>Error: <code>Theme 'material' not found</code></p> <p>Solution: <pre><code># Install theme\npip install mkdocs-material\n\n# Verify installation\npip show mkdocs-material\n</code></pre></p>"},{"location":"DOCUMENTATION/#search-not-working","title":"Search Not Working","text":"<p>Error: Search returns no results</p> <p>Solution: <pre><code># Make sure search plugin is enabled\n# in mkdocs.yml:\nplugins:\n  - search\n\n# Rebuild\nmkdocs build --clean\n</code></pre></p>"},{"location":"DOCUMENTATION/#slow-build-times","title":"Slow Build Times","text":"<p>Solution: <pre><code># Use serve mode (faster rebuilds)\nmkdocs serve\n\n# Or disable plugins temporarily\n# Comment out in mkdocs.yml:\nplugins:\n  - search\n  # - mkdocstrings  # Disable for speed\n</code></pre></p>"},{"location":"DOCUMENTATION/#best-practices","title":"Best Practices","text":""},{"location":"DOCUMENTATION/#writing-good-documentation","title":"Writing Good Documentation","text":"<ol> <li>Be Clear and Concise</li> <li>Short sentences</li> <li>Active voice</li> <li> <p>Simple language</p> </li> <li> <p>Use Examples</p> </li> <li>Code snippets</li> <li>Real-world scenarios</li> <li> <p>Before/after comparisons</p> </li> <li> <p>Structure Well</p> </li> <li>Use headings (##, ###)</li> <li>Short paragraphs</li> <li> <p>Lists and tables</p> </li> <li> <p>Test Your Examples</p> </li> <li>All code should work</li> <li>Copy-pasteable</li> <li>Up-to-date</li> </ol>"},{"location":"DOCUMENTATION/#markdown-style","title":"Markdown Style","text":"<pre><code># Use ATX-style headings\n## Not underlines\n---\n\nUse **bold** for emphasis, not *italics* for UI elements\n\nUse `code` for:\n- Commands: `polyglot-ffi init`\n- File names: `config.toml`\n- Code: `def foo():`\n\nUse fenced code blocks:\n````python\ndef example():\n    pass\n````\n</code></pre>"},{"location":"DOCUMENTATION/#documentation-workflow","title":"Documentation Workflow","text":"<ol> <li>Plan: What needs documenting?</li> <li>Write: Create/update markdown files</li> <li>Review: Read through as a user</li> <li>Test: <code>mkdocs serve</code> and check</li> <li>Build: <code>mkdocs build --strict</code></li> <li>Commit: Git commit with clear message</li> <li>Push: Automatic deployment!</li> </ol>"},{"location":"DOCUMENTATION/#resources","title":"Resources","text":""},{"location":"DOCUMENTATION/#mkdocs","title":"MkDocs","text":"<ul> <li>Documentation: https://www.mkdocs.org/</li> <li>Material Theme: https://squidfunk.github.io/mkdocs-material/</li> <li>Plugins: https://github.com/mkdocs/mkdocs/wiki/MkDocs-Plugins</li> </ul>"},{"location":"DOCUMENTATION/#writing","title":"Writing","text":"<ul> <li>Markdown Guide: https://www.markdownguide.org/</li> <li>Style Guide: https://google.github.io/styleguide/docguide/style.html</li> <li>API Docs Guide: https://www.divio.com/blog/documentation/</li> </ul>"},{"location":"DOCUMENTATION/#tools","title":"Tools","text":"<ul> <li>Link Checker: https://linkchecker.github.io/linkchecker/</li> <li>Spell Checker: https://facelessuser.github.io/pyspelling/</li> <li>Markdown Linter: https://github.com/DavidAnson/markdownlint</li> </ul>"},{"location":"DOCUMENTATION/#getting-help","title":"Getting Help","text":"<ul> <li>MkDocs Issues: https://github.com/mkdocs/mkdocs/issues</li> <li>Material Theme: https://github.com/squidfunk/mkdocs-material/discussions</li> <li>Our Issues: https://github.com/chizy7/polyglot-ffi/issues</li> </ul>"},{"location":"DOCUMENTATION/#quick-reference","title":"Quick Reference","text":"<pre><code># Development\nmkdocs serve              # Live preview\nmkdocs build              # Build site\nmkdocs build --strict     # Strict build (fail on warnings)\n\n# Deployment\nmkdocs gh-deploy          # Deploy to GitHub Pages\nmike deploy VERSION       # Deploy versioned docs\n\n# Maintenance\nrm -rf site/              # Clean build\nmkdocs build --clean      # Clean + build\n\n# Testing\nlinkchecker site/         # Check for broken links\nmarkdownlint docs/        # Lint markdown files\n</code></pre> <p>Last Updated: October 2025</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Chizaram Chibueze</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"ROADMAP/","title":"Polyglot FFI Roadmap","text":"<p>Vision: The universal FFI bindings generator for polyglot projects</p>"},{"location":"ROADMAP/#overview","title":"Overview","text":"<p>Polyglot FFI aims to eliminate FFI boilerplate by automatically generating type-safe, memory-safe bindings between programming languages. Our goal is to support multiple source and target languages with excellent developer experience.</p>"},{"location":"ROADMAP/#current-status-v043-in-production","title":"Current Status: v0.4.3 - In Production","text":"<ul> <li>285 tests passing (88% coverage)</li> <li>Complete documentation</li> <li>Full CI/CD automation</li> <li>Ready for PyPI release</li> </ul>"},{"location":"ROADMAP/#completed-milestones","title":"Completed Milestones","text":""},{"location":"ROADMAP/#v01-foundation","title":"v0.1 - Foundation","text":"<p>Internal Validation (Battle-Tested Locally): October 2025</p> <p>Core Features:</p> <ul> <li>OCaml <code>.mli</code> parser for primitive types</li> <li>Python wrapper generation</li> <li>OCaml ctypes bindings generation</li> <li>C stub generation with memory safety</li> <li>CLI with <code>init</code> and <code>generate</code> commands</li> <li>Basic error handling</li> <li>44% test coverage baseline</li> </ul> <p>Deliverable: Working OCaml\u2192Python bindings for simple functions</p>"},{"location":"ROADMAP/#v02-type-system","title":"v0.2 - Type System","text":"<p>Internal Validation (Battle-Tested Locally): October 2025</p> <p>Complex Types:</p> <ul> <li>Option types (<code>'a option</code>)</li> <li>List types (<code>'a list</code>)</li> <li>Tuple types (<code>'a * 'b</code>)</li> <li>Record types (parsed, partial generation)</li> <li>Variant types (parsed, partial generation)</li> </ul> <p>Type System:</p> <ul> <li>Type registry architecture</li> <li>Extensible type mappings</li> <li>Custom type converters</li> <li>Multi-language support (OCaml, Python, C, Rust types)</li> </ul> <p>Testing:</p> <ul> <li>86 tests (+42 from v0.1)</li> <li>65% coverage (+21%)</li> <li>Complex type scenarios</li> </ul> <p>Deliverable: Can handle 90% of OCaml types</p>"},{"location":"ROADMAP/#v03-developer-experience","title":"v0.3 - Developer Experience","text":"<p>Internal Validation (Battle-Tested Locally): October 2025</p> <p>New Commands:</p> <ul> <li><code>watch</code> - Auto-regenerate on file changes</li> <li><code>check</code> - Validate project configuration and dependencies</li> <li><code>clean</code> - Remove generated files safely</li> </ul> <p>Configuration:</p> <ul> <li><code>polyglot.toml</code> configuration file support</li> <li>Auto-discovery of <code>.mli</code> files</li> <li>Per-language configuration</li> <li>Custom type mappings in config</li> </ul> <p>Developer Experience:</p> <ul> <li>Rich CLI output with colors</li> <li>Progress indicators for long operations</li> <li>Detailed error messages with suggestions</li> <li>Dry-run mode for preview</li> <li>Force regeneration option</li> </ul> <p>Deliverable: Improved DX</p>"},{"location":"ROADMAP/#v04-production-release-q4-2025","title":"v0.4 - Production Release (Q4 2025)","text":"<p>Released: October 2025</p> <p>Testing &amp; Quality:</p> <ul> <li>285 tests (+199 from v0.3)</li> <li>88% coverage (+23%)</li> <li>Integration tests for all CLI commands</li> <li>End-to-end workflow tests</li> </ul> <p>Documentation:</p> <ul> <li>Complete MkDocs documentation site</li> <li>API reference with mkdocstrings</li> <li>3 working examples (beginner to intermediate)</li> <li>Architecture documentation</li> <li>Contributing guidelines</li> <li>7 man pages for all commands</li> </ul> <p>Polish:</p> <ul> <li>Shell completion (Bash, Zsh, Fish)</li> <li>Performance optimization (~15,000 gen/sec)</li> <li>Better identifier sanitization</li> <li>Config template fixes</li> </ul> <p>CI/CD &amp; Publishing:</p> <ul> <li>GitHub Actions workflows (test, docs, release)</li> <li>Automated releases on tag</li> <li>Documentation deployment to GitHub Pages</li> <li>PyPI package builds successfully</li> <li>Security scanning (bandit, safety)</li> </ul> <p>Open Source:</p> <ul> <li>Code of Conduct (Contributor Covenant v3.0)</li> <li>Security policy</li> <li>Issue templates (4 types)</li> <li>Pull request template</li> <li>CODEOWNERS file</li> </ul> <p>Deliverable: Ready for public release on PyPI</p>"},{"location":"ROADMAP/#current-focus-v040-release","title":"Current Focus: v0.4.0 Release","text":""},{"location":"ROADMAP/#immediate-tasks","title":"Immediate Tasks","text":"<p>Goal: First PyPI release</p> <ul> <li>[x] Final testing and verification</li> <li>[x] Documentation review and polish</li> <li>[x] Package building and validation</li> <li>[x] Create v0.4.0 release tag</li> <li>[x] Publish to PyPI</li> <li>[x] Deploy documentation</li> <li>[x] Announce release</li> </ul> <p>Success Metrics:</p> <ul> <li>Package available on PyPI</li> <li>Documentation live at polyglotffi.com</li> <li>Can install with <code>pip install polyglot-ffi</code></li> </ul>"},{"location":"ROADMAP/#planned-milestones","title":"Planned Milestones","text":""},{"location":"ROADMAP/#v050-record-variant-support-q4-2025","title":"v0.5.0 - Record &amp; Variant Support (Q4 2025)","text":"<p>Target: October-December 2025</p> <p>Advanced Type Generation:</p> <ul> <li>[ ] Complete record type generation</li> <li>[ ] OCaml record type definitions</li> <li>[ ] Python dataclass generation</li> <li>[ ] C struct generation</li> <li>[ ] Memory management for nested records</li> <li>[ ] Complete variant type generation</li> <li>[ ] OCaml variant types</li> <li>[ ] Python enum/union types</li> <li>[ ] C tagged unions</li> <li>[ ] Pattern matching helpers</li> </ul> <p>Type System Enhancements:</p> <ul> <li>[ ] Polymorphic types (<code>'a</code>)</li> <li>[ ] Constrained types</li> <li>[ ] Recursive types</li> <li>[ ] Type aliases</li> </ul> <p>Testing:</p> <ul> <li>[ ] Record type test suite</li> <li>[ ] Variant type test suite</li> <li>[ ] Complex nested type tests</li> <li>[ ] Memory safety validation</li> </ul> <p>Deliverable: Full support for OCaml's rich type system</p>"},{"location":"ROADMAP/#v060-rust-target-support-q4-2025","title":"v0.6.0 - Rust Target Support (Q4 2025)","text":"<p>Target: TBD (Late 2025)</p> <p>Rust Generator:</p> <ul> <li>[ ] Rust FFI bindings generation</li> <li>[ ] <code>extern \"C\"</code> declarations</li> <li>[ ] Rust type mappings</li> <li>[ ] <code>unsafe</code> blocks with safety guarantees</li> <li>[ ] Cargo.toml generation</li> </ul> <p>Bidirectional Support:</p> <ul> <li>[ ] OCaml \u2192 Rust bindings</li> <li>[ ] Rust \u2192 Python bindings</li> <li>[ ] Type conversions</li> </ul> <p>Build Integration:</p> <ul> <li>[ ] Cargo build system support</li> <li>[ ] Cross-compilation support</li> <li>[ ] Dependency management</li> </ul> <p>Documentation:</p> <ul> <li>[ ] Rust examples</li> <li>[ ] Type mapping guide for Rust</li> <li>[ ] Build system integration guide</li> </ul> <p>Deliverable: Full support for Rust bindings</p>"},{"location":"ROADMAP/#v100-stable-release-q1-2026","title":"v1.0.0 - Stable Release (Q1 2026)","text":"<p>Target: January-March 2026</p> <p>Stability:</p> <ul> <li>[ ] API stability guarantees</li> <li>[ ] Comprehensive upgrade guides</li> <li>[ ] Long-term support (LTS) commitment</li> <li>[ ] Performance benchmarks published</li> </ul> <p>Multi-Language Matrix:</p> <ul> <li>[ ] OCaml \u2194 Python (complete)</li> <li>[ ] OCaml \u2194 Rust (complete)</li> <li>[ ] Python \u2192 OCaml (reverse direction)</li> <li>[ ] Rust \u2192 OCaml (reverse direction)</li> </ul> <p>Enterprise Features:</p> <ul> <li>[ ] Large project support (multi-module)</li> <li>[ ] Incremental generation</li> <li>[ ] Build cache</li> <li>[ ] Parallel generation</li> </ul> <p>Testing &amp; Quality:</p> <ul> <li>[ ] 95%+ code coverage</li> <li>[ ] 500+ tests</li> <li>[ ] Cross-platform CI (Linux, macOS, Windows)</li> <li>[ ] Performance regression tests</li> </ul> <p>Documentation:</p> <ul> <li>[ ] Video tutorials</li> <li>[ ] Interactive examples</li> <li>[ ] Migration guides</li> <li>[ ] Best practices guide</li> </ul> <p>Deliverable: Stable, production-ready v1.0</p>"},{"location":"ROADMAP/#v150-go-support-q2-2026","title":"v1.5.0 - Go Support (Q2 2026)","text":"<p>Target: April-June 2026</p> <p>Go Generator:</p> <ul> <li>[ ] Go FFI bindings generation</li> <li>[ ] <code>cgo</code> integration</li> <li>[ ] Go type mappings</li> <li>[ ] Go module generation</li> </ul> <p>Language Support:</p> <ul> <li>[ ] OCaml \u2192 Go</li> <li>[ ] Python \u2192 Go</li> <li>[ ] Rust \u2192 Go</li> <li>[ ] Go \u2192 all (reverse)</li> </ul> <p>Build Integration:</p> <ul> <li>[ ] Go modules support</li> <li>[ ] go.mod generation</li> <li>[ ] Cross-platform builds</li> </ul> <p>Deliverable: Full Go language support</p>"},{"location":"ROADMAP/#v200-advanced-features-2026","title":"v2.0.0 - Advanced Features (2026)","text":"<p>Target: Q1-Q2 2026</p> <p>Plugin System:</p> <ul> <li>[ ] Plugin architecture</li> <li>[ ] Community plugin support</li> <li>[ ] Custom generator plugins</li> <li>[ ] Custom parser plugins</li> <li>[ ] Plugin marketplace/registry</li> </ul> <p>Developer Tools:</p> <ul> <li>[ ] Interactive REPL mode</li> <li>[ ] Language Server Protocol (LSP)</li> <li>[ ] VS Code extension</li> <li>[ ] JetBrains plugin</li> <li>[ ] Syntax highlighting</li> </ul> <p>Advanced Types:</p> <ul> <li>[ ] GADTs (Generalized Algebraic Data Types)</li> <li>[ ] Module functors</li> <li>[ ] First-class modules</li> <li>[ ] Polymorphic variants</li> <li>[ ] Object types</li> </ul> <p>Performance:</p> <ul> <li>[ ] Parallel generation</li> <li>[ ] Incremental compilation</li> <li>[ ] Smart caching</li> <li>[ ] Memory optimization</li> </ul> <p>Deliverable: Advanced tooling and type support</p>"},{"location":"ROADMAP/#future-exploration-post-v20","title":"Future Exploration (Post v2.0)","text":""},{"location":"ROADMAP/#additional-language-targets","title":"Additional Language Targets","text":"<p>Priority: Community-Driven</p> <ul> <li>[ ] Java/Kotlin via JNI</li> <li>[ ] Java class generation</li> <li>[ ] Kotlin extension functions</li> <li> <p>[ ] Gradle integration</p> </li> <li> <p>[ ] C++ with modern features</p> </li> <li>[ ] C++17/20 support</li> <li>[ ] Smart pointers</li> <li>[ ] Template support</li> <li> <p>[ ] CMake integration</p> </li> <li> <p>[ ] JavaScript/TypeScript via WASM</p> </li> <li>[ ] WebAssembly target</li> <li>[ ] TypeScript definitions</li> <li>[ ] npm package generation</li> <li> <p>[ ] Node.js native modules</p> </li> <li> <p>[ ] C#/.NET via P/Invoke</p> </li> <li>[ ] C# class generation</li> <li>[ ] .NET Core support</li> <li> <p>[ ] NuGet packages</p> </li> <li> <p>[ ] Swift for iOS/macOS</p> </li> <li>[ ] Swift bindings</li> <li>[ ] Objective-C bridge</li> <li>[ ] SwiftPM integration</li> </ul>"},{"location":"ROADMAP/#advanced-features","title":"Advanced Features","text":"<p>Priority: Based on User Demand</p> <ul> <li>[ ] Async/Await Support</li> <li>[ ] Async FFI boundaries</li> <li>[ ] Future/Promise conversion</li> <li> <p>[ ] Event loop integration</p> </li> <li> <p>[ ] Memory Pooling</p> </li> <li>[ ] Custom allocators</li> <li>[ ] Pool-based memory management</li> <li> <p>[ ] Zero-copy optimizations</p> </li> <li> <p>[ ] Serialization</p> </li> <li>[ ] Auto-generate serialization code</li> <li>[ ] JSON/Protobuf/MessagePack</li> <li> <p>[ ] Zero-copy serialization</p> </li> <li> <p>[ ] Distributed Systems</p> </li> <li>[ ] RPC code generation</li> <li>[ ] gRPC support</li> <li>[ ] Network protocol bindings</li> </ul>"},{"location":"ROADMAP/#ecosystem-integration","title":"Ecosystem Integration","text":"<p>Priority: Community Partnerships</p> <ul> <li>[ ] Package Manager Integration</li> <li>[ ] Homebrew formula</li> <li>[ ] apt/yum packages</li> <li>[ ] Windows installer</li> <li> <p>[ ] Nix package</p> </li> <li> <p>[ ] Cloud Services</p> </li> <li>[ ] AWS Lambda bindings</li> <li>[ ] Google Cloud Functions</li> <li> <p>[ ] Azure Functions</p> </li> <li> <p>[ ] Build System Plugins</p> </li> <li>[ ] CMake plugin</li> <li>[ ] Bazel rules</li> <li>[ ] Meson integration</li> <li>[ ] Make integration</li> </ul>"},{"location":"ROADMAP/#technology-roadmap","title":"Technology Roadmap","text":""},{"location":"ROADMAP/#short-term-2025","title":"Short-term (2025)","text":"<ul> <li>[x] Python 3.8-3.12 support</li> <li>[x] OCaml 4.14+ support</li> <li>[ ] Python 3.13 support</li> <li>[ ] OCaml 5.x support</li> <li>[ ] Rust 1.70+ support</li> </ul>"},{"location":"ROADMAP/#medium-term-2026","title":"Medium-term (2026)","text":"<ul> <li>[ ] WASM compilation target</li> <li>[ ] Cloud-native deployment</li> <li>[ ] Container optimization</li> <li>[ ] Performance: 100,000+ gen/sec</li> </ul>"},{"location":"ROADMAP/#long-term-2027","title":"Long-term (2027+)","text":"<ul> <li>[ ] Machine learning optimization</li> <li>[ ] Intelligent type inference</li> <li>[ ] Auto-migration tools</li> <li>[ ] Self-hosting (polyglot-ffi generates its own bindings)</li> </ul>"},{"location":"ROADMAP/#community-roadmap","title":"Community Roadmap","text":""},{"location":"ROADMAP/#open-source-growth","title":"Open Source Growth","text":"<ul> <li>[ ] 100+ GitHub stars</li> <li>[ ] 10+ contributors</li> <li>[ ] Community Slack/Discord</li> <li>[ ] Monthly releases</li> <li>[ ] Quarterly community calls</li> </ul>"},{"location":"ROADMAP/#documentation-education","title":"Documentation &amp; Education","text":"<ul> <li>[ ] Video tutorial series</li> <li>[ ] Interactive playground</li> <li>[ ] University course materials</li> <li>[ ] Conference talks</li> <li>[ ] Blog post series</li> </ul>"},{"location":"ROADMAP/#adoption-goals","title":"Adoption Goals","text":"<ul> <li>[ ] 50+ production users</li> <li>[ ] 5+ case studies</li> <li>[ ] Industry partnerships</li> <li>[ ] Academic research citations</li> </ul>"},{"location":"ROADMAP/#success-metrics","title":"Success Metrics","text":""},{"location":"ROADMAP/#technical-metrics","title":"Technical Metrics","text":"Metric v0.4.0 (Current) v1.0 Goal v2.0 Goal Test Coverage 88% 95% 98% Tests 285 500+ 1000+ Languages 3* 4 6+ Gen Speed 15k/sec 50k/sec 100k/sec Supported Types 90% 98% 100% <p>*OCaml, Python, C (Rust types mapped but not generated yet)</p>"},{"location":"ROADMAP/#community-metrics","title":"Community Metrics","text":"Metric v0.4.0 v1.0 Goal v2.0 Goal GitHub Stars TBD 100+ 500+ Contributors 1 10+ 25+ Production Users 0 50+ 200+ Weekly Downloads 0 1000+ 5000+"},{"location":"ROADMAP/#how-to-contribute","title":"How to Contribute","text":"<p>We welcome contributions to any part of the roadmap! Here's how you can help:</p>"},{"location":"ROADMAP/#current-priorities","title":"Current Priorities","text":"<ol> <li>Testing: Add test cases for edge cases</li> <li>Documentation: Improve examples and guides</li> <li>Bug Reports: Help us find and fix issues</li> <li>Feature Requests: Tell us what you need</li> </ol>"},{"location":"ROADMAP/#future-features","title":"Future Features","text":"<ul> <li>Rust Support: Help implement Rust generator (v0.6.0)</li> <li>Record Types: Complete record type generation (v0.5.0)</li> <li>New Languages: Propose and implement new language targets</li> </ul>"},{"location":"ROADMAP/#get-involved","title":"Get Involved","text":"<ul> <li>Issues: https://github.com/chizy7/polyglot-ffi/issues</li> <li>Discussions: https://github.com/chizy7/polyglot-ffi/discussions</li> <li>Contributing: See CONTRIBUTING.md</li> <li>Code of Conduct: CODE_OF_CONDUCT.md</li> </ul>"},{"location":"ROADMAP/#release-schedule-projected","title":"Release Schedule (Projected)","text":""},{"location":"ROADMAP/#regular-releases","title":"Regular Releases","text":"<ul> <li>Minor releases (0.x.0): Every 6-8 weeks</li> <li>Patch releases (0.x.y): As needed for bugs</li> <li>Major releases (x.0.0): Every 12-18 months</li> </ul>"},{"location":"ROADMAP/#lts-support","title":"LTS Support","text":"<ul> <li>v1.0: 2 years of support</li> <li>v2.0: 3 years of support</li> <li>Security patches: Indefinite for v1.0+</li> </ul>"},{"location":"ROADMAP/#versioning-policy","title":"Versioning Policy","text":"<p>We follow Semantic Versioning:</p> <ul> <li>Major (x.0.0): Breaking changes</li> <li>Minor (0.x.0): New features, backwards compatible</li> <li>Patch (0.0.x): Bug fixes, backwards compatible</li> </ul>"},{"location":"ROADMAP/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Announced 3 months in advance</li> <li>Migration guides provided</li> <li>Deprecation warnings in previous release</li> <li>Community feedback period</li> </ul>"},{"location":"ROADMAP/#references-inspiration","title":"References &amp; Inspiration","text":"<ul> <li>PyO3: Rust \u2194 Python bindings architecture</li> <li>SWIG: Multi-language wrapper generator</li> <li>ctypes: OCaml FFI foundation</li> <li>bindgen: Rust binding generator</li> <li>JNI: Java native interface patterns</li> </ul>"},{"location":"ROADMAP/#questions-feedback","title":"Questions &amp; Feedback","text":"<p>Have ideas for the roadmap? Want to influence priorities?</p> <ul> <li>Feature Requests: https://github.com/chizy7/polyglot-ffi/issues/new?template=feature_request.yml</li> <li>Discussions: https://github.com/chizy7/polyglot-ffi/discussions</li> <li>Email: See GitHub profile</li> </ul> <p>Last Updated: October 25, 2025 Next Review: December 2025</p> <p>Current Focus: Fix bugs in v0.4.3 and publish to PyPI and grow the community!</p>"},{"location":"SECURITY/","title":"Security Policy","text":""},{"location":"SECURITY/#supported-versions","title":"Supported Versions","text":"<p>We release patches for security vulnerabilities for the following versions:</p> Version Supported 0.4.x \u2705 0.3.x \u2705 0.2.x \u274c 0.1.x \u274c &lt; 0.1 \u274c"},{"location":"SECURITY/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>We take the security of Polyglot FFI seriously. If you believe you have found a security vulnerability, please report it to us as described below.</p>"},{"location":"SECURITY/#where-to-report","title":"Where to Report","text":"<p>Please do NOT report security vulnerabilities through public GitHub issues.</p> <p>Instead, please report them via:</p> <ol> <li>GitHub Security Advisories (Preferred):</li> <li>Go to https://github.com/chizy7/polyglot-ffi/security/advisories</li> <li>Click \"Report a vulnerability\"</li> <li> <p>Fill out the form with details</p> </li> <li> <p>Email:</p> </li> <li>Send email to the maintainer at: chizy@chizyhub.com</li> <li>Include \"SECURITY\" in the subject line</li> </ol>"},{"location":"SECURITY/#what-to-include","title":"What to Include","text":"<p>Please include the following information in your report:</p> <ul> <li>Description: A clear description of the vulnerability</li> <li>Impact: What an attacker could achieve by exploiting this</li> <li>Steps to Reproduce: Detailed steps to reproduce the vulnerability</li> <li>Affected Versions: Which versions are affected</li> <li>Proof of Concept: Code or commands demonstrating the issue (if applicable)</li> <li>Suggested Fix: If you have ideas on how to fix it (optional)</li> </ul>"},{"location":"SECURITY/#what-to-expect","title":"What to Expect","text":"<ul> <li>Acknowledgment: We'll acknowledge receipt within 48 hours</li> <li>Initial Assessment: We'll provide an initial assessment within 1 week</li> <li>Updates: We'll keep you informed of progress</li> <li>Resolution: We aim to release a fix within 30 days for critical issues</li> <li>Credit: We'll credit you in the security advisory (unless you prefer to remain anonymous)</li> </ul>"},{"location":"SECURITY/#security-update-process","title":"Security Update Process","text":"<p>When we receive a security report:</p> <ol> <li>Confirm the vulnerability and determine affected versions</li> <li>Develop a fix and create a security patch</li> <li>Test the fix thoroughly</li> <li>Release a new version with the security patch</li> <li>Publish a security advisory on GitHub</li> <li>Notify users through release notes and changelog</li> </ol>"},{"location":"SECURITY/#security-best-practices","title":"Security Best Practices","text":"<p>When using Polyglot FFI:</p>"},{"location":"SECURITY/#for-users","title":"For Users","text":"<ol> <li> <p>Keep Updated: Always use the latest stable version    <pre><code>pip install --upgrade polyglot-ffi\n</code></pre></p> </li> <li> <p>Validate Input: Always validate OCaml interface files from untrusted sources</p> </li> <li> <p>Review Generated Code: Review generated bindings before deploying to production</p> </li> <li> <p>Sandboxed Testing: Test generated code in isolated environments first</p> </li> <li> <p>Dependencies: Keep your dependencies updated    <pre><code>pip list --outdated\n</code></pre></p> </li> </ol>"},{"location":"SECURITY/#for-developers","title":"For Developers","text":"<ol> <li> <p>Code Review: All code changes go through PR review</p> </li> <li> <p>Automated Scanning: We use:</p> </li> <li><code>safety</code> for dependency vulnerability scanning</li> <li><code>bandit</code> for security issue detection</li> <li> <p>GitHub Dependabot for automated updates</p> </li> <li> <p>Input Validation: Always validate and sanitize user input</p> </li> <li> <p>Memory Safety: Use proper memory management in generated C code</p> </li> <li>CAMLparam/CAMLreturn macros</li> <li>Proper string ownership</li> <li> <p>GC-safe conversions</p> </li> <li> <p>Type Safety: Leverage type systems to prevent errors</p> </li> <li>Python type hints</li> <li>OCaml type constraints</li> <li>C type declarations</li> </ol>"},{"location":"SECURITY/#known-security-considerations","title":"Known Security Considerations","text":""},{"location":"SECURITY/#generated-c-code","title":"Generated C Code","text":"<p>The C stub code we generate includes:</p> <ul> <li>Memory Management: We use OCaml's GC-safe macros (CAMLparam, CAMLreturn)</li> <li>String Handling: Proper ownership and cleanup of string allocations</li> <li>Null Pointer Checks: Generated code includes appropriate null checks</li> </ul>"},{"location":"SECURITY/#ffi-boundaries","title":"FFI Boundaries","text":"<p>When crossing language boundaries:</p> <ul> <li>Type Marshalling: Ensure proper type conversions at FFI boundaries</li> <li>Error Handling: Check return values and handle errors appropriately</li> <li>Resource Cleanup: Ensure resources are properly freed on both sides</li> </ul>"},{"location":"SECURITY/#build-system","title":"Build System","text":"<ul> <li>Dependency Integrity: We use <code>pip</code> with hash verification in CI/CD</li> <li>Supply Chain: All dependencies are regularly updated and scanned</li> <li>Reproducible Builds: Our build process is deterministic</li> </ul>"},{"location":"SECURITY/#security-scanning","title":"Security Scanning","text":"<p>We use automated security scanning in our CI/CD pipeline:</p> <pre><code># Run on every PR and push\n- safety check          # Check for known vulnerabilities\n- bandit -r src/        # Static security analysis\n- dependabot           # Automated dependency updates\n</code></pre> <p>You can run these locally:</p> <pre><code># Install security tools\npip install safety bandit\n\n# Check for vulnerabilities\nsafety check\n\n# Run security linter\nbandit -r src/\n</code></pre>"},{"location":"SECURITY/#disclosure-policy","title":"Disclosure Policy","text":"<ul> <li>Coordinated Disclosure: We follow a coordinated disclosure process</li> <li>Embargo Period: Typically 90 days to develop and release a fix</li> <li>Public Advisory: Published after fix is released</li> <li>CVE Assignment: We request CVEs for significant vulnerabilities</li> </ul>"},{"location":"SECURITY/#contact","title":"Contact","text":"<p>For security-related questions or concerns:</p> <ul> <li>GitHub: https://github.com/chizy7/polyglot-ffi/security</li> <li>Issues: https://github.com/chizy7/polyglot-ffi/issues (for non-security bugs)</li> </ul>"},{"location":"SECURITY/#acknowledgments","title":"Acknowledgments","text":"<p>We would like to thank the following researchers and contributors who have responsibly disclosed vulnerabilities:</p> <ul> <li>(None yet - you could be the first!)</li> </ul>"},{"location":"SECURITY/#additional-resources","title":"Additional Resources","text":"<ul> <li>OWASP Top 10</li> <li>CWE Top 25</li> <li>Python Security Best Practices</li> <li>OCaml Security</li> </ul> <p>Last Updated: October 2025</p> <p>Thank you for helping keep Polyglot FFI and our users safe!</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>Version: v0.4.3</p> <p>Polyglot FFI uses a multi-stage pipeline to generate FFI bindings:</p> <pre><code>flowchart LR\n    A[\"Source File (.mli)\"] --&gt; B[\"Parser\"]\n    B --&gt; C[\"IR\"]\n    C --&gt; D[\"Type Registry\"]\n    D --&gt; E[\"Generators\"]\n    E --&gt; F[\"Output Files\"]\n\n    C --&gt; G[\"Type Mappings&lt;br/&gt;(OCaml / Python / C / Rust)\"]\n</code></pre>"},{"location":"architecture/#design-principles","title":"Design Principles","text":"<ol> <li>Language-Agnostic IR - Intermediate representation decouples source and target languages</li> <li>Pluggable Generators - Easy to add new target languages</li> <li>Type-Safe - Preserves type information throughout pipeline</li> <li>Memory-Safe - Proper CAMLparam/CAMLreturn, no leaks</li> <li>Testable - Each component independently unit tested</li> <li>Extensible Type System - Type Registry allows custom type mappings</li> </ol>"},{"location":"architecture/#components","title":"Components","text":""},{"location":"architecture/#1-parser-srcpolyglot_ffiparsersocamlpy","title":"1. Parser (<code>src/polyglot_ffi/parsers/ocaml.py</code>)","text":"<p>Purpose: Parse OCaml <code>.mli</code> files into AST</p> <p>Features: - Regex-based parsing - Multi-line signature support (partial) - Documentation comment extraction - Error messages with line numbers</p> <p>Example: <pre><code>from polyglot_ffi.parsers.ocaml import parse_mli_file\n\nmodule = parse_mli_file(\"crypto.mli\")\n# Returns IRModule with functions\n</code></pre></p>"},{"location":"architecture/#2-intermediate-representation-srcpolyglot_ffiirtypespy","title":"2. Intermediate Representation (<code>src/polyglot_ffi/ir/types.py</code>)","text":"<p>Purpose: Language-agnostic type system</p> <p>Key Types: - <code>IRModule</code> - Top-level module - <code>IRFunction</code> - Function with params and return type - <code>IRParameter</code> - Function parameter - <code>IRType</code> - Type representation (primitive, option, list, tuple, record, variant) - <code>IRTypeDefinition</code> - Custom type definitions (records, variants) - <code>TypeKind</code> - Enum of type categories</p> <p>Enhancements: - Added <code>OPTION</code>, <code>LIST</code>, <code>TUPLE</code> type kinds - Added <code>RECORD</code> and <code>VARIANT</code> type kinds - Support for nested and combined types - Type variables for polymorphic functions</p> <p>Example: <pre><code>from polyglot_ffi.ir.types import (\n    IRFunction, IRParameter, STRING, INT,\n    ir_option, ir_list, ir_tuple\n)\n\n# Simple function\nfunc = IRFunction(\n    name=\"add\",\n    params=[IRParameter(\"x\", INT), IRParameter(\"y\", INT)],\n    return_type=INT\n)\n\n# Function with complex types\nfind_func = IRFunction(\n    name=\"find_user\",\n    params=[IRParameter(\"name\", STRING)],\n    return_type=ir_option(STRING)  # Returns string option\n)\n</code></pre></p>"},{"location":"architecture/#3-type-registry-srcpolyglot_ffitype_system","title":"3. Type Registry (<code>src/polyglot_ffi/type_system/</code>)","text":"<p>Purpose: Manage type mappings between languages</p> <p>The Type Registry provides centralized, extensible type mapping management.</p> <p>Key Components:</p>"},{"location":"architecture/#a-typeregistry-registrypy","title":"A. TypeRegistry (<code>registry.py</code>)","text":"<ul> <li>Registers primitive type mappings</li> <li>Handles complex type conversions</li> <li>Supports custom type converters</li> <li>Validates type mappings</li> </ul> <p>Example: <pre><code>from polyglot_ffi.type_system import TypeRegistry\n\nregistry = TypeRegistry()\n\n# Register a primitive type\nregistry.register_primitive(\"string\", {\n    \"ocaml\": \"string\",\n    \"python\": \"str\",\n    \"c\": \"char*\",\n    \"rust\": \"String\"\n})\n\n# Get mapping for target language\npython_type = registry.get_mapping(ir_type, \"python\")\n</code></pre></p>"},{"location":"architecture/#b-built-in-types-builtinpy","title":"B. Built-in Types (<code>builtin.py</code>)","text":"<p>Pre-registered mappings for all standard types: - Primitives: string, int, float, bool, unit - Complex: option, list, tuple types - Multi-language support: OCaml, Python, C, Rust</p> <p>Features: - Automatic handling of <code>Optional[T]</code>, <code>List[T]</code>, <code>Tuple[T1, T2]</code> - Consistent naming conventions across languages - Extensible via custom converters</p> <p>Example: <pre><code>from polyglot_ffi.type_system import get_default_registry\nfrom polyglot_ffi.ir.types import ir_option, STRING\n\nregistry = get_default_registry()\n\n# Automatic complex type mapping\noption_str = ir_option(STRING)\npython_type = registry.get_mapping(option_str, \"python\")\n# Returns: \"Optional[str]\"\n</code></pre></p>"},{"location":"architecture/#4-generators-srcpolyglot_ffigenerators","title":"4. Generators (<code>src/polyglot_ffi/generators/</code>)","text":""},{"location":"architecture/#a-ctypes-generator-ctypes_genpy","title":"A. Ctypes Generator (<code>ctypes_gen.py</code>)","text":"<p>Generates OCaml ctypes bindings: - <code>type_description.ml</code> - Type definitions module - <code>function_description.ml</code> - Foreign function declarations</p>"},{"location":"architecture/#b-c-stub-generator-c_stubs_genpy","title":"B. C Stub Generator (<code>c_stubs_gen.py</code>)","text":"<p>Generates C wrapper code: - Proper CAMLparam/CAMLlocal/CAMLreturn macros - Type conversions (OCaml \u2194 C) - Memory management (strdup for strings) - Multi-parameter callback support</p>"},{"location":"architecture/#c-python-generator-python_genpy","title":"C. Python Generator (<code>python_gen.py</code>)","text":"<p>Generates Python wrapper: - Type hints - Error handling with custom exceptions - UTF-8 encoding/decoding - Pythonic API</p>"},{"location":"architecture/#d-dune-generator-dune_genpy","title":"D. Dune Generator (<code>dune_gen.py</code>)","text":"<p>Generates build configuration: - <code>dune</code> - Library and rule definitions - <code>dune-project</code> - Project metadata</p>"},{"location":"architecture/#5-commands-srcpolyglot_fficommands","title":"5. Commands (<code>src/polyglot_ffi/commands/</code>)","text":"<p>High-level command implementations:</p> <ul> <li><code>init.py</code> - Project scaffolding with templates</li> <li><code>generate.py</code> - Binding generation orchestration</li> <li><code>check.py</code> - Project validation and dependency checking</li> <li><code>clean.py</code> - Generated file cleanup</li> <li><code>watch.py</code> - Auto-regenerate on file changes</li> </ul>"},{"location":"architecture/#6-cli-srcpolyglot_fficlimainpy","title":"6. CLI (<code>src/polyglot_ffi/cli/main.py</code>)","text":"<p>Click-based command-line interface with rich output:</p> <p>Features: - Progress indicators and spinners - Colored output for better UX - Shell completions (Bash, Zsh, Fish) - Verbose mode for debugging - Dry-run mode for preview - Force regeneration option</p> <p>Commands: - <code>polyglot-ffi init</code> - Initialize new project - <code>polyglot-ffi generate</code> - Generate bindings - <code>polyglot-ffi check</code> - Validate configuration - <code>polyglot-ffi clean</code> - Clean generated files - <code>polyglot-ffi watch</code> - Watch for changes</p>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#generation-pipeline","title":"Generation Pipeline","text":"<ol> <li>Parse <code>.mli</code> file \u2192 AST</li> <li>Convert AST \u2192 IR (IRModule)</li> <li>Validate IR types</li> <li>Generate target code from IR</li> <li>Write files to output directory</li> </ol>"},{"location":"architecture/#type-mapping","title":"Type Mapping","text":"<pre><code>OCaml Type    \u2192  IR Type       \u2192  C Type    \u2192  Python Type\n-----------      ----------       --------      ------------\nstring        \u2192  STRING        \u2192  char*     \u2192  str\nint           \u2192  INT           \u2192  int       \u2192  int\nfloat         \u2192  FLOAT         \u2192  double    \u2192  float\nbool          \u2192  BOOL          \u2192  int       \u2192  bool\nunit          \u2192  UNIT          \u2192  void      \u2192  None\n</code></pre>"},{"location":"architecture/#generated-code-structure","title":"Generated Code Structure","text":"<p>For <code>crypto.mli</code>:</p> <pre><code>generated/\n\u251c\u2500\u2500 type_description.ml       # OCaml: module Types (F : TYPE) = ...\n\u251c\u2500\u2500 function_description.ml   # OCaml: module Functions (F : FOREIGN) = ...\n\u251c\u2500\u2500 crypto_stubs.c            # C: ml_encrypt, ml_decrypt, ml_hash\n\u251c\u2500\u2500 crypto_stubs.h            # C: function declarations\n\u251c\u2500\u2500 dune                      # Dune: library + rule\n\u251c\u2500\u2500 dune-project              # Dune: project metadata\n\u2514\u2500\u2500 crypto_py.py              # Python: encrypt(), decrypt(), hash()\n</code></pre>"},{"location":"architecture/#memory-safety","title":"Memory Safety","text":""},{"location":"architecture/#ocaml-side","title":"OCaml Side","text":"<ul> <li>Functions registered with <code>Callback.register</code></li> <li>GC-managed memory</li> </ul>"},{"location":"architecture/#c-side","title":"C Side","text":"<ul> <li><code>CAMLparam0()</code> - Declare no parameters</li> <li><code>CAMLlocal2(ml_x, ml_y)</code> - Declare local GC roots</li> <li><code>caml_copy_string()</code> - Copy C string to OCaml</li> <li><code>String_val()</code> - Get C string from OCaml</li> <li><code>strdup()</code> - Duplicate string for C ownership</li> <li><code>CAMLreturnT(type, value)</code> - Return with GC awareness</li> </ul>"},{"location":"architecture/#python-side","title":"Python Side","text":"<ul> <li><code>encode('utf-8')</code> - Convert Python str to bytes</li> <li><code>decode('utf-8')</code> - Convert bytes to Python str</li> <li>Error handling prevents NULL pointer dereferences</li> </ul>"},{"location":"architecture/#extensibility","title":"Extensibility","text":""},{"location":"architecture/#adding-a-new-target-language","title":"Adding a New Target Language","text":"<ol> <li>Create <code>src/polyglot_ffi/generators/rust_gen.py</code></li> <li>Implement generator class with <code>generate()</code> method</li> <li>Map IR types to Rust types</li> <li>Register in <code>__init__.py</code></li> <li>Add tests</li> </ol>"},{"location":"architecture/#adding-a-new-source-language","title":"Adding a New Source Language","text":"<ol> <li>Create <code>src/polyglot_ffi/parsers/rust.py</code></li> <li>Implement parser class with <code>parse()</code> method</li> <li>Convert to IR</li> <li>Add tests</li> </ol>"},{"location":"architecture/#testing-strategy","title":"Testing Strategy","text":"<p>Current Status (v0.4.0): - 285 tests passing  - 88% code coverage  - Test suite covering all components</p> <p>Test Categories:</p> <ul> <li>Unit tests (<code>tests/unit/</code>) - Test each component independently</li> <li>Parser tests (OCaml <code>.mli</code> parsing)</li> <li>Generator tests (ctypes, C stubs, Python, Dune)</li> <li>Type system tests (primitives, complex types, registry)</li> <li> <p>IR tests (type definitions, functions, modules)</p> </li> <li> <p>Integration tests (<code>tests/integration/</code>) - Test end-to-end generation</p> </li> <li>Full generation pipeline</li> <li>CLI command testing</li> <li>Multi-file projects</li> <li> <p>Error handling</p> </li> <li> <p>Fixtures (<code>tests/fixtures/</code>) - Example <code>.mli</code> files for testing</p> </li> <li>Simple functions (primitives)</li> <li>Complex types (options, lists, tuples)</li> <li>Real-world examples</li> </ul> <p>Coverage Configuration: - Excludes CLI entry points (tested via integration tests) - Targets business logic and core components - Standard production coverage practices</p>"},{"location":"architecture/#performance","title":"Performance","text":"<ul> <li>Parsing: &lt; 10ms for typical files</li> <li>Generation: &lt; 100ms total</li> <li>Zero runtime overhead: All code generated at build time</li> </ul>"},{"location":"configuration/","title":"Configuration Guide","text":"<p>Complete reference for configuring Polyglot FFI projects.</p>"},{"location":"configuration/#overview","title":"Overview","text":"<p>Polyglot FFI uses <code>polyglot.toml</code> for project configuration. This file is created automatically by <code>polyglot-ffi init</code> and can be customized for your needs.</p> <p>Location: Project root directory</p>"},{"location":"configuration/#quick-example","title":"Quick Example","text":"<pre><code>[project]\nname = \"my-crypto-lib\"\nversion = \"0.1.0\"\ndescription = \"FFI bindings for crypto library\"\nauthors = [\"Your Name &lt;you@example.com&gt;\"]\n\n[bindings]\nsource_dir = \"src\"\noutput_dir = \"generated\"\nsource_files = [\"src/crypto.mli\", \"src/hash.mli\"]\nauto_discover = false\n\n[targets.python]\nenabled = true\noutput_dir = \"generated/python\"\nmodule_prefix = \"crypto\"\n</code></pre>"},{"location":"configuration/#configuration-reference","title":"Configuration Reference","text":""},{"location":"configuration/#project","title":"[project]","text":"<p>Project metadata and general settings.</p> <p>Required: - <code>name</code> (string) - Project name   <pre><code>name = \"my-project\"\n</code></pre></p> <p>Optional: - <code>version</code> (string) - Project version (default: <code>\"0.1.0\"</code>) - <code>description</code> (string) - Project description - <code>authors</code> (array) - List of authors   <pre><code>version = \"1.0.0\"\ndescription = \"My awesome FFI bindings\"\nauthors = [\"Alice &lt;alice@example.com&gt;\", \"Bob &lt;bob@example.com&gt;\"]\n</code></pre></p>"},{"location":"configuration/#bindings","title":"[bindings]","text":"<p>Bindings generation configuration.</p> <p>Optional: - <code>source_dir</code> (string) - Source directory (default: <code>\"src\"</code>) - <code>output_dir</code> (string) - Output directory (default: <code>\"generated\"</code>) - <code>source_files</code> (array) - List of <code>.mli</code> files to process - <code>auto_discover</code> (boolean) - Auto-discover <code>.mli</code> files (default: <code>true</code>)</p> <p>Example: <pre><code>[bindings]\nsource_dir = \"src\"\noutput_dir = \"generated\"\nsource_files = [\"src/api.mli\", \"src/utils.mli\"]\nauto_discover = false  # Only process listed files\n</code></pre></p>"},{"location":"configuration/#targetspython","title":"[targets.python]","text":"<p>Python-specific configuration.</p> <p>Optional: - <code>enabled</code> (boolean) - Enable Python target (default: <code>true</code>) - <code>output_dir</code> (string) - Python output directory - <code>module_prefix</code> (string) - Prefix for generated modules - <code>min_version</code> (string) - Minimum Python version (default: <code>\"3.8\"</code>)</p> <p>Example: <pre><code>[targets.python]\nenabled = true\noutput_dir = \"generated/python\"\nmodule_prefix = \"mylib\"\nmin_version = \"3.9\"\n</code></pre></p>"},{"location":"configuration/#targetsrust","title":"[targets.rust]","text":"<p>Rust-specific configuration (future support).</p> <p>Optional: - <code>enabled</code> (boolean) - Enable Rust target (default: <code>false</code>) - <code>output_dir</code> (string) - Rust output directory - <code>crate_name</code> (string) - Rust crate name</p> <p>Example: <pre><code>[targets.rust]\nenabled = true\noutput_dir = \"generated/rust\"\ncrate_name = \"mylib_ffi\"\n</code></pre></p>"},{"location":"configuration/#types","title":"[types]","text":"<p>Custom type mappings.</p> <p>Define custom type mappings for your project:</p> <pre><code>[types.binary_data]\nocaml = \"bytes\"\npython = \"bytes\"\nrust = \"Vec&lt;u8&gt;\"\nc = \"uint8_t*\"\n\n[types.timestamp]\nocaml = \"float\"\npython = \"datetime.datetime\"\nrust = \"SystemTime\"\nc = \"double\"\n</code></pre>"},{"location":"configuration/#build","title":"[build]","text":"<p>Build system configuration.</p> <p>Optional: - <code>system</code> (string) - Build system (<code>\"dune\"</code>, <code>\"make\"</code>, etc.) - <code>auto_build</code> (boolean) - Auto-build after generation (default: <code>false</code>)</p> <p>Example: <pre><code>[build]\nsystem = \"dune\"\nauto_build = true\n</code></pre></p>"},{"location":"configuration/#complete-example","title":"Complete Example","text":"<p>A full-featured configuration file:</p> <pre><code># Project metadata\n[project]\nname = \"crypto-bindings\"\nversion = \"0.1.0\"\ndescription = \"FFI bindings for cryptographic library\"\nauthors = [\"Jane Developer &lt;jane@example.com&gt;\"]\n\n# Bindings configuration\n[bindings]\nsource_dir = \"src\"\noutput_dir = \"generated\"\nsource_files = [\"src/crypto.mli\", \"src/hash.mli\"]\nauto_discover = false\n\n# Python target\n[targets.python]\nenabled = true\noutput_dir = \"generated/python\"\nmodule_prefix = \"crypto\"\nmin_version = \"3.8\"\n\n# Rust target (future)\n[targets.rust]\nenabled = false\noutput_dir = \"generated/rust\"\ncrate_name = \"crypto_ffi\"\n\n# Custom type mappings\n[types.binary_data]\nocaml = \"bytes\"\npython = \"bytes\"\nrust = \"Vec&lt;u8&gt;\"\nc = \"uint8_t*\"\n\n# Build configuration\n[build]\nsystem = \"dune\"\nauto_build = false\n</code></pre>"},{"location":"configuration/#cli-override","title":"CLI Override","text":"<p>Command-line options override configuration file settings:</p> <pre><code># Override output directory\npolyglot-ffi generate src/module.mli -o custom-output/\n\n# Override module name\npolyglot-ffi generate src/module.mli -n custom_name\n\n# Dry run (preview only)\npolyglot-ffi generate src/module.mli --dry-run\n\n# Force regeneration\npolyglot-ffi generate src/module.mli --force\n\n# Verbose output\npolyglot-ffi generate src/module.mli -v\n</code></pre>"},{"location":"configuration/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"configuration/#single-module-project","title":"Single Module Project","text":"<pre><code>[project]\nname = \"simple-lib\"\n\n[bindings]\nsource_files = [\"src/api.mli\"]\n\n[targets.python]\nenabled = true\n</code></pre>"},{"location":"configuration/#multi-module-project","title":"Multi-Module Project","text":"<pre><code>[project]\nname = \"complex-lib\"\n\n[bindings]\nsource_dir = \"src\"\nauto_discover = true  # Find all .mli files\n\n[targets.python]\nenabled = true\nmodule_prefix = \"complex\"\n</code></pre>"},{"location":"configuration/#development-vs-production","title":"Development vs Production","text":"<p>Development (<code>polyglot.dev.toml</code>): <pre><code>[bindings]\nauto_discover = true\n\n[build]\nauto_build = true  # Rebuild on changes\n</code></pre></p> <p>Production (<code>polyglot.toml</code>): <pre><code>[bindings]\nsource_files = [\"src/api.mli\"]  # Explicit list\nauto_discover = false\n\n[build]\nauto_build = false\n</code></pre></p> <p>Use with: <code>polyglot-ffi generate --config polyglot.dev.toml</code></p>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>Override configuration with environment variables:</p> <pre><code># Override output directory\nexport POLYGLOT_FFI_OUTPUT_DIR=\"custom-output\"\npolyglot-ffi generate src/module.mli\n\n# Override module name\nexport POLYGLOT_FFI_MODULE_NAME=\"custom_name\"\npolyglot-ffi generate src/module.mli\n</code></pre>"},{"location":"configuration/#validation","title":"Validation","text":"<p>Check your configuration:</p> <pre><code># Validate configuration file\npolyglot-ffi check\n\n# Validate with dependency check\npolyglot-ffi check --check-deps\n\n# Show current configuration\npolyglot-ffi check --show-config\n</code></pre>"},{"location":"configuration/#default-configuration","title":"Default Configuration","text":"<p>If no <code>polyglot.toml</code> exists, these defaults are used:</p> <pre><code>[project]\nname = \"polyglot-project\"\nversion = \"0.1.0\"\n\n[bindings]\nsource_dir = \"src\"\noutput_dir = \"generated\"\nauto_discover = true\n\n[targets.python]\nenabled = true\nmin_version = \"3.8\"\n</code></pre>"},{"location":"configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/#configuration-not-found","title":"Configuration Not Found","text":"<pre><code># Create default configuration\npolyglot-ffi init\n\n# Or specify config location\npolyglot-ffi generate --config path/to/polyglot.toml\n</code></pre>"},{"location":"configuration/#invalid-configuration","title":"Invalid Configuration","text":"<pre><code># Check for errors\npolyglot-ffi check\n\n# Common issues:\n# - Missing required fields (name)\n# - Invalid TOML syntax\n# - Wrong type for field values\n</code></pre>"},{"location":"configuration/#module-name-conflicts","title":"Module Name Conflicts","text":"<p>If generated module names conflict with Python builtins:</p> <pre><code>[targets.python]\nmodule_prefix = \"my\"  # Generates my_crypto instead of crypto\n</code></pre>"},{"location":"configuration/#see-also","title":"See Also","text":"<ul> <li>Quickstart Guide - Get started quickly</li> <li>Type Mapping - Custom type mappings</li> <li>CLI Reference - Command-line options</li> <li>API Configuration - Configuration API</li> </ul> <p>Need help? See Installation Guide or open an issue.</p>"},{"location":"contributing/","title":"Contributing to Polyglot FFI","text":"<p>Thank you for your interest in contributing!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/chizy7/polyglot-ffi\ncd polyglot-ffi\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode\npip install -e \".[dev]\"\n\n# Verify installation\npolyglot-ffi --version\npytest tests/ -v\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li>Create a branch for your feature/fix</li> <li>Write tests first (TDD recommended)</li> <li>Implement your changes</li> <li>Run tests to ensure they pass</li> <li>Format code with black</li> <li>Lint code with ruff</li> <li>Submit PR with description</li> </ol>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># All tests\npytest tests/ -v\n\n# Specific test file\npytest tests/unit/test_parser.py -v\n\n# With coverage\npytest tests/ --cov=polyglot_ffi --cov-report=html\n\n# View coverage\nopen htmlcov/index.html\n</code></pre>"},{"location":"contributing/#code-quality","title":"Code Quality","text":"<pre><code># Format code\nblack src/ tests/\n\n# Lint code\nruff check src/ tests/\n\n# Type check\nmypy src/\n</code></pre>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>polyglot-ffi/\n\u251c\u2500\u2500 src/polyglot_ffi/   # Main package\n\u2502   \u251c\u2500\u2500 parsers/        # Language parsers\n\u2502   \u251c\u2500\u2500 ir/             # Intermediate representation\n\u2502   \u251c\u2500\u2500 generators/     # Code generators\n\u2502   \u251c\u2500\u2500 commands/       # CLI commands\n\u2502   \u251c\u2500\u2500 cli/            # CLI interface\n\u2502   \u2514\u2500\u2500 utils/          # Utilities\n\u251c\u2500\u2500 tests/              # Test suite\n\u2502   \u251c\u2500\u2500 unit/           # Unit tests\n\u2502   \u2514\u2500\u2500 integration/    # Integration tests\n\u251c\u2500\u2500 docs/               # Documentation\n\u2514\u2500\u2500 examples/           # Example projects\n</code></pre>"},{"location":"contributing/#adding-features","title":"Adding Features","text":""},{"location":"contributing/#adding-a-new-type","title":"Adding a New Type","text":"<ol> <li>Update <code>src/polyglot_ffi/ir/types.py</code></li> <li>Update parser in <code>src/polyglot_ffi/parsers/ocaml.py</code></li> <li>Update generators to handle new type</li> <li>Add tests</li> <li>Update documentation</li> </ol>"},{"location":"contributing/#adding-a-new-generator","title":"Adding a New Generator","text":"<ol> <li>Create <code>src/polyglot_ffi/generators/rust_gen.py</code></li> <li>Implement <code>generate()</code> method</li> <li>Register in <code>__init__.py</code></li> <li>Add tests in <code>tests/unit/test_generators.py</code></li> <li>Update documentation</li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8</li> <li>Use type hints</li> <li>Write docstrings for public APIs</li> <li>Keep functions small and focused</li> <li>Prefer composition over inheritance</li> </ul>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":"<ul> <li>Unit tests: Test individual components</li> <li>Integration tests: Test end-to-end workflows</li> <li>Aim for 70%+ coverage</li> <li>Use fixtures for complex test data</li> <li>Mock external dependencies</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update documentation</li> <li>Add/update tests</li> <li>Ensure all tests pass</li> <li>Update CHANGELOG.md</li> <li>Create PR with clear description</li> <li>Address review feedback</li> </ol>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<ul> <li>Use GitHub Issues</li> <li>Provide minimal reproducible example</li> <li>Include version information</li> <li>Describe expected vs actual behavior</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#general","title":"General","text":""},{"location":"faq/#what-is-polyglot-ffi","title":"What is Polyglot FFI?","text":"<p>Polyglot FFI is an automatic Foreign Function Interface (FFI) bindings generator that bridges programming languages. It reads OCaml interface files (<code>.mli</code>) and generates complete, type-safe, memory-safe bindings for other languages like Python.</p>"},{"location":"faq/#why-use-polyglot-ffi","title":"Why use Polyglot FFI?","text":"<ul> <li>Zero boilerplate: One command generates 100+ lines of FFI code</li> <li>Type safe: Preserves type information across languages</li> <li>Memory safe: Proper GC handling and no memory leaks</li> <li>Time-saving: Focus on logic, not FFI plumbing</li> </ul>"},{"location":"faq/#what-languages-are-supported","title":"What languages are supported?","text":"<p>Currently: - OCaml \u2192 Python (fully supported)</p> <p>Coming soon: - OCaml \u2192 Rust - OCaml \u2192 Go</p>"},{"location":"faq/#is-it-production-ready","title":"Is it production-ready?","text":"<p>Yes! Version 0.4.3 is production-ready with: - 262 comprehensive tests (0 failures) - 88% code coverage - Full CI/CD pipeline - Battle-tested on real projects</p>"},{"location":"faq/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"faq/#how-do-i-install-polyglot-ffi","title":"How do I install Polyglot FFI?","text":"<pre><code>pip install polyglot-ffi\n</code></pre> <p>See Installation Guide for detailed instructions.</p>"},{"location":"faq/#what-are-the-system-requirements","title":"What are the system requirements?","text":"<ul> <li>Python 3.8+ (required for Polyglot FFI)</li> <li>OCaml 4.14+ (required to build generated bindings)</li> <li>Dune 3.0+ (build system for OCaml)</li> </ul>"},{"location":"faq/#do-i-need-to-know-ocaml","title":"Do I need to know OCaml?","text":"<p>Basic knowledge helps, but you don't need to be an expert. You mainly need to: 1. Write OCaml interface files (<code>.mli</code>) 2. Implement the functions in OCaml (<code>.ml</code>) 3. Use the generated Python bindings</p>"},{"location":"faq/#usage","title":"Usage","text":""},{"location":"faq/#how-do-i-generate-bindings","title":"How do I generate bindings?","text":"<pre><code># From an interface file\npolyglot-ffi generate my_module.mli\n\n# From a project with polyglot.toml\npolyglot-ffi generate\n</code></pre>"},{"location":"faq/#can-i-customize-the-generated-code","title":"Can I customize the generated code?","text":"<p>Yes, through <code>polyglot.toml</code>:</p> <pre><code>[source]\nlanguage = \"ocaml\"\ninterface_file = \"src/mylib.mli\"\n\n[[targets]]\nlanguage = \"python\"\noutput_dir = \"bindings/python\"\nmodule_name = \"mylib\"\n</code></pre>"},{"location":"faq/#how-do-i-use-the-generated-bindings","title":"How do I use the generated bindings?","text":"<pre><code># Import generated module\nfrom generated.mylib_py import my_function\n\n# Use it like normal Python\nresult = my_function(\"hello\", 42)\n</code></pre>"},{"location":"faq/#type-system","title":"Type System","text":""},{"location":"faq/#what-ocaml-types-are-supported","title":"What OCaml types are supported?","text":"<p>Primitives: - <code>int</code>, <code>float</code>, <code>string</code>, <code>bool</code>, <code>unit</code></p> <p>Complex types: - <code>'a option</code> \u2192 <code>Optional[T]</code> - <code>'a list</code> \u2192 <code>List[T]</code> - <code>'a * 'b</code> \u2192 <code>Tuple[T1, T2]</code> - Records \u2192 Python dataclasses - Variants \u2192 Python classes</p> <p>See Type Mapping Guide for complete list.</p>"},{"location":"faq/#how-are-option-types-handled","title":"How are option types handled?","text":"<p>OCaml <code>option</code> maps to Python <code>Optional</code>:</p> <pre><code>(* OCaml *)\nval find_user : string -&gt; user option\n</code></pre> <pre><code># Python\ndef find_user(name: str) -&gt; Optional[User]:\n    ...\n\nuser = find_user(\"john\")\nif user is not None:\n    print(user.name)\n</code></pre>"},{"location":"faq/#how-are-lists-handled","title":"How are lists handled?","text":"<p>OCaml lists map to Python lists:</p> <pre><code>(* OCaml *)\nval get_all_users : unit -&gt; user list\n</code></pre> <pre><code># Python\ndef get_all_users() -&gt; List[User]:\n    ...\n\nusers = get_all_users()\nfor user in users:\n    print(user.name)\n</code></pre>"},{"location":"faq/#can-i-use-custom-types","title":"Can I use custom types?","text":"<p>Yes! Define types in your <code>.mli</code> file:</p> <pre><code>type user = {\n  name: string;\n  age: int;\n}\n\nval create_user : string -&gt; int -&gt; user\n</code></pre> <p>The generator creates corresponding Python classes automatically.</p>"},{"location":"faq/#error-handling","title":"Error Handling","text":""},{"location":"faq/#how-are-ocaml-exceptions-handled","title":"How are OCaml exceptions handled?","text":"<p>Currently, exceptions cause the C stub to return an error value. We recommend using result types:</p> <pre><code>type ('a, 'b) result = Ok of 'a | Error of 'b\n\nval process : string -&gt; (user, string) result\n</code></pre>"},{"location":"faq/#what-if-generation-fails","title":"What if generation fails?","text":"<p>Check the error message - they include suggestions:</p> <pre><code>Error: Unsupported type 'custom_type' in function 'foo'\n\nSuggestion: Define 'custom_type' in the same .mli file\n</code></pre>"},{"location":"faq/#how-do-i-debug-generated-code","title":"How do I debug generated code?","text":"<pre><code># Generate with verbose output\npolyglot-ffi generate mylib.mli -v\n\n# Check generated files\nls -la generated/\n\n# Review the generated code\ncat generated/stubs.c\ncat generated/mylib_py.py\n</code></pre>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#how-fast-is-code-generation","title":"How fast is code generation?","text":"<p>Very fast! Benchmark results: - ~15,000 generations per second - &lt; 0.3ms for 100 functions - Parser: &lt; 0.01ms for simple functions</p>"},{"location":"faq/#does-it-add-runtime-overhead","title":"Does it add runtime overhead?","text":"<p>Minimal overhead: - Direct C FFI calls (no interpretation) - Native OCaml performance preserved - Python wrapper overhead is negligible</p>"},{"location":"faq/#can-i-use-it-for-large-projects","title":"Can I use it for large projects?","text":"<p>Yes! The tool is designed to scale: - Handles modules with 100+ functions - Efficient memory management - Incremental regeneration with watch mode</p>"},{"location":"faq/#development-contributing","title":"Development &amp; Contributing","text":""},{"location":"faq/#how-can-i-contribute","title":"How can I contribute?","text":"<p>See Contributing Guide for: - Setting up development environment - Running tests - Submitting pull requests - Code style guidelines</p>"},{"location":"faq/#how-do-i-report-bugs","title":"How do I report bugs?","text":"<p>Open an issue with: - Description of the problem - Steps to reproduce - Expected vs actual behavior - Your environment (OS, Python version, etc.)</p>"},{"location":"faq/#how-do-i-request-features","title":"How do I request features?","text":"<p>Open an issue with: - Use case description - Proposed solution (if you have one) - Why it would be useful</p>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#command-not-found-error","title":"\"Command not found\" error","text":"<pre><code># Check if installed\npip show polyglot-ffi\n\n# Try using module directly\npython -m polyglot_ffi --version\n\n# Add to PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n</code></pre>"},{"location":"faq/#module-not-found-when-importing","title":"\"Module not found\" when importing","text":"<pre><code># Make sure you built the OCaml library\ncd your-project\ndune build\n\n# Check the generated .so file exists\nls _build/default/src/*.so\n</code></pre>"},{"location":"faq/#ocaml-build-fails","title":"OCaml build fails","text":"<pre><code># Make sure OCaml environment is set up\neval $(opam env)\n\n# Install required packages\nopam install dune ctypes ctypes-foreign\n\n# Verify OCaml version\nocaml --version  # Should be 4.14+\n</code></pre>"},{"location":"faq/#types-not-matching","title":"Types not matching","text":"<p>Make sure type definitions are in the same <code>.mli</code> file:</p> <pre><code>(* Define types first *)\ntype user = { name: string; age: int }\n\n(* Then use them *)\nval create_user : string -&gt; int -&gt; user\n</code></pre>"},{"location":"faq/#generated-code-doesnt-compile","title":"Generated code doesn't compile","text":"<ol> <li>Check the error message</li> <li>Verify your <code>.mli</code> syntax is correct</li> <li>Make sure all types are defined</li> <li>Try regenerating with <code>--force</code> flag</li> </ol>"},{"location":"faq/#project-names-with-hyphens-causing-errors","title":"Project names with hyphens causing errors","text":"<p>Issue: Dune build fails with \"invalid module name\" or \"invalid library name\"</p> <p>Solution: Project names with hyphens (e.g., <code>my-crypto-lib</code>) are automatically sanitized in generated code. However, when copying source files to the <code>generated/</code> directory for building, you must rename them to use underscores:</p> <pre><code># Don't do this\ncp src/my-crypto-lib.ml generated/\n\n# Do this instead\ncp src/my-crypto-lib.ml generated/my_crypto_lib.ml\ncp src/my-crypto-lib.mli generated/my_crypto_lib.mli\n</code></pre> <p>This is required because OCaml module names cannot contain hyphens.</p>"},{"location":"faq/#library-ctypes-not-found-error","title":"\"Library ctypes not found\" error","text":"<p>Issue: <code>Error: Library \"ctypes\" not found</code> when running <code>dune build</code></p> <p>Solution: Install the required OCaml dependencies:</p> <pre><code>opam install dune ctypes ctypes-foreign\n</code></pre> <p>These are prerequisites for building the generated bindings, but not for the polyglot-ffi tool itself.</p>"},{"location":"faq/#best-practices","title":"Best Practices","text":""},{"location":"faq/#project-structure","title":"Project structure","text":"<pre><code>my-project/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 mylib.mli      # Interface (input to polyglot-ffi)\n\u2502   \u2514\u2500\u2500 mylib.ml       # Implementation\n\u251c\u2500\u2500 generated/          # Generated bindings (don't edit!)\n\u251c\u2500\u2500 polyglot.toml      # Configuration\n\u2514\u2500\u2500 dune-project       # OCaml build config\n</code></pre>"},{"location":"faq/#development-workflow","title":"Development workflow","text":"<ol> <li>Write OCaml interface (<code>.mli</code>)</li> <li>Generate bindings: <code>polyglot-ffi generate</code></li> <li>Implement OCaml code (<code>.ml</code>)</li> <li>Build: <code>dune build</code></li> <li>Use from Python: <code>import generated.mylib_py</code></li> </ol>"},{"location":"faq/#watch-mode-for-development","title":"Watch mode for development","text":"<pre><code># Auto-regenerate on file changes\npolyglot-ffi watch\n</code></pre>"},{"location":"faq/#testing","title":"Testing","text":"<p>Test both sides of the FFI boundary: - Write OCaml tests with <code>dune runtest</code> - Write Python tests with <code>pytest</code></p>"},{"location":"faq/#comparison-with-alternatives","title":"Comparison with Alternatives","text":""},{"location":"faq/#vs-manual-ffi-code","title":"vs. Manual FFI code","text":"Feature Manual Polyglot FFI Lines of code 100+ 1 command Type safety Manual Automatic Memory safety Error-prone Guaranteed Maintenance High Low Documentation Manual Preserved"},{"location":"faq/#vs-swig","title":"vs. SWIG","text":"Feature SWIG Polyglot FFI Language support Many OCaml-focused Setup complexity High Simple Type preservation Partial Full OCaml support Limited First-class"},{"location":"faq/#vs-pyo3-rust","title":"vs. Pyo3 (Rust)","text":"Feature Pyo3 Polyglot FFI Source language Rust OCaml Maturity High Growing Proc macros Yes N/A (different approach) Type system Strong Strong"},{"location":"faq/#future-plans","title":"Future Plans","text":""},{"location":"faq/#upcoming-features-v10","title":"Upcoming features (v1.0)","text":"<ul> <li>Publish to PyPI</li> <li>Rust target support</li> <li>Go target support</li> <li>Bidirectional bindings</li> <li>Plugin system</li> </ul>"},{"location":"faq/#long-term-roadmap","title":"Long-term roadmap","text":"<ul> <li>IDE/LSP integration</li> <li>More language targets (Java, JavaScript)</li> <li>Advanced type features (GADTs, functors)</li> <li>REPL integration</li> <li>Performance optimization</li> </ul>"},{"location":"faq/#getting-help","title":"Getting Help","text":""},{"location":"faq/#resources","title":"Resources","text":"<ul> <li>Documentation: https://polyglotffi.com/</li> <li>GitHub: https://github.com/chizy7/polyglot-ffi</li> <li>Issues: https://github.com/chizy7/polyglot-ffi/issues</li> <li>Discussions: https://github.com/chizy7/polyglot-ffi/discussions</li> </ul>"},{"location":"faq/#community","title":"Community","text":"<ul> <li>Report bugs via GitHub Issues</li> <li>Ask questions via GitHub Discussions</li> <li>Contribute via Pull Requests</li> </ul> <p>Didn't find your answer? Ask a question</p>"},{"location":"installation/","title":"Installation","text":"<p>This guide covers installing Polyglot FFI and its dependencies.</p>"},{"location":"installation/#quick-install","title":"Quick Install","text":""},{"location":"installation/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<pre><code>pip install polyglot-ffi\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/chizy7/polyglot-ffi\ncd polyglot-ffi\npip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":""},{"location":"installation/#python","title":"Python","text":"<ul> <li>Python 3.8 or higher</li> <li>pip (Python package manager)</li> </ul> <p>Check your Python version:</p> <pre><code>python --version\n# or\npython3 --version\n</code></pre>"},{"location":"installation/#ocaml-for-building-examples","title":"OCaml (For Building Examples)","text":"<p>If you want to build and run the generated bindings:</p> <ul> <li>OCaml 4.14 or higher</li> <li>Dune 3.0 or higher (build system)</li> <li>ocaml-ctypes library</li> </ul>"},{"location":"installation/#install-ocaml-on-macos","title":"Install OCaml on macOS","text":"<pre><code># Using Homebrew\nbrew install opam\nopam init\nopam switch create 4.14.1\neval $(opam env)\n\n# Install dependencies\nopam install dune ctypes ctypes-foreign\n</code></pre>"},{"location":"installation/#install-ocaml-on-linux","title":"Install OCaml on Linux","text":"<pre><code># Ubuntu/Debian\nsudo apt-get install opam\nopam init\nopam switch create 4.14.1\neval $(opam env)\n\n# Install dependencies\nopam install dune ctypes ctypes-foreign\n</code></pre>"},{"location":"installation/#install-ocaml-on-windows","title":"Install OCaml on Windows","text":"<pre><code># Using WSL2 (recommended)\n# Follow Linux instructions above\n\n# Or using OCaml for Windows\n# Download from: https://ocaml.org/docs/install.html\n</code></pre>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-user-install-recommended","title":"Method 1: User Install (Recommended)","text":"<p>Install for current user only:</p> <pre><code>pip install --user polyglot-ffi\n</code></pre> <p>The command will be available at: - Linux/macOS: <code>~/.local/bin/polyglot-ffi</code> - Windows: <code>%APPDATA%\\Python\\Scripts\\polyglot-ffi.exe</code></p> <p>Make sure this directory is in your PATH.</p>"},{"location":"installation/#method-2-virtual-environment","title":"Method 2: Virtual Environment","text":"<p>Create isolated environment:</p> <pre><code># Create virtual environment\npython -m venv polyglot-env\n\n# Activate it\nsource polyglot-env/bin/activate  # Linux/macOS\n# or\npolyglot-env\\Scripts\\activate     # Windows\n\n# Install\npip install polyglot-ffi\n</code></pre>"},{"location":"installation/#method-3-system-wide-install","title":"Method 3: System-Wide Install","text":"<p>Requires sudo/admin privileges:</p> <pre><code>sudo pip install polyglot-ffi  # Linux/macOS\n# or\npip install polyglot-ffi       # Windows (run as Administrator)\n</code></pre>"},{"location":"installation/#method-4-development-install","title":"Method 4: Development Install","text":"<p>For contributing or testing:</p> <pre><code>git clone https://github.com/chizy7/polyglot-ffi\ncd polyglot-ffi\npip install -e \".[dev]\"\n</code></pre> <p>This installs in \"editable\" mode with development dependencies.</p>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":""},{"location":"installation/#check-version","title":"Check Version","text":"<pre><code>polyglot-ffi --version\n# Output: polyglot-ffi, version 0.4.3\n</code></pre>"},{"location":"installation/#check-help","title":"Check Help","text":"<pre><code>polyglot-ffi --help\n</code></pre>"},{"location":"installation/#run-quick-test","title":"Run Quick Test","text":"<pre><code># Initialize a test project\npolyglot-ffi init test-project\ncd test-project\n\n# Generate bindings\npolyglot-ffi generate\n</code></pre>"},{"location":"installation/#shell-completion-optional","title":"Shell Completion (Optional)","text":"<p>Install shell completion for better CLI experience:</p>"},{"location":"installation/#bash","title":"Bash","text":"<pre><code># Install completion script\n_POLYGLOT_FFI_COMPLETE=bash_source polyglot-ffi &gt; ~/.polyglot-ffi-complete.bash\n\n# Add to ~/.bashrc\necho 'source ~/.polyglot-ffi-complete.bash' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>"},{"location":"installation/#zsh","title":"Zsh","text":"<pre><code># Install completion script\n_POLYGLOT_FFI_COMPLETE=zsh_source polyglot-ffi &gt; ~/.polyglot-ffi-complete.zsh\n\n# Add to ~/.zshrc\necho 'source ~/.polyglot-ffi-complete.zsh' &gt;&gt; ~/.zshrc\nsource ~/.zshrc\n</code></pre>"},{"location":"installation/#fish","title":"Fish","text":"<pre><code># Install completion script\n_POLYGLOT_FFI_COMPLETE=fish_source polyglot-ffi &gt; ~/.config/fish/completions/polyglot-ffi.fish\n</code></pre>"},{"location":"installation/#upgrading","title":"Upgrading","text":""},{"location":"installation/#upgrade-to-latest-version","title":"Upgrade to Latest Version","text":"<p>To upgrade to the latest version from PyPI:</p> <pre><code>pip install --upgrade polyglot-ffi\n</code></pre>"},{"location":"installation/#upgrade-to-specific-version","title":"Upgrade to Specific Version","text":"<p>To upgrade to a specific version:</p> <pre><code>pip install --upgrade polyglot-ffi==0.5.0\n</code></pre>"},{"location":"installation/#check-current-version","title":"Check Current Version","text":"<p>Before upgrading, check what version you have:</p> <pre><code>polyglot-ffi --version\n</code></pre>"},{"location":"installation/#check-available-versions","title":"Check Available Versions","text":"<p>To see all available versions on PyPI:</p> <pre><code>pip index versions polyglot-ffi\n</code></pre>"},{"location":"installation/#upgrade-from-source","title":"Upgrade from Source","text":"<p>If you installed from source (development mode):</p> <pre><code>cd polyglot-ffi\ngit pull origin master\npip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#force-reinstall","title":"Force Reinstall","text":"<p>If you encounter issues during upgrade:</p> <pre><code>pip install --upgrade --force-reinstall polyglot-ffi\n</code></pre>"},{"location":"installation/#upgrade-in-virtual-environment","title":"Upgrade in Virtual Environment","text":"<p>If you're using a virtual environment:</p> <pre><code># Activate your environment first\nsource env/bin/activate  # Linux/macOS\n# or\nenv\\Scripts\\activate     # Windows\n\n# Then upgrade\npip install --upgrade polyglot-ffi\n</code></pre>"},{"location":"installation/#whats-new","title":"What's New","text":"<p>After upgrading, check what changed:</p> <ul> <li>View Changelog: https://github.com/chizy7/polyglot-ffi/blob/master/CHANGELOG.md</li> <li>Release Notes: https://github.com/chizy7/polyglot-ffi/releases</li> </ul>"},{"location":"installation/#breaking-changes","title":"Breaking Changes","text":"<p>When upgrading between major versions (e.g., v0.x to v1.x), review the changelog for breaking changes and migration guides.</p>"},{"location":"installation/#uninstallation","title":"Uninstallation","text":"<pre><code>pip uninstall polyglot-ffi\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#command-not-found","title":"Command Not Found","text":"<p>Issue: <code>polyglot-ffi: command not found</code></p> <p>Solution: <pre><code># Check if installed\npip show polyglot-ffi\n\n# Find installation location\npython -m polyglot_ffi --version\n\n# Add to PATH (if needed)\nexport PATH=\"$HOME/.local/bin:$PATH\"  # Linux/macOS\n</code></pre></p>"},{"location":"installation/#import-error","title":"Import Error","text":"<p>Issue: <code>ModuleNotFoundError: No module named 'polyglot_ffi'</code></p> <p>Solution: <pre><code># Reinstall\npip uninstall polyglot-ffi\npip install polyglot-ffi\n\n# Or install in current Python environment\npython -m pip install polyglot-ffi\n</code></pre></p>"},{"location":"installation/#permission-denied","title":"Permission Denied","text":"<p>Issue: Permission errors during installation</p> <p>Solution: <pre><code># Use --user flag\npip install --user polyglot-ffi\n\n# Or use virtual environment\npython -m venv env\nsource env/bin/activate\npip install polyglot-ffi\n</code></pre></p>"},{"location":"installation/#ocaml-not-found","title":"OCaml Not Found","text":"<p>Issue: OCaml commands not available after installation</p> <p>Solution: <pre><code># Run opam environment setup\neval $(opam env)\n\n# Add to shell rc file permanently\necho 'eval $(opam env)' &gt;&gt; ~/.bashrc  # or ~/.zshrc\n</code></pre></p>"},{"location":"installation/#version-mismatch","title":"Version Mismatch","text":"<p>Issue: Old version showing after upgrade</p> <p>Solution: <pre><code># Clear pip cache\npip cache purge\n\n# Force reinstall\npip install --force-reinstall polyglot-ffi\n\n# Or uninstall first\npip uninstall polyglot-ffi\npip install polyglot-ffi\n</code></pre></p>"},{"location":"installation/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"installation/#macos","title":"macOS","text":"<ul> <li>Use Homebrew for OCaml: <code>brew install opam</code></li> <li>May need Command Line Tools: <code>xcode-select --install</code></li> </ul>"},{"location":"installation/#linux","title":"Linux","text":"<ul> <li>Ubuntu/Debian: <code>apt-get install opam</code></li> <li>Fedora/RHEL: <code>dnf install opam</code></li> <li>Arch: <code>pacman -S opam</code></li> </ul>"},{"location":"installation/#windows","title":"Windows","text":"<ul> <li>Use WSL2 for best experience</li> <li>Or install OCaml for Windows from official site</li> <li>PowerShell may require execution policy: <code>Set-ExecutionPolicy RemoteSigned</code></li> </ul>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>After installation:</p> <ol> <li>Quick Start Guide - Get started in 5 minutes</li> <li>Configuration - Set up your project</li> <li>CLI Commands - Learn available commands</li> </ol>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: https://polyglotffi.com/</li> <li>Issues: https://github.com/chizy7/polyglot-ffi/issues</li> <li>Discussions: https://github.com/chizy7/polyglot-ffi/discussions</li> </ul>"},{"location":"quick_reference/","title":"Quick Reference Card","text":"<p>Quick command reference for Polyglot FFI</p>"},{"location":"quick_reference/#installation","title":"Installation","text":"<pre><code># From PyPI\npip install polyglot-ffi\n\n# From source (development)\ngit clone https://github.com/chizy7/polyglot-ffi\ncd polyglot-ffi\npip install -e \".[dev]\"\n</code></pre>"},{"location":"quick_reference/#common-commands","title":"Common Commands","text":""},{"location":"quick_reference/#initialize-project","title":"Initialize Project","text":"<pre><code># Create new project\npolyglot-ffi init my-project\n\n# Create with specific languages\npolyglot-ffi init my-project --lang python --lang rust\n\n# Interactive mode\npolyglot-ffi init --interactive\n</code></pre>"},{"location":"quick_reference/#generate-bindings","title":"Generate Bindings","text":"<pre><code># Basic generation\npolyglot-ffi generate src/file.mli\n\n# With output directory\npolyglot-ffi generate src/file.mli -o output/\n\n# With custom module name\npolyglot-ffi generate src/file.mli -n mylib\n\n# Preview without writing (dry-run)\npolyglot-ffi generate src/file.mli --dry-run\n\n# Force regeneration\npolyglot-ffi generate src/file.mli --force\n</code></pre>"},{"location":"quick_reference/#watch-mode-auto-regenerate","title":"Watch Mode (Auto-regenerate)","text":"<pre><code># Watch single file\npolyglot-ffi watch src/crypto.mli\n\n# Watch multiple files\npolyglot-ffi watch src/*.mli\n\n# Watch with auto-build\npolyglot-ffi watch --build\n</code></pre>"},{"location":"quick_reference/#validate-project","title":"Validate Project","text":"<pre><code># Check configuration and setup\npolyglot-ffi check\n\n# Check with dependencies\npolyglot-ffi check --check-deps\n\n# Check specific language\npolyglot-ffi check --lang python\n</code></pre>"},{"location":"quick_reference/#clean-generated-files","title":"Clean Generated Files","text":"<pre><code># Preview what will be deleted (dry-run)\npolyglot-ffi clean --dry-run\n\n# Clean generated files\npolyglot-ffi clean\n\n# Clean everything including directories\npolyglot-ffi clean --all\n</code></pre>"},{"location":"quick_reference/#check-version","title":"Check Version","text":"<pre><code># Show version\npolyglot-ffi --version\n\n# Show help\npolyglot-ffi --help\n</code></pre>"},{"location":"quick_reference/#run-tests-development","title":"Run Tests (Development)","text":"<pre><code># All tests\npytest tests/ -v\n\n# With coverage\npytest tests/ --cov=src/polyglot_ffi --cov-report=html\n\n# Specific test file\npytest tests/unit/test_generators.py -v\n</code></pre>"},{"location":"quick_reference/#type-mappings","title":"Type Mappings","text":"OCaml Python C <code>string</code> <code>str</code> <code>char*</code> <code>int</code> <code>int</code> <code>int</code> <code>float</code> <code>float</code> <code>double</code> <code>bool</code> <code>bool</code> <code>int</code> <code>unit</code> <code>None</code> <code>void</code> <code>'a option</code> <code>Optional[T]</code> <code>void*</code> <code>'a list</code> <code>List[T]</code> <code>void*</code> <code>'a * 'b</code> <code>Tuple[T, U]</code> <code>void*</code>"},{"location":"quick_reference/#example-workflows","title":"Example Workflows","text":""},{"location":"quick_reference/#quick-start","title":"Quick Start","text":"<pre><code># 1. Initialize project\npolyglot-ffi init my-crypto-lib\ncd my-crypto-lib\n\n# 2. Create OCaml interface\ncat &gt; src/crypto.mli &lt;&lt; 'EOF'\nval encrypt : string -&gt; string\nval decrypt : string -&gt; string\nEOF\n\n# 3. Generate bindings\npolyglot-ffi generate src/crypto.mli\n\n# 4. View generated files\nls -la generated/\n</code></pre>"},{"location":"quick_reference/#development-workflow","title":"Development Workflow","text":"<pre><code># 1. Start watch mode\npolyglot-ffi watch src/*.mli --build &amp;\n\n# 2. Edit your .mli files\n# (bindings auto-regenerate on save)\n\n# 3. Check configuration\npolyglot-ffi check --check-deps\n\n# 4. Clean when needed\npolyglot-ffi clean --dry-run  # Preview first\npolyglot-ffi clean            # Then clean\n</code></pre>"},{"location":"quick_reference/#getting-help","title":"Getting Help","text":"<pre><code># Main help\npolyglot-ffi --help\n\n# Command-specific help\npolyglot-ffi init --help\npolyglot-ffi generate --help\npolyglot-ffi watch --help\npolyglot-ffi check --help\npolyglot-ffi clean --help\n</code></pre>"},{"location":"quick_reference/#configuration-file","title":"Configuration File","text":"<p>Location: <code>polyglot.toml</code> (project root)</p> <pre><code>[project]\nname = \"my-project\"\nversion = \"0.1.0\"\n\n[bindings]\nsource_files = [\"src/api.mli\"]\noutput_dir = \"generated\"\n\n[targets.python]\nenabled = true\n</code></pre> <p>See Configuration Guide for full reference.</p>"},{"location":"quick_reference/#upgrading","title":"Upgrading","text":"<pre><code># Upgrade to latest version\npip install --upgrade polyglot-ffi\n\n# Check current version\npolyglot-ffi --version\n</code></pre> <p>See Installation Guide for more options.</p>"},{"location":"quick_reference/#documentation-links","title":"Documentation Links","text":"<ul> <li>Quickstart Guide - Get started in 5 minutes</li> <li>Installation - Setup and upgrade</li> <li>Configuration - Project configuration</li> <li>Architecture - System design</li> <li>Type Mapping - Type reference</li> <li>Contributing - How to contribute</li> <li>Roadmap - Future plans</li> </ul>"},{"location":"quick_reference/#troubleshooting","title":"Troubleshooting","text":"<pre><code># Command not found?\npython -m polyglot_ffi --version\n\n# Permission issues?\npip install --user polyglot-ffi\n\n# Dependencies missing?\npolyglot-ffi check --check-deps\n</code></pre> <p>See Installation Guide for more help.</p> <p>Version: 0.4.3 Documentation: https://polyglotffi.com/ Repository: https://github.com/chizy7/polyglot-ffi </p>"},{"location":"quickstart/","title":"Quickstart Guide","text":"<p>Get started with Polyglot FFI in 5 minutes!</p>"},{"location":"quickstart/#installation","title":"Installation","text":""},{"location":"quickstart/#from-pypi","title":"From PyPI","text":"<pre><code>pip install polyglot-ffi\n</code></pre>"},{"location":"quickstart/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/chizy7/polyglot-ffi\ncd polyglot-ffi\npip install -e \".[dev]\"\n</code></pre>"},{"location":"quickstart/#verify-installation","title":"Verify Installation","text":"<pre><code>polyglot-ffi --version\n# Output: polyglot-ffi, version 0.4.3\n</code></pre>"},{"location":"quickstart/#your-first-project","title":"Your First Project","text":""},{"location":"quickstart/#step-1-initialize-a-new-project","title":"Step 1: Initialize a New Project","text":"<pre><code>polyglot-ffi init my-crypto-lib\ncd my-crypto-lib\n</code></pre> <p>Note: You can use hyphens in project names (like <code>my-crypto-lib</code>). Polyglot-ffi automatically converts them to underscores in generated code for compatibility with OCaml, C, and Python naming rules.</p> <p>This creates: <pre><code>my-crypto-lib/\n\u251c\u2500\u2500 polyglot.toml       # Configuration\n\u251c\u2500\u2500 README.md           # Project documentation\n\u251c\u2500\u2500 Makefile            # Convenience commands\n\u251c\u2500\u2500 .gitignore          # Git ignore rules\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 my-crypto-lib.mli   # OCaml interface (edit this)\n    \u2514\u2500\u2500 my-crypto-lib.ml    # OCaml implementation (edit this)\n</code></pre></p>"},{"location":"quickstart/#step-2-define-your-api","title":"Step 2: Define Your API","text":"<p>Edit <code>src/my-crypto-lib.mli</code>:</p> <pre><code>(* my-crypto-lib.mli *)\n\nval encrypt : string -&gt; string\n(** Encrypt a string using Caesar cipher *)\n\nval decrypt : string -&gt; string\n(** Decrypt a string using Caesar cipher *)\n\nval hash : string -&gt; int\n(** Simple hash function *)\n</code></pre>"},{"location":"quickstart/#step-3-generate-bindings","title":"Step 3: Generate Bindings","text":"<pre><code>polyglot-ffi generate src/my-crypto-lib.mli -o generated/ -n my_crypto\n</code></pre> <p>Output: <pre><code>\u2713 Bindings generated successfully!\n\nGenerated files:\n  \u2713 generated/type_description.ml\n  \u2713 generated/function_description.ml\n  \u2713 generated/my_crypto_stubs.c\n  \u2713 generated/my_crypto_stubs.h\n  \u2713 generated/dune\n  \u2713 generated/dune-project\n  \u2713 generated/my_crypto_py.py\n\nGenerated 3 function(s)\n</code></pre></p>"},{"location":"quickstart/#step-4-implement-your-ocaml-functions","title":"Step 4: Implement Your OCaml Functions","text":"<p>Edit <code>src/my-crypto-lib.ml</code>:</p> <pre><code>(* my-crypto-lib.ml *)\n\nlet encrypt s =\n  String.map (fun c -&gt;\n    if c &gt;= 'a' &amp;&amp; c &lt;= 'z' then\n      Char.chr ((Char.code c - Char.code 'a' + 3) mod 26 + Char.code 'a')\n    else c\n  ) s\n\nlet decrypt s =\n  String.map (fun c -&gt;\n    if c &gt;= 'a' &amp;&amp; c &lt;= 'z' then\n      Char.chr ((Char.code c - Char.code 'a' - 3 + 26) mod 26 + Char.code 'a')\n    else c\n  ) s\n\nlet hash s =\n  String.fold_left (fun acc c -&gt; acc * 31 + Char.code c) 0 s\n\n(* Register functions for C FFI *)\nlet () =\n  Callback.register \"encrypt\" encrypt;\n  Callback.register \"decrypt\" decrypt;\n  Callback.register \"hash\" hash\n</code></pre>"},{"location":"quickstart/#step-5-build-optional-if-you-have-ocamldune","title":"Step 5: Build (Optional - if you have OCaml/Dune)","text":"<p>First, install OCaml build dependencies:</p> <pre><code># Install OCaml dependencies (one-time setup)\nopam install dune ctypes ctypes-foreign\n</code></pre> <p>Then build your bindings:</p> <pre><code># Copy implementation to generated directory\n# Note: If your project name has hyphens, rename files to use underscores\ncp src/my-crypto-lib.ml generated/my_crypto_lib.ml\ncp src/my-crypto-lib.mli generated/my_crypto_lib.mli\n\ncd generated\ndune build\n</code></pre> <p>Important: When copying source files with hyphens in their names, rename them to use underscores (e.g., <code>my-crypto-lib.ml</code> \u2192 <code>my_crypto_lib.ml</code>). This ensures compatibility with OCaml's module naming requirements.</p>"},{"location":"quickstart/#step-6-use-from-python","title":"Step 6: Use from Python","text":"<pre><code># test_crypto.py\nfrom generated.my_crypto_py import encrypt, decrypt, hash\n\n# Test encryption\nmessage = \"hello\"\nencrypted = encrypt(message)\nprint(f\"Original: {message}\")\nprint(f\"Encrypted: {encrypted}\")  # \"khoor\"\n\n# Test decryption\ndecrypted = decrypt(encrypted)\nprint(f\"Decrypted: {decrypted}\")  # \"hello\"\n\n# Test hash\nhash_val = hash(message)\nprint(f\"Hash: {hash_val}\")\n</code></pre>"},{"location":"quickstart/#common-workflows","title":"Common Workflows","text":""},{"location":"quickstart/#generate-with-custom-output","title":"Generate with Custom Output","text":"<pre><code># Specify output directory and module name\npolyglot-ffi generate src/module.mli -o bindings/ -n mymodule\n\n# Dry run (see what would be generated)\npolyglot-ffi generate src/module.mli --dry-run\n\n# Force regeneration\npolyglot-ffi generate src/module.mli --force\n</code></pre>"},{"location":"quickstart/#using-the-makefile","title":"Using the Makefile","text":"<p>The generated <code>Makefile</code> provides convenient commands:</p> <pre><code># Generate bindings\nmake generate\n\n# Build OCaml library\nmake build\n\n# Clean generated files\nmake clean\n\n# Run tests\nmake test\n</code></pre>"},{"location":"quickstart/#example-multiple-function-types","title":"Example: Multiple Function Types","text":"<pre><code>(* example.mli *)\n\n(* String operations *)\nval greet : string -&gt; string\n(** Greet someone *)\n\n(* Math operations *)\nval add : int -&gt; int -&gt; int\n(** Add two integers *)\n\nval multiply : float -&gt; float -&gt; float\n(** Multiply two floats *)\n\n(* Boolean operations *)\nval is_even : int -&gt; bool\n(** Check if number is even *)\n\n(* No parameters *)\nval get_version : unit -&gt; string\n(** Get library version *)\n</code></pre> <p>Generate and use:</p> <pre><code>polyglot-ffi generate example.mli -o gen/ -n example\n</code></pre> <pre><code>from gen.example_py import greet, add, multiply, is_even, get_version\n\nprint(greet(\"Alice\"))      # \"Hello, Alice!\"\nprint(add(2, 3))           # 5\nprint(multiply(2.5, 4.0))  # 10.0\nprint(is_even(4))          # True\nprint(get_version())       # \"1.0.0\"\n</code></pre>"},{"location":"quickstart/#supported-types","title":"Supported Types","text":""},{"location":"quickstart/#primitive-types","title":"Primitive Types","text":"OCaml Type C Type Python Type Example <code>string</code> <code>char*</code> <code>str</code> <code>\"hello\"</code> <code>int</code> <code>int</code> <code>int</code> <code>42</code> <code>float</code> <code>double</code> <code>float</code> <code>3.14</code> <code>bool</code> <code>int</code> <code>bool</code> <code>True</code> <code>unit</code> <code>void</code> <code>None</code> <code>None</code>"},{"location":"quickstart/#complex-types","title":"Complex Types","text":"OCaml Type Python Type Example <code>'a option</code> <code>Optional[T]</code> <code>Optional[int]</code> <code>'a list</code> <code>List[T]</code> <code>List[str]</code> <code>'a * 'b</code> <code>Tuple[T, U]</code> <code>Tuple[int, str]</code> <p>See Type Mapping Guide for complete reference.</p>"},{"location":"quickstart/#project-structure","title":"Project Structure","text":"<p>After initialization:</p> <pre><code>my-project/\n\u251c\u2500\u2500 polyglot.toml              # Configuration\n\u251c\u2500\u2500 README.md                  # Documentation\n\u251c\u2500\u2500 Makefile                   # Build commands\n\u251c\u2500\u2500 .gitignore                 # Git ignore\n\u2502\n\u251c\u2500\u2500 src/                       # Your OCaml source\n\u2502   \u251c\u2500\u2500 my-project.mli        # Interface (edit this)\n\u2502   \u2514\u2500\u2500 my-project.ml         # Implementation (edit this)\n\u2502\n\u2514\u2500\u2500 generated/                 # Generated bindings (don't edit)\n    \u251c\u2500\u2500 type_description.ml   # OCaml types\n    \u251c\u2500\u2500 function_description.ml  # OCaml ctypes\n    \u251c\u2500\u2500 my-project_stubs.c    # C wrappers\n    \u251c\u2500\u2500 my-project_stubs.h    # C headers\n    \u251c\u2500\u2500 dune                  # Build config\n    \u251c\u2500\u2500 dune-project          # Dune metadata\n    \u2514\u2500\u2500 my-project_py.py      # Python wrapper\n</code></pre>"},{"location":"quickstart/#configuration-file","title":"Configuration File","text":"<p><code>polyglot.toml</code>:</p> <pre><code>[project]\nname = \"my-project\"\nversion = \"0.1.0\"\nsource_lang = \"ocaml\"\n\n[languages.ocaml]\nsource_dir = \"src\"\nbuild_system = \"dune\"\n\n[languages.python]\ntarget_dir = \"generated\"\nmin_version = \"3.8\"\n\n[bindings]\nauto_discover = true\ninterfaces = [\"src/my-project.mli\"]\n\n[generate]\nwatch = false\nverbose = false\n</code></pre>"},{"location":"quickstart/#advanced-features","title":"Advanced Features","text":""},{"location":"quickstart/#watch-mode-auto-regenerate","title":"Watch Mode (Auto-regenerate)","text":"<pre><code># Watch files and auto-regenerate on changes\npolyglot-ffi watch src/*.mli\n\n# Watch with auto-build\npolyglot-ffi watch src/*.mli --build\n</code></pre>"},{"location":"quickstart/#validate-configuration","title":"Validate Configuration","text":"<pre><code># Check project configuration\npolyglot-ffi check\n\n# Check with dependencies\npolyglot-ffi check --check-deps\n</code></pre>"},{"location":"quickstart/#clean-generated-files","title":"Clean Generated Files","text":"<pre><code># Preview what will be deleted\npolyglot-ffi clean --dry-run\n\n# Actually clean\npolyglot-ffi clean\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Complex types: Try options, lists, and tuples</li> <li>Watch mode: Use <code>polyglot-ffi watch</code> for auto-regeneration</li> <li>Configuration: Customize <code>polyglot.toml</code> for your project</li> <li>Multiple modules: Generate bindings for each <code>.mli</code> file</li> <li>CI/CD: Add <code>polyglot-ffi generate</code> to your build pipeline</li> <li>Examples: Check out <code>examples/</code> directory for more patterns</li> </ul>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quickstart/#command-not-found","title":"Command not found","text":"<pre><code># Make sure you're in a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install\npip install -e \".[dev]\"\n</code></pre>"},{"location":"quickstart/#import-errors-in-python","title":"Import errors in Python","text":"<p>Make sure the shared library is built and in the correct location. The Python wrapper expects <code>lib{module_name}.so</code> in the same directory.</p>"},{"location":"quickstart/#parse-errors","title":"Parse errors","text":"<p>Check your <code>.mli</code> syntax: - Use <code>val name : type</code> format - Currently supports only primitive types - Multi-line signatures need continuation</p>"},{"location":"quickstart/#help-and-support","title":"Help and Support","text":"<pre><code># Get help\npolyglot-ffi --help\n\n# Command-specific help\npolyglot-ffi init --help\npolyglot-ffi generate --help\npolyglot-ffi watch --help\npolyglot-ffi check --help\npolyglot-ffi clean --help\n</code></pre>"},{"location":"quickstart/#resources","title":"Resources","text":"<ul> <li>Documentation: https://polyglotffi.com/</li> <li>Quick Reference: quick_reference.md</li> <li>Type Mapping: type-mapping.md</li> <li>Architecture: architecture.md</li> <li>Issues: https://github.com/chizy7/polyglot-ffi/issues</li> <li>Examples: See <code>examples/</code> directory in repository</li> </ul>"},{"location":"quickstart/#upgrading","title":"Upgrading","text":"<pre><code># Upgrade to latest version\npip install --upgrade polyglot-ffi\n\n# Check version\npolyglot-ffi --version\n</code></pre> <p>See Installation Guide for more options.</p> <p>Ready to eliminate FFI boilerplate? Let's build something amazing!</p> <p>Version: 0.4.3 | Documentation: https://polyglotffi.com/</p>"},{"location":"type-mapping/","title":"Type Mapping Reference","text":"<p>Version: v0.4.3</p> <p>Complete guide to type mappings across languages in Polyglot FFI.</p>"},{"location":"type-mapping/#implementation-status","title":"Implementation Status","text":"Type Category Status Notes Primitives Fully Supported <code>string</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>unit</code> Option Types Fully Supported <code>'a option</code> \u2192 <code>Optional[T]</code>, <code>Option&lt;T&gt;</code> List Types Fully Supported <code>'a list</code> \u2192 <code>List[T]</code>, <code>Vec&lt;T&gt;</code> Tuple Types Fully Supported <code>'a * 'b</code> \u2192 <code>Tuple[T1, T2]</code>, <code>(T1, T2)</code> Record Types Partial Support Parsed, basic generation implemented Variant Types Partial Support Parsed, basic generation implemented Type Variables Supported Generic/polymorphic types <p>Legend: - Fully Supported - Production ready, tested, documented - Partial Support - Basic functionality works, advanced features in progress</p>"},{"location":"type-mapping/#primitive-types","title":"Primitive Types","text":"OCaml IR C Python Rust Notes <code>string</code> <code>STRING</code> <code>char*</code> <code>str</code> <code>String</code> UTF-8 encoded <code>int</code> <code>INT</code> <code>int</code> <code>int</code> <code>i64</code> 31/63-bit on OCaml <code>float</code> <code>FLOAT</code> <code>double</code> <code>float</code> <code>f64</code> IEEE 754 <code>bool</code> <code>BOOL</code> <code>int</code> <code>bool</code> <code>bool</code> 0=false, 1=true <code>unit</code> <code>UNIT</code> <code>void</code> <code>None</code> <code>()</code> No value"},{"location":"type-mapping/#conversion-details","title":"Conversion Details","text":""},{"location":"type-mapping/#string","title":"String","text":"<p>OCaml \u2192 C: <pre><code>ml_string = caml_copy_string(c_string);\n</code></pre></p> <p>C \u2192 OCaml: <pre><code>char* c_string = strdup(String_val(ml_string));\n</code></pre></p> <p>Python: <pre><code># Python \u2192 C\nc_bytes = py_string.encode('utf-8')\n\n# C \u2192 Python\npy_string = c_bytes.decode('utf-8')\n</code></pre></p>"},{"location":"type-mapping/#integer","title":"Integer","text":"<p>OCaml \u2192 C: <pre><code>ml_int = Val_int(c_int);\n</code></pre></p> <p>C \u2192 OCaml: <pre><code>int c_int = Int_val(ml_int);\n</code></pre></p>"},{"location":"type-mapping/#float","title":"Float","text":"<p>OCaml \u2192 C: <pre><code>ml_float = caml_copy_double(c_double);\n</code></pre></p> <p>C \u2192 OCaml: <pre><code>double c_double = Double_val(ml_float);\n</code></pre></p>"},{"location":"type-mapping/#boolean","title":"Boolean","text":"<p>OCaml \u2192 C: <pre><code>ml_bool = Val_bool(c_bool);\n</code></pre></p> <p>C \u2192 OCaml: <pre><code>int c_bool = Bool_val(ml_bool);\n</code></pre></p>"},{"location":"type-mapping/#complex-types","title":"Complex Types","text":""},{"location":"type-mapping/#option-types","title":"Option Types","text":"<p>OCaml: <pre><code>val find : string -&gt; string option\nval parse : string -&gt; int option\n</code></pre></p> <p>Type Mappings:</p> Language Type Representation OCaml <code>'a option</code> <code>Some x</code> or <code>None</code> IR <code>OPTION</code> <code>IRType(kind=OPTION, params=[...])</code> C <code>void*</code> Opaque pointer (GC-safe) Python <code>Optional[T]</code> <code>value</code> or <code>None</code> Rust <code>Option&lt;T&gt;</code> <code>Some(value)</code> or <code>None</code> <p>Example: <pre><code># Python\nuser = find_user(\"john\")  # Returns Optional[User]\nif user is not None:\n    print(user.name)\n</code></pre></p>"},{"location":"type-mapping/#list-types","title":"List Types","text":"<p>OCaml: <pre><code>val get_all : unit -&gt; string list\nval filter : (int -&gt; bool) -&gt; int list -&gt; int list\n</code></pre></p> <p>Type Mappings:</p> Language Type Representation OCaml <code>'a list</code> <code>[x; y; z]</code> IR <code>LIST</code> <code>IRType(kind=LIST, params=[...])</code> C <code>void*</code> Opaque OCaml list pointer Python <code>List[T]</code> <code>[x, y, z]</code> Rust <code>Vec&lt;T&gt;</code> <code>vec![x, y, z]</code> <p>Example: <pre><code># Python\nusers = get_all_users()  # Returns List[User]\nfor user in users:\n    print(user.name)\n</code></pre></p>"},{"location":"type-mapping/#tuple-types","title":"Tuple Types","text":"<p>OCaml: <pre><code>val pair : string -&gt; int * string\nval triple : unit -&gt; int * string * float\n</code></pre></p> <p>Type Mappings:</p> Language Type Representation OCaml <code>'a * 'b</code> <code>(x, y)</code> IR <code>TUPLE</code> <code>IRType(kind=TUPLE, params=[...])</code> C <code>void*</code> Opaque tuple pointer Python <code>Tuple[T1, T2]</code> <code>(x, y)</code> Rust <code>(T1, T2)</code> <code>(x, y)</code> <p>Example: <pre><code># Python\nname, age = get_name_and_age(user)  # Returns Tuple[str, int]\nprint(f\"{name} is {age} years old\")\n</code></pre></p>"},{"location":"type-mapping/#record-types","title":"Record Types","text":"<p>OCaml: <pre><code>type user = {\n  name: string;\n  age: int;\n  email: string option;\n}\n\nval create_user : string -&gt; int -&gt; string -&gt; user\nval get_name : user -&gt; string\n</code></pre></p> <p>Type Mappings:</p> Language Type Representation OCaml <code>type t = { ... }</code> Record with fields IR <code>RECORD</code> <code>IRTypeDefinition(kind=RECORD, fields={...})</code> C <code>void*</code> Opaque record pointer Python <code>class User</code> Python class Rust <code>struct User</code> Rust struct <p>Example: <pre><code># Python (type hint generated)\ndef create_user(name: str, age: int, email: str) -&gt; User:\n    pass\n\nuser = create_user(\"John\", 25, \"john@example.com\")\n</code></pre></p>"},{"location":"type-mapping/#variant-types","title":"Variant Types","text":"<p>OCaml: <pre><code>type result = Ok of string | Error of string\ntype status = Active | Inactive | Pending\n\nval process : string -&gt; result\nval check : user -&gt; status\n</code></pre></p> <p>Type Mappings:</p> Language Type Representation OCaml <code>type t = A \\| B of 'a</code> Sum type with constructors IR <code>VARIANT</code> <code>IRTypeDefinition(kind=VARIANT, variants={...})</code> C <code>void*</code> Opaque variant pointer Python <code>class Result</code> Python class (enum-like) Rust <code>enum Result</code> Rust enum <p>Example: <pre><code># Python\nresult = process(\"input\")  # Returns Result\n# Handle different variants in application logic\n</code></pre></p>"},{"location":"type-mapping/#type-variables-polymorphic-types","title":"Type Variables (Polymorphic Types)","text":"<p>OCaml: <pre><code>val identity : 'a -&gt; 'a\nval map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list\n</code></pre></p> <p>Type Mappings:</p> Language Type Representation OCaml <code>'a</code>, <code>'b</code> Type variables IR <code>PRIMITIVE</code> <code>IRType(kind=PRIMITIVE, name=\"'a\")</code> C <code>void*</code> Generic pointer Python <code>Any</code> <code>typing.Any</code> Rust <code>T</code>, <code>U</code> Generic type parameters"},{"location":"type-mapping/#complex-combinations","title":"Complex Combinations","text":"<p>Nested Types: <pre><code>val find : string -&gt; user option\nval get_optional_lists : unit -&gt; int list option\nval process : (int * string) list -&gt; string list option\n</code></pre></p> <p>Python Mappings: <pre><code>def find(input: str) -&gt; Optional[User]: ...\ndef get_optional_lists() -&gt; Optional[List[int]]: ...\ndef process(pairs: List[Tuple[int, str]]) -&gt; Optional[List[str]]: ...\n</code></pre></p>"},{"location":"type-mapping/#complete-type-matrix","title":"Complete Type Matrix","text":""},{"location":"type-mapping/#all-supported-types","title":"All Supported Types","text":"OCaml Type IR Kind C Type Python Type Rust Type Primitives <code>string</code> <code>PRIMITIVE</code> <code>char*</code> <code>str</code> <code>String</code> <code>int</code> <code>PRIMITIVE</code> <code>int</code> <code>int</code> <code>i64</code> <code>float</code> <code>PRIMITIVE</code> <code>double</code> <code>float</code> <code>f64</code> <code>bool</code> <code>PRIMITIVE</code> <code>int</code> <code>bool</code> <code>bool</code> <code>unit</code> <code>PRIMITIVE</code> <code>void</code> <code>None</code> <code>()</code> Containers <code>'a option</code> <code>OPTION</code> <code>void*</code> <code>Optional[T]</code> <code>Option&lt;T&gt;</code> <code>'a list</code> <code>LIST</code> <code>void*</code> <code>List[T]</code> <code>Vec&lt;T&gt;</code> <code>'a * 'b</code> <code>TUPLE</code> <code>void*</code> <code>Tuple[T1, T2]</code> <code>(T1, T2)</code> Custom <code>type t = {...}</code> <code>RECORD</code> <code>void*</code> <code>T</code> (class) <code>struct T</code> <code>type t = A \\| B</code> <code>VARIANT</code> <code>void*</code> <code>T</code> (class) <code>enum T</code> <code>'a</code> <code>PRIMITIVE</code> <code>void*</code> <code>Any</code> <code>T</code> Combined <code>int list option</code> nested <code>void*</code> <code>Optional[List[int]]</code> <code>Option&lt;Vec&lt;i64&gt;&gt;</code> <code>(int * string) list</code> nested <code>void*</code> <code>List[Tuple[int, str]]</code> <code>Vec&lt;(i64, String)&gt;</code>"},{"location":"api/","title":"API Reference","text":"<p>API documentation for Polyglot FFI's public interfaces.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>Polyglot FFI provides a modular API organized into five main components:</p> <pre><code>graph LR\n    A[Parser] --&gt; B[IR Types]\n    B --&gt; C[Type System]\n    B --&gt; D[Generators]\n    E[Config] --&gt; D\n    C --&gt; D</code></pre>"},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#parser","title":"Parser","text":"<p>Parse source language files into intermediate representation.</p> <p>Key Classes: - <code>OCamlParser</code> - Parse OCaml .mli files - <code>parse_mli_file()</code> - Convenience function for file parsing - <code>parse_mli_string()</code> - Parse OCaml code from strings</p> <p>Use When: - Reading OCaml interface files - Converting source code to IR - Building custom parsers</p> <p>Example: <pre><code>from polyglot_ffi.parsers.ocaml import parse_mli_file\n\nmodule = parse_mli_file(Path(\"crypto.mli\"))\nprint(f\"Found {len(module.functions)} functions\")\n</code></pre></p>"},{"location":"api/#ir-types","title":"IR Types","text":"<p>Language-agnostic intermediate representation of types and functions.</p> <p>Key Classes: - <code>IRType</code> - Represents a type - <code>IRFunction</code> - Represents a function - <code>IRModule</code> - Represents a module - <code>TypeKind</code> - Enumeration of type categories</p> <p>Use When: - Building parsers or generators - Manipulating type representations - Creating custom IR transformations</p> <p>Example: <pre><code>from polyglot_ffi.ir.types import IRFunction, IRParameter, STRING\n\nfunc = IRFunction(\n    name=\"encrypt\",\n    parameters=[IRParameter(name=\"data\", type=STRING)],\n    return_type=STRING\n)\n</code></pre></p>"},{"location":"api/#type-system","title":"Type System","text":"<p>Manage type mappings between languages.</p> <p>Key Classes: - <code>TypeRegistry</code> - Central type mapping registry - <code>get_default_registry()</code> - Get global registry instance</p> <p>Use When: - Mapping IR types to target languages - Registering custom type mappings - Validating type support</p> <p>Example: <pre><code>from polyglot_ffi.type_system.registry import get_default_registry\nfrom polyglot_ffi.ir.types import STRING\n\nregistry = get_default_registry()\npython_type = registry.get_mapping(STRING, \"python\")  # \"str\"\n</code></pre></p>"},{"location":"api/#generators","title":"Generators","text":"<p>Generate target language code from IR.</p> <p>Key Classes: - <code>CtypesGenerator</code> - Generate OCaml ctypes bindings - <code>CStubGenerator</code> - Generate C wrapper code - <code>PythonGenerator</code> - Generate Python wrappers - <code>DuneGenerator</code> - Generate Dune build configs</p> <p>Use When: - Generating bindings for target languages - Creating custom generators - Producing build configurations</p> <p>Example: <pre><code>from polyglot_ffi.generators.python_gen import PythonGenerator\n\ngen = PythonGenerator()\ncode = gen.generate(module, \"crypto\")\nPath(\"crypto_py.py\").write_text(code)\n</code></pre></p>"},{"location":"api/#configuration","title":"Configuration","text":"<p>Load and validate project configuration.</p> <p>Key Classes: - <code>ProjectConfig</code> - Complete project configuration - <code>BindingsConfig</code> - Bindings-specific settings - <code>TargetConfig</code> - Per-target-language configuration - <code>load_config()</code> - Load from polyglot.toml - <code>validate_config()</code> - Validate configuration</p> <p>Use When: - Loading project settings - Validating configuration files - Creating default configurations</p> <p>Example: <pre><code>from polyglot_ffi.core.config import load_config\n\nconfig = load_config()\nprint(f\"Project: {config.name}\")\nfor target in config.targets:\n    if target.enabled:\n        print(f\"  Target: {target.language}\")\n</code></pre></p>"},{"location":"api/#quick-start","title":"Quick Start","text":""},{"location":"api/#basic-workflow","title":"Basic Workflow","text":"<pre><code>from pathlib import Path\nfrom polyglot_ffi.parsers.ocaml import parse_mli_file\nfrom polyglot_ffi.generators.python_gen import PythonGenerator\n\n# 1. Parse OCaml interface\nmodule = parse_mli_file(Path(\"crypto.mli\"))\n\n# 2. Generate Python bindings\ngenerator = PythonGenerator()\npython_code = generator.generate(module, \"crypto\")\n\n# 3. Save output\nPath(\"crypto_py.py\").write_text(python_code)\n</code></pre>"},{"location":"api/#complete-generation","title":"Complete Generation","text":"<pre><code>from pathlib import Path\nfrom polyglot_ffi.parsers.ocaml import parse_mli_file\nfrom polyglot_ffi.generators.ctypes_gen import CtypesGenerator\nfrom polyglot_ffi.generators.c_stubs_gen import CStubGenerator\nfrom polyglot_ffi.generators.python_gen import PythonGenerator\nfrom polyglot_ffi.generators.dune_gen import DuneGenerator\n\n# Parse\nmodule = parse_mli_file(Path(\"crypto.mli\"))\n\n# Generate all artifacts\noutput = Path(\"generated\")\noutput.mkdir(exist_ok=True)\n\n# OCaml ctypes\nctypes = CtypesGenerator()\n(output / \"type_description.ml\").write_text(\n    ctypes.generate_type_description(module)\n)\n(output / \"function_description.ml\").write_text(\n    ctypes.generate_function_description(module)\n)\n\n# C stubs\nc_gen = CStubGenerator()\n(output / \"stubs.c\").write_text(c_gen.generate_stubs(module, \"crypto\"))\n(output / \"stubs.h\").write_text(c_gen.generate_header(module, \"crypto\"))\n\n# Python wrapper\npy_gen = PythonGenerator()\n(output / \"crypto_py.py\").write_text(py_gen.generate(module, \"crypto\"))\n\n# Dune build\ndune = DuneGenerator()\n(output / \"dune\").write_text(dune.generate_dune(\"crypto\"))\n(output / \"dune-project\").write_text(dune.generate_dune_project(\"crypto\"))\n</code></pre>"},{"location":"api/#using-configuration","title":"Using Configuration","text":"<pre><code>from pathlib import Path\nfrom polyglot_ffi.core.config import load_config\nfrom polyglot_ffi.parsers.ocaml import parse_mli_file\nfrom polyglot_ffi.generators.python_gen import PythonGenerator\n\n# Load project configuration\nconfig = load_config()\n\n# Process each source file\nfor source_file in config.bindings.source_files:\n    module = parse_mli_file(Path(source_file))\n\n    # Generate for each enabled target\n    for target in config.targets:\n        if target.enabled and target.language == \"python\":\n            gen = PythonGenerator()\n            code = gen.generate(module, config.name)\n\n            # Write to target output directory\n            output_path = Path(target.output_dir) / f\"{config.name}_py.py\"\n            output_path.parent.mkdir(parents=True, exist_ok=True)\n            output_path.write_text(code)\n</code></pre>"},{"location":"api/#api-design-principles","title":"API Design Principles","text":""},{"location":"api/#1-language-agnostic-ir","title":"1. Language-Agnostic IR","text":"<p>Parsers and generators are completely decoupled through the IR layer:</p> <ul> <li>Parsers only need to understand: Source Language \u2192 IR</li> <li>Generators only need to understand: IR \u2192 Target Language</li> <li>Adding new languages requires implementing only one side</li> </ul>"},{"location":"api/#2-type-safety","title":"2. Type Safety","text":"<p>All components use Python type hints for better IDE support and error catching:</p> <pre><code>def parse_file(cls, path: Path) -&gt; IRModule:\n    \"\"\"Parse returns a typed IRModule.\"\"\"\n\ndef generate(self, module: IRModule, name: str) -&gt; str:\n    \"\"\"Generate requires a typed IRModule input.\"\"\"\n</code></pre>"},{"location":"api/#3-composability","title":"3. Composability","text":"<p>Components can be used independently or composed:</p> <pre><code># Use parser alone\nmodule = parse_mli_file(Path(\"api.mli\"))\n\n# Use generator alone (with manually created IR)\ngen = PythonGenerator()\ncode = gen.generate(my_custom_module, \"api\")\n\n# Compose them\nmodule = parse_mli_file(Path(\"api.mli\"))\ncode = PythonGenerator().generate(module, \"api\")\n</code></pre>"},{"location":"api/#4-error-handling","title":"4. Error Handling","text":"<p>All components provide rich error messages:</p> <pre><code>from polyglot_ffi.utils.errors import (\n    ParseError,\n    GenerationError,\n    ConfigurationError,\n    TypeMappingError\n)\n\ntry:\n    module = parse_mli_file(Path(\"api.mli\"))\nexcept ParseError as e:\n    print(f\"Line {e.context.line}: {e.message}\")\n    if e.suggestions:\n        print(f\"Try: {', '.join(e.suggestions)}\")\n</code></pre>"},{"location":"api/#5-performance","title":"5. Performance","text":"<p>All components are optimized for speed:</p> <ul> <li>Regex pre-compilation in parsers</li> <li>Type mapping caching in registry</li> <li>Efficient string building in generators</li> <li>Lazy initialization where appropriate</li> </ul>"},{"location":"api/#common-patterns","title":"Common Patterns","text":""},{"location":"api/#creating-a-custom-generator","title":"Creating a Custom Generator","text":"<pre><code>from polyglot_ffi.ir.types import IRModule, IRFunction\nfrom polyglot_ffi.type_system.registry import get_default_registry\n\nclass GoGenerator:\n    \"\"\"Generate Go FFI bindings.\"\"\"\n\n    def generate(self, module: IRModule, package: str) -&gt; str:\n        registry = get_default_registry()\n        lines = [\n            f\"package {package}\",\n            \"\",\n            \"// #cgo LDFLAGS: -l{package}\",\n            \"// #include &lt;stdlib.h&gt;\",\n            '// #include \"stubs.h\"',\n            \"import \\\"C\\\"\",\n            \"\",\n        ]\n\n        for func in module.functions:\n            # Generate Go function wrapper\n            go_params = []\n            for param in func.parameters:\n                go_type = self._map_type(param.type, registry)\n                go_params.append(f\"{param.name} {go_type}\")\n\n            go_return = self._map_type(func.return_type, registry)\n            params_str = \", \".join(go_params)\n\n            lines.append(f\"func {func.name.title()}({params_str}) {go_return} {{\")\n            lines.append(f\"\\t// Call C function\")\n            lines.append(f\"\\treturn C.ml_{func.name}(...)\")\n            lines.append(\"}\")\n            lines.append(\"\")\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/#type-mapping-with-custom-types","title":"Type Mapping with Custom Types","text":"<pre><code>from polyglot_ffi.type_system.registry import TypeRegistry\nfrom polyglot_ffi.ir.types import ir_primitive\n\n# Create custom registry\nregistry = TypeRegistry()\n\n# Register custom types\nregistry.register_primitive(\"uuid\", {\n    \"python\": \"uuid.UUID\",\n    \"rust\": \"Uuid\",\n    \"go\": \"string\",\n    \"c\": \"char*\"\n})\n\nregistry.register_primitive(\"datetime\", {\n    \"python\": \"datetime.datetime\",\n    \"rust\": \"DateTime&lt;Utc&gt;\",\n    \"go\": \"time.Time\",\n    \"c\": \"time_t\"\n})\n\n# Use custom types\nuuid_type = ir_primitive(\"uuid\")\npython_type = registry.get_mapping(uuid_type, \"python\")  # \"uuid.UUID\"\n</code></pre>"},{"location":"api/#next-steps","title":"Next Steps","text":"<ul> <li>New to the API? Start with Parser to understand the input</li> <li>Building a generator? Read Generators and Type System</li> <li>Extending types? Check IR Types and Type System</li> <li>Using in applications? See Configuration for project setup</li> </ul>"},{"location":"api/#see-also","title":"See Also","text":"<ul> <li>Architecture - System design overview</li> <li>Type Mapping - Type system details</li> <li>Contributing - Development guidelines</li> </ul>"},{"location":"api/config/","title":"Configuration API","text":"<p>The configuration module handles loading, validating, and managing project configuration from <code>polyglot.toml</code> files.</p>"},{"location":"api/config/#overview","title":"Overview","text":"<p>Configuration provides:</p> <ul> <li>TOML parsing: Load configuration from files</li> <li>Validation: Ensure configuration is valid</li> <li>Type safety: Pydantic models for configuration</li> <li>Defaults: Sensible default values</li> <li>Error reporting: Clear error messages</li> </ul>"},{"location":"api/config/#configuration-models","title":"Configuration Models","text":""},{"location":"api/config/#polyglot_ffi.core.config.PolyglotConfig","title":"<code>polyglot_ffi.core.config.PolyglotConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete polyglot.toml configuration.</p> Source code in <code>src/polyglot_ffi/core/config.py</code> <pre><code>class PolyglotConfig(BaseModel):\n    \"\"\"Complete polyglot.toml configuration.\"\"\"\n\n    project: ProjectConfig\n    source: SourceConfig\n    targets: List[TargetConfig] = Field(default_factory=list)\n    build: BuildConfig = Field(default_factory=BuildConfig)\n    type_mappings: Dict[str, TypeMappingConfig] = Field(\n        default_factory=dict, description=\"Custom type mappings\"\n    )\n\n    @field_validator(\"targets\")\n    @classmethod\n    def validate_targets(cls, v: List[TargetConfig]) -&gt; List[TargetConfig]:\n        \"\"\"Ensure at least one target is configured.\"\"\"\n        if not v:\n            raise ValueError(\"At least one target language must be configured\")\n        return v\n\n    model_config = ConfigDict(extra=\"allow\")  # Allow extra fields for future expansion\n</code></pre>"},{"location":"api/config/#polyglot_ffi.core.config.PolyglotConfig-functions","title":"Functions","text":""},{"location":"api/config/#polyglot_ffi.core.config.PolyglotConfig.validate_targets","title":"<code>validate_targets(v)</code>  <code>classmethod</code>","text":"<p>Ensure at least one target is configured.</p> Source code in <code>src/polyglot_ffi/core/config.py</code> <pre><code>@field_validator(\"targets\")\n@classmethod\ndef validate_targets(cls, v: List[TargetConfig]) -&gt; List[TargetConfig]:\n    \"\"\"Ensure at least one target is configured.\"\"\"\n    if not v:\n        raise ValueError(\"At least one target language must be configured\")\n    return v\n</code></pre>"},{"location":"api/config/#polyglot_ffi.core.config.SourceConfig","title":"<code>polyglot_ffi.core.config.SourceConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Source language configuration.</p> Source code in <code>src/polyglot_ffi/core/config.py</code> <pre><code>class SourceConfig(BaseModel):\n    \"\"\"Source language configuration.\"\"\"\n\n    language: str = Field(..., description=\"Source language (e.g., 'ocaml')\")\n    files: List[str] = Field(default_factory=list, description=\"Source files to process\")\n    dir: Optional[str] = Field(None, description=\"Source directory\")\n    exclude: List[str] = Field(default_factory=list, description=\"Files to exclude\")\n\n    @field_validator(\"language\")\n    @classmethod\n    def validate_language(cls, v: str) -&gt; str:\n        \"\"\"Validate source language.\"\"\"\n        supported = [\"ocaml\"]\n        if v.lower() not in supported:\n            raise ValueError(f\"Unsupported source language: {v}. Supported: {', '.join(supported)}\")\n        return v.lower()\n</code></pre>"},{"location":"api/config/#polyglot_ffi.core.config.SourceConfig-functions","title":"Functions","text":""},{"location":"api/config/#polyglot_ffi.core.config.SourceConfig.validate_language","title":"<code>validate_language(v)</code>  <code>classmethod</code>","text":"<p>Validate source language.</p> Source code in <code>src/polyglot_ffi/core/config.py</code> <pre><code>@field_validator(\"language\")\n@classmethod\ndef validate_language(cls, v: str) -&gt; str:\n    \"\"\"Validate source language.\"\"\"\n    supported = [\"ocaml\"]\n    if v.lower() not in supported:\n        raise ValueError(f\"Unsupported source language: {v}. Supported: {', '.join(supported)}\")\n    return v.lower()\n</code></pre>"},{"location":"api/config/#polyglot_ffi.core.config.TargetConfig","title":"<code>polyglot_ffi.core.config.TargetConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Target language configuration.</p> Source code in <code>src/polyglot_ffi/core/config.py</code> <pre><code>class TargetConfig(BaseModel):\n    \"\"\"Target language configuration.\"\"\"\n\n    language: str = Field(..., description=\"Target language (e.g., 'python', 'rust')\")\n    output_dir: str = Field(default=\"generated\", description=\"Output directory\")\n    enabled: bool = Field(default=True, description=\"Enable this target\")\n\n    @field_validator(\"language\")\n    @classmethod\n    def validate_language(cls, v: str) -&gt; str:\n        \"\"\"Validate target language.\"\"\"\n        supported = [\"python\", \"rust\", \"c\"]\n        if v.lower() not in supported:\n            raise ValueError(f\"Unsupported target language: {v}. Supported: {', '.join(supported)}\")\n        return v.lower()\n</code></pre>"},{"location":"api/config/#polyglot_ffi.core.config.TargetConfig-functions","title":"Functions","text":""},{"location":"api/config/#polyglot_ffi.core.config.TargetConfig.validate_language","title":"<code>validate_language(v)</code>  <code>classmethod</code>","text":"<p>Validate target language.</p> Source code in <code>src/polyglot_ffi/core/config.py</code> <pre><code>@field_validator(\"language\")\n@classmethod\ndef validate_language(cls, v: str) -&gt; str:\n    \"\"\"Validate target language.\"\"\"\n    supported = [\"python\", \"rust\", \"c\"]\n    if v.lower() not in supported:\n        raise ValueError(f\"Unsupported target language: {v}. Supported: {', '.join(supported)}\")\n    return v.lower()\n</code></pre>"},{"location":"api/config/#loading-configuration","title":"Loading Configuration","text":""},{"location":"api/config/#from-file","title":"From File","text":"<pre><code>from pathlib import Path\nfrom polyglot_ffi.core.config import load_config\n\n# Load from default location (./polyglot.toml)\nconfig = load_config()\n\n# Load from specific path\nconfig = load_config(Path(\"custom.toml\"))\n\n# Access configuration\nprint(f\"Project: {config.name}\")\nprint(f\"Targets: {', '.join(t.language for t in config.targets)}\")\n</code></pre>"},{"location":"api/config/#creating-configuration","title":"Creating Configuration","text":"<pre><code>from polyglot_ffi.core.config import (\n    ProjectConfig, BindingsConfig, TargetConfig\n)\n\n# Create configuration programmatically\nconfig = ProjectConfig(\n    name=\"my-project\",\n    version=\"0.1.0\",\n    description=\"My FFI bindings\",\n    bindings=BindingsConfig(\n        source_dir=\"src\",\n        output_dir=\"generated\",\n        source_files=[\"src/api.mli\"]\n    ),\n    targets=[\n        TargetConfig(\n            language=\"python\",\n            enabled=True,\n            output_dir=\"generated/python\"\n        )\n    ]\n)\n</code></pre>"},{"location":"api/config/#saving-configuration","title":"Saving Configuration","text":"<pre><code># Convert to dictionary\nconfig_dict = config.dict()\n\n# Save to TOML\nimport toml\nwith open(\"polyglot.toml\", \"w\") as f:\n    toml.dump(config_dict, f)\n</code></pre>"},{"location":"api/config/#validation","title":"Validation","text":""},{"location":"api/config/#automatic-validation","title":"Automatic Validation","text":"<p>Configuration is validated automatically on load:</p> <pre><code>from polyglot_ffi.core.config import load_config\nfrom polyglot_ffi.utils.errors import ConfigurationError\n\ntry:\n    config = load_config(Path(\"polyglot.toml\"))\nexcept ConfigurationError as e:\n    print(f\"Invalid configuration: {e.message}\")\n    if e.suggestions:\n        print(f\"Suggestions: {', '.join(e.suggestions)}\")\n</code></pre>"},{"location":"api/config/#manual-validation","title":"Manual Validation","text":"<pre><code>from polyglot_ffi.core.config import validate_config\n\n# Validate loaded configuration\nerrors = validate_config(config)\n\nif errors:\n    print(\"Configuration errors:\")\n    for error in errors:\n        print(f\"  - {error}\")\nelse:\n    print(\"Configuration is valid!\")\n</code></pre>"},{"location":"api/config/#common-validation-errors","title":"Common Validation Errors","text":"Error Cause Fix Missing name No project name specified Add <code>name = \"project-name\"</code> Invalid language Unsupported target language Use: python, rust, or go Source file not found .mli file doesn't exist Check source_files paths Duplicate targets Same language listed twice Remove duplicate No enabled targets All targets disabled Enable at least one target"},{"location":"api/config/#configuration-structure","title":"Configuration Structure","text":""},{"location":"api/config/#complete-example","title":"Complete Example","text":"<pre><code># polyglot.toml\n\n# Project metadata\n[project]\nname = \"crypto-bindings\"\nversion = \"0.1.0\"\ndescription = \"FFI bindings for crypto library\"\nauthors = [\"Jane Developer &lt;jane@example.com&gt;\"]\n\n# Bindings configuration\n[bindings]\nsource_dir = \"src\"\noutput_dir = \"generated\"\nsource_files = [\"src/crypto.mli\", \"src/hash.mli\"]\nauto_discover = false\n\n# Python target\n[targets.python]\nenabled = true\noutput_dir = \"generated/python\"\nmodule_prefix = \"crypto\"\n\n# Rust target\n[targets.rust]\nenabled = true\noutput_dir = \"generated/rust\"\n\n# Custom type mappings\n[types.binary_data]\nocaml = \"bytes\"\npython = \"bytes\"\nrust = \"Vec&lt;u8&gt;\"\nc = \"uint8_t*\"\n</code></pre>"},{"location":"api/config/#minimal-example","title":"Minimal Example","text":"<pre><code>[project]\nname = \"simple-project\"\n\n[bindings]\nsource_files = [\"src/api.mli\"]\n\n[targets.python]\nenabled = true\n</code></pre>"},{"location":"api/config/#default-values","title":"Default Values","text":"<p>The configuration system provides sensible defaults:</p> <pre><code># Default bindings config\nbindings = BindingsConfig(\n    source_dir=\"src\",          # Default source directory\n    output_dir=\"generated\",    # Default output directory\n    source_files=[],           # No default files\n    auto_discover=True         # Auto-discover .mli files\n)\n\n# Default target config\ntarget = TargetConfig(\n    language=\"python\",\n    enabled=True,              # Enabled by default\n    output_dir=None,          # Uses bindings.output_dir\n    module_prefix=None        # No prefix by default\n)\n</code></pre>"},{"location":"api/config/#environment-variables","title":"Environment Variables","text":"<p>Override configuration with environment variables:</p> <pre><code>import os\nfrom polyglot_ffi.core.config import load_config\n\n# Override config file location\nos.environ[\"POLYGLOT_FFI_CONFIG\"] = \"/path/to/custom.toml\"\nconfig = load_config()\n\n# Override output directory\nos.environ[\"POLYGLOT_FFI_OUTPUT\"] = \"/tmp/bindings\"\n</code></pre>"},{"location":"api/config/#accessing-configuration-values","title":"Accessing Configuration Values","text":"<pre><code>config = load_config()\n\n# Project information\nprint(f\"Name: {config.name}\")\nprint(f\"Version: {config.version}\")\nprint(f\"Description: {config.description}\")\n\n# Bindings settings\nprint(f\"Source dir: {config.bindings.source_dir}\")\nprint(f\"Output dir: {config.bindings.output_dir}\")\nprint(f\"Source files: {config.bindings.source_files}\")\n\n# Targets\nfor target in config.targets:\n    print(f\"Target: {target.language}\")\n    print(f\"  Enabled: {target.enabled}\")\n    print(f\"  Output: {target.output_dir}\")\n\n# Custom types\nif hasattr(config, 'types'):\n    for type_name, mappings in config.types.items():\n        print(f\"Custom type: {type_name}\")\n        for lang, target_type in mappings.items():\n            print(f\"  {lang}: {target_type}\")\n</code></pre>"},{"location":"api/config/#filtering-targets","title":"Filtering Targets","text":"<pre><code># Get only enabled targets\nenabled_targets = [t for t in config.targets if t.enabled]\n\n# Get specific language target\npython_target = next(\n    (t for t in config.targets if t.language == \"python\"),\n    None\n)\n\nif python_target:\n    print(f\"Python output: {python_target.output_dir}\")\n</code></pre>"},{"location":"api/config/#creating-default-configuration","title":"Creating Default Configuration","text":"<pre><code>from polyglot_ffi.core.config import create_default_config\n\n# Create default config for a new project\nconfig = create_default_config(\n    name=\"my-project\",\n    target_langs=[\"python\", \"rust\"]\n)\n\n# Save to file\nimport toml\nwith open(\"polyglot.toml\", \"w\") as f:\n    toml.dump(config.dict(), f)\n</code></pre>"},{"location":"api/config/#complete-usage-example","title":"Complete Usage Example","text":"<pre><code>from pathlib import Path\nfrom polyglot_ffi.core.config import load_config, validate_config\nfrom polyglot_ffi.utils.errors import ConfigurationError\n\ndef setup_project():\n    \"\"\"Load and validate project configuration.\"\"\"\n    try:\n        # Load configuration\n        config_path = Path(\"polyglot.toml\")\n        config = load_config(config_path)\n\n        # Validate\n        errors = validate_config(config)\n        if errors:\n            print(\"Configuration errors:\")\n            for error in errors:\n                print(f\"  \u2717 {error}\")\n            return None\n\n        print(f\"\u2713 Loaded configuration for {config.name}\")\n\n        # Check source files exist\n        for source_file in config.bindings.source_files:\n            if not Path(source_file).exists():\n                print(f\"\u2717 Source file not found: {source_file}\")\n                return None\n\n        # Check enabled targets\n        enabled = [t for t in config.targets if t.enabled]\n        if not enabled:\n            print(\"\u2717 No enabled targets\")\n            return None\n\n        print(f\"\u2713 Found {len(enabled)} enabled target(s):\")\n        for target in enabled:\n            print(f\"  - {target.language}\")\n\n        return config\n\n    except ConfigurationError as e:\n        print(f\"\u2717 Configuration error: {e.message}\")\n        if e.suggestions:\n            print(\"Suggestions:\")\n            for suggestion in e.suggestions:\n                print(f\"  - {suggestion}\")\n        return None\n\n    except FileNotFoundError:\n        print(\"\u2717 Configuration file not found: polyglot.toml\")\n        print(\"Run 'polyglot-ffi init' to create a new project\")\n        return None\n\n# Use it\nif __name__ == \"__main__\":\n    config = setup_project()\n    if config:\n        print(\"\\n\u2713 Configuration valid and ready!\")\n</code></pre>"},{"location":"api/config/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide - Detailed configuration reference</li> <li>Quick Reference - Quick configuration examples</li> </ul>"},{"location":"api/generators/","title":"Generators API","text":"<p>Generators convert the intermediate representation (IR) into target language code. Each generator is responsible for producing idiomatic code in its target language.</p>"},{"location":"api/generators/#overview","title":"Overview","text":"<p>The generator architecture allows extending Polyglot FFI to new target languages without modifying the parser or IR. Each generator implements the same interface but produces different output.</p>"},{"location":"api/generators/#ctypes-generator","title":"Ctypes Generator","text":"<p>Generates OCaml ctypes type and function descriptions.</p>"},{"location":"api/generators/#polyglot_ffi.generators.ctypes_gen.CtypesGenerator","title":"<code>polyglot_ffi.generators.ctypes_gen.CtypesGenerator</code>","text":"<p>Generate OCaml ctypes binding code.</p> Source code in <code>src/polyglot_ffi/generators/ctypes_gen.py</code> <pre><code>class CtypesGenerator:\n    \"\"\"Generate OCaml ctypes binding code.\"\"\"\n\n    # Map IR primitive types to Ctypes types\n    TYPE_MAP: Dict[str, str] = {\n        \"string\": \"string\",\n        \"int\": \"int\",\n        \"float\": \"double\",\n        \"bool\": \"bool\",\n        \"unit\": \"void\",\n    }\n\n    def generate_type_description(self, module: IRModule) -&gt; str:\n        \"\"\"\n        Generate type_description.ml.\n\n        Basic boilerplate only (no complex types).\n        \"\"\"\n        return \"\"\"(* Generated by polyglot-ffi *)\n\nmodule Types (F : Ctypes.TYPE) = struct\n  (* Type descriptions go here if needed for complex types *)\n  (* Foundational types: Only primitives, no custom types needed *)\nend\n\"\"\"\n\n    def generate_function_description(self, module: IRModule) -&gt; str:\n        \"\"\"\n        Generate function_description.ml with foreign function declarations.\n        \"\"\"\n        lines = [\n            \"(* Generated by polyglot-ffi *)\",\n            \"open Ctypes\",\n            \"\",\n            \"module Functions (F : Ctypes.FOREIGN) = struct\",\n            \"  open F\",\n        ]\n\n        for func in module.functions:\n            # Generate foreign function declaration\n            lines.append(f\"  let {func.name} =\")\n            lines.append(f'    F.foreign \"ml_{func.name}\"')\n\n            # Build the ctypes signature\n            sig_parts = []\n\n            # Add parameter types\n            for param in func.params:\n                ctype = self._get_ctype(param.type)\n                sig_parts.append(ctype)\n\n            # Add return type\n            return_ctype = self._get_ctype(func.return_type)\n\n            # Construct the signature\n            sig_line = \"      (\"\n            if sig_parts:\n                sig_line += \" @-&gt; \".join(sig_parts) + \" @-&gt; \"\n            sig_line += f\"returning {return_ctype})\"\n\n            lines.append(sig_line)\n            lines.append(\"\")\n\n        lines.append(\"end\")\n\n        return \"\\n\".join(lines)\n\n    def _get_ctype(self, ir_type: IRType) -&gt; str:\n        \"\"\"\n        Convert IR type to Ctypes type string.\n\n        Handles:\n        - Primitives: string, int, float, bool, unit\n        - Options: mapped to OCaml option using ptr (nullable)\n        - Lists: mapped to OCaml list (opaque for C FFI)\n        - Tuples: serialized as composite values\n        - Custom types: referenced by name\n        \"\"\"\n        if ir_type.is_primitive():\n            return self.TYPE_MAP.get(ir_type.name, \"string\")\n\n        # Handle option types\n        # Options in OCaml FFI: For C interop, we typically pass options as pointers\n        # None = NULL, Some x = pointer to x\n        if ir_type.kind == TypeKind.OPTION:\n            if ir_type.params:\n                inner_ctype = self._get_ctype(ir_type.params[0])\n                # For C FFI, options become nullable pointers\n                return f\"ptr {inner_ctype}\"\n            return \"ptr void\"\n\n        # Handle list types\n        # Lists in OCaml FFI: Lists are OCaml values, passed as abstract pointers\n        if ir_type.kind == TypeKind.LIST:\n            # Next features, we'll represent lists as opaque OCaml values\n            # Full marshaling support comes in future versions\n            return \"ptr void\"  # Opaque list pointer\n\n        # Handle tuple types\n        # Tuples in OCaml FFI: Can be passed as structures or individual params\n        if ir_type.kind == TypeKind.TUPLE:\n            # next features, represent tuples as opaque values\n            # Full struct support comes in future versions\n            return \"ptr void\"  # Opaque tuple pointer\n\n        # Handle custom types (records, variants, type aliases)\n        if ir_type.kind in (TypeKind.CUSTOM, TypeKind.RECORD, TypeKind.VARIANT):\n            # Custom types are passed as opaque pointers in C FFI\n            return \"ptr void\"  # Opaque custom type pointer\n\n        raise ValueError(f\"Unsupported type for Ctypes generation: {ir_type}\")\n</code></pre>"},{"location":"api/generators/#polyglot_ffi.generators.ctypes_gen.CtypesGenerator-functions","title":"Functions","text":""},{"location":"api/generators/#polyglot_ffi.generators.ctypes_gen.CtypesGenerator.generate_type_description","title":"<code>generate_type_description(module)</code>","text":"<p>Generate type_description.ml.</p> <p>Basic boilerplate only (no complex types).</p> Source code in <code>src/polyglot_ffi/generators/ctypes_gen.py</code> <pre><code>    def generate_type_description(self, module: IRModule) -&gt; str:\n        \"\"\"\n        Generate type_description.ml.\n\n        Basic boilerplate only (no complex types).\n        \"\"\"\n        return \"\"\"(* Generated by polyglot-ffi *)\n\nmodule Types (F : Ctypes.TYPE) = struct\n  (* Type descriptions go here if needed for complex types *)\n  (* Foundational types: Only primitives, no custom types needed *)\nend\n\"\"\"\n</code></pre>"},{"location":"api/generators/#polyglot_ffi.generators.ctypes_gen.CtypesGenerator.generate_function_description","title":"<code>generate_function_description(module)</code>","text":"<p>Generate function_description.ml with foreign function declarations.</p> Source code in <code>src/polyglot_ffi/generators/ctypes_gen.py</code> <pre><code>def generate_function_description(self, module: IRModule) -&gt; str:\n    \"\"\"\n    Generate function_description.ml with foreign function declarations.\n    \"\"\"\n    lines = [\n        \"(* Generated by polyglot-ffi *)\",\n        \"open Ctypes\",\n        \"\",\n        \"module Functions (F : Ctypes.FOREIGN) = struct\",\n        \"  open F\",\n    ]\n\n    for func in module.functions:\n        # Generate foreign function declaration\n        lines.append(f\"  let {func.name} =\")\n        lines.append(f'    F.foreign \"ml_{func.name}\"')\n\n        # Build the ctypes signature\n        sig_parts = []\n\n        # Add parameter types\n        for param in func.params:\n            ctype = self._get_ctype(param.type)\n            sig_parts.append(ctype)\n\n        # Add return type\n        return_ctype = self._get_ctype(func.return_type)\n\n        # Construct the signature\n        sig_line = \"      (\"\n        if sig_parts:\n            sig_line += \" @-&gt; \".join(sig_parts) + \" @-&gt; \"\n        sig_line += f\"returning {return_ctype})\"\n\n        lines.append(sig_line)\n        lines.append(\"\")\n\n    lines.append(\"end\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/generators/#usage-example","title":"Usage Example","text":"<pre><code>from polyglot_ffi.parsers.ocaml import parse_mli_file\nfrom polyglot_ffi.generators.ctypes_gen import CtypesGenerator\n\n# Parse OCaml interface\nmodule = parse_mli_file(Path(\"crypto.mli\"))\n\n# Generate ctypes bindings\ngenerator = CtypesGenerator()\ntype_desc = generator.generate_type_description(module)\nfunc_desc = generator.generate_function_description(module)\n\n# Write to files\nPath(\"type_description.ml\").write_text(type_desc)\nPath(\"function_description.ml\").write_text(func_desc)\n</code></pre>"},{"location":"api/generators/#generated-output","title":"Generated Output","text":"<p>For <code>val encrypt : string -&gt; string</code>:</p> <pre><code>(* type_description.ml *)\nopen Ctypes\n\nlet string = Ctypes.string\n\n(* function_description.ml *)\nopen Ctypes\n\nlet encrypt = foreign \"ml_encrypt\" (string @-&gt; returning string)\n</code></pre>"},{"location":"api/generators/#c-stubs-generator","title":"C Stubs Generator","text":"<p>Generates memory-safe C wrapper code with proper CAMLparam/CAMLreturn macros.</p>"},{"location":"api/generators/#polyglot_ffi.generators.c_stubs_gen.CStubGenerator","title":"<code>polyglot_ffi.generators.c_stubs_gen.CStubGenerator</code>","text":"<p>Generate C wrapper code for OCaml functions.</p> Source code in <code>src/polyglot_ffi/generators/c_stubs_gen.py</code> <pre><code>class CStubGenerator:\n    \"\"\"Generate C wrapper code for OCaml functions.\"\"\"\n\n    # Map IR types to C types\n    C_TYPE_MAP: Dict[str, str] = {\n        \"string\": \"const char*\",\n        \"int\": \"int\",\n        \"float\": \"double\",\n        \"bool\": \"int\",\n        \"unit\": \"void\",\n    }\n\n    def generate_stubs(self, module: IRModule, module_name: str) -&gt; str:\n        \"\"\"Generate C stub implementation file.\"\"\"\n        safe_name = sanitize_module_name(module_name)\n        lines = [\n            f\"/* Generated by polyglot-ffi */\",\n            f\"/* {safe_name}_stubs.c */\",\n            \"\",\n            \"#include &lt;string.h&gt;\",\n            \"#include &lt;caml/mlvalues.h&gt;\",\n            \"#include &lt;caml/memory.h&gt;\",\n            \"#include &lt;caml/alloc.h&gt;\",\n            \"#include &lt;caml/callback.h&gt;\",\n            \"\",\n        ]\n\n        for func in module.functions:\n            lines.extend(self._generate_function_stub(func))\n            lines.append(\"\")\n\n        return \"\\n\".join(lines)\n\n    def generate_header(self, module: IRModule, module_name: str) -&gt; str:\n        \"\"\"Generate C header file.\"\"\"\n        safe_name = sanitize_module_name(module_name)\n        guard = f\"{safe_name.upper()}_STUBS_H\"\n\n        lines = [\n            f\"/* Generated by polyglot-ffi */\",\n            f\"/* {safe_name}_stubs.h */\",\n            \"\",\n            f\"#ifndef {guard}\",\n            f\"#define {guard}\",\n            \"\",\n        ]\n\n        # Function declarations\n        for func in module.functions:\n            c_return = self._get_c_type(func.return_type)\n            params = \", \".join(f\"{self._get_c_type(p.type)} {p.name}\" for p in func.params)\n            lines.append(f\"{c_return} ml_{func.name}({params});\")\n\n        lines.append(\"\")\n        lines.append(f\"#endif /* {guard} */\")\n\n        return \"\\n\".join(lines)\n\n    def _generate_function_stub(self, func: IRFunction) -&gt; list:\n        \"\"\"Generate C stub for a single function.\"\"\"\n        lines = []\n\n        # Function signature\n        c_return = self._get_c_type(func.return_type)\n        params = \", \".join(f\"{self._get_c_type(p.type)} {p.name}\" for p in func.params)\n\n        lines.append(f\"/* Wrapper for OCaml {func.name} function */\")\n        lines.append(f\"{c_return} ml_{func.name}({params}) {{\")\n        lines.append(\"    CAMLparam0();\")\n\n        # Declare local variables\n        num_locals = len(func.params) + 1\n        local_vars = \", \".join(f\"ml_{p.name}\" for p in func.params) + \", ml_result\"\n        lines.append(f\"    CAMLlocal{num_locals}({local_vars});\")\n        lines.append(\"\")\n\n        # Convert C parameters to OCaml values\n        for param in func.params:\n            lines.extend(self._convert_c_to_ocaml(param.name, param.type))\n\n        # Call OCaml function\n        if len(func.params) == 1:\n            # Single parameter\n            lines.append(\n                f'    ml_result = caml_callback(*caml_named_value(\"{func.name}\"), ml_{func.params[0].name});'\n            )\n        elif len(func.params) &gt; 1:\n            # Multiple parameters\n            param_names = \", \".join(f\"ml_{p.name}\" for p in func.params)\n            lines.append(\n                f'    ml_result = caml_callback{len(func.params)}(*caml_named_value(\"{func.name}\"), {param_names});'\n            )\n        else:\n            # No parameters\n            lines.append(\n                f'    ml_result = caml_callback(*caml_named_value(\"{func.name}\"), Val_unit);'\n            )\n\n        lines.append(\"\")\n\n        # Convert result back to C\n        lines.extend(self._convert_ocaml_to_c(func.return_type))\n\n        lines.append(\"}\")\n\n        return lines\n\n    def _convert_c_to_ocaml(self, param_name: str, param_type: IRType) -&gt; list:\n        \"\"\"\n        Generate code to convert C value to OCaml value.\n\n        Handles primitives and complex types (options, lists, tuples, custom types).\n        Complex types are passed as opaque pointers and cast to OCaml values.\n        \"\"\"\n        lines = []\n\n        if param_type.is_primitive():\n            if param_type.name == \"string\":\n                lines.append(f\"    ml_{param_name} = caml_copy_string({param_name});\")\n            elif param_type.name == \"int\":\n                lines.append(f\"    ml_{param_name} = Val_int({param_name});\")\n            elif param_type.name == \"float\":\n                lines.append(f\"    ml_{param_name} = caml_copy_double({param_name});\")\n            elif param_type.name == \"bool\":\n                lines.append(f\"    ml_{param_name} = Val_bool({param_name});\")\n            elif param_type.name == \"unit\":\n                lines.append(f\"    ml_{param_name} = Val_unit;\")\n        else:\n            # Complex types (options, lists, tuples, custom types)\n            # These are passed as opaque pointers and cast to value\n            lines.append(f\"    ml_{param_name} = (value){param_name};\")\n\n        return lines\n\n    def _convert_ocaml_to_c(self, return_type: IRType) -&gt; list:\n        \"\"\"\n        Generate code to convert OCaml return value to C.\n\n        Handles primitives and complex types. Complex types are returned\n        as opaque pointers to maintain GC-safety.\n        \"\"\"\n        lines = []\n        c_type = self._get_c_type(return_type)\n\n        if return_type.is_primitive():\n            if return_type.name == \"string\":\n                lines.append(f\"    {c_type} result = strdup(String_val(ml_result));\")\n                lines.append(f\"    CAMLreturnT({c_type}, result);\")\n            elif return_type.name == \"int\":\n                lines.append(f\"    {c_type} result = Int_val(ml_result);\")\n                lines.append(f\"    CAMLreturnT({c_type}, result);\")\n            elif return_type.name == \"float\":\n                lines.append(f\"    {c_type} result = Double_val(ml_result);\")\n                lines.append(f\"    CAMLreturnT({c_type}, result);\")\n            elif return_type.name == \"bool\":\n                lines.append(f\"    {c_type} result = Bool_val(ml_result);\")\n                lines.append(f\"    CAMLreturnT({c_type}, result);\")\n            elif return_type.name == \"unit\":\n                lines.append(\"    CAMLreturn0;\")\n        else:\n            # Complex types (options, lists, tuples, custom types)\n            # Return as opaque pointer (cast from value)\n            # Note: This keeps the value alive and GC-safe\n            lines.append(f\"    {c_type} result = (void*)ml_result;\")\n            lines.append(f\"    CAMLreturnT({c_type}, result);\")\n\n        return lines\n\n    def _get_c_type(self, ir_type: IRType) -&gt; str:\n        \"\"\"\n        Convert IR type to C type string.\n\n        Primitives map to C native types.\n        Complex types (options, lists, tuples, custom) map to void* (opaque).\n        \"\"\"\n        if ir_type.is_primitive():\n            return self.C_TYPE_MAP.get(ir_type.name, \"char*\")\n\n        # Complex types are opaque pointers in C\n        if ir_type.kind in (\n            TypeKind.OPTION,\n            TypeKind.LIST,\n            TypeKind.TUPLE,\n            TypeKind.CUSTOM,\n            TypeKind.RECORD,\n            TypeKind.VARIANT,\n        ):\n            return \"void*\"\n\n        raise ValueError(f\"Unsupported type for C generation: {ir_type}\")\n</code></pre>"},{"location":"api/generators/#polyglot_ffi.generators.c_stubs_gen.CStubGenerator-functions","title":"Functions","text":""},{"location":"api/generators/#polyglot_ffi.generators.c_stubs_gen.CStubGenerator.generate_stubs","title":"<code>generate_stubs(module, module_name)</code>","text":"<p>Generate C stub implementation file.</p> Source code in <code>src/polyglot_ffi/generators/c_stubs_gen.py</code> <pre><code>def generate_stubs(self, module: IRModule, module_name: str) -&gt; str:\n    \"\"\"Generate C stub implementation file.\"\"\"\n    safe_name = sanitize_module_name(module_name)\n    lines = [\n        f\"/* Generated by polyglot-ffi */\",\n        f\"/* {safe_name}_stubs.c */\",\n        \"\",\n        \"#include &lt;string.h&gt;\",\n        \"#include &lt;caml/mlvalues.h&gt;\",\n        \"#include &lt;caml/memory.h&gt;\",\n        \"#include &lt;caml/alloc.h&gt;\",\n        \"#include &lt;caml/callback.h&gt;\",\n        \"\",\n    ]\n\n    for func in module.functions:\n        lines.extend(self._generate_function_stub(func))\n        lines.append(\"\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/generators/#polyglot_ffi.generators.c_stubs_gen.CStubGenerator.generate_header","title":"<code>generate_header(module, module_name)</code>","text":"<p>Generate C header file.</p> Source code in <code>src/polyglot_ffi/generators/c_stubs_gen.py</code> <pre><code>def generate_header(self, module: IRModule, module_name: str) -&gt; str:\n    \"\"\"Generate C header file.\"\"\"\n    safe_name = sanitize_module_name(module_name)\n    guard = f\"{safe_name.upper()}_STUBS_H\"\n\n    lines = [\n        f\"/* Generated by polyglot-ffi */\",\n        f\"/* {safe_name}_stubs.h */\",\n        \"\",\n        f\"#ifndef {guard}\",\n        f\"#define {guard}\",\n        \"\",\n    ]\n\n    # Function declarations\n    for func in module.functions:\n        c_return = self._get_c_type(func.return_type)\n        params = \", \".join(f\"{self._get_c_type(p.type)} {p.name}\" for p in func.params)\n        lines.append(f\"{c_return} ml_{func.name}({params});\")\n\n    lines.append(\"\")\n    lines.append(f\"#endif /* {guard} */\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/generators/#usage-example_1","title":"Usage Example","text":"<pre><code>from polyglot_ffi.generators.c_stubs_gen import CStubGenerator\n\ngenerator = CStubGenerator()\nstubs = generator.generate_stubs(module, \"crypto\")\nheader = generator.generate_header(module, \"crypto\")\n\nPath(\"stubs.c\").write_text(stubs)\nPath(\"stubs.h\").write_text(header)\n</code></pre>"},{"location":"api/generators/#generated-output_1","title":"Generated Output","text":"<p>For <code>val encrypt : string -&gt; string</code>:</p> <pre><code>/* stubs.c */\n#include &lt;caml/mlvalues.h&gt;\n#include &lt;caml/memory.h&gt;\n#include &lt;caml/alloc.h&gt;\n#include \"stubs.h\"\n\nCAMLprim value ml_encrypt(value input) {\n    CAMLparam1(input);\n    CAMLlocal1(result);\n\n    char* c_input = String_val(input);\n    char* c_result = encrypt(c_input);\n    result = caml_copy_string(c_result);\n\n    CAMLreturn(result);\n}\n</code></pre> <pre><code>/* stubs.h */\n#ifndef CRYPTO_STUBS_H\n#define CRYPTO_STUBS_H\n\n#include &lt;caml/mlvalues.h&gt;\n\nCAMLprim value ml_encrypt(value input);\n\n#endif\n</code></pre>"},{"location":"api/generators/#python-generator","title":"Python Generator","text":"<p>Generates type-safe Python wrapper modules with type hints.</p>"},{"location":"api/generators/#polyglot_ffi.generators.python_gen.PythonGenerator","title":"<code>polyglot_ffi.generators.python_gen.PythonGenerator</code>","text":"<p>Generate Python wrapper code.</p> Source code in <code>src/polyglot_ffi/generators/python_gen.py</code> <pre><code>class PythonGenerator:\n    \"\"\"Generate Python wrapper code.\"\"\"\n\n    # Map IR types to Python type hints\n    PY_TYPE_MAP: Dict[str, str] = {\n        \"string\": \"str\",\n        \"int\": \"int\",\n        \"float\": \"float\",\n        \"bool\": \"bool\",\n        \"unit\": \"None\",\n    }\n\n    # Map IR types to ctypes\n    CTYPES_MAP: Dict[str, str] = {\n        \"string\": \"ctypes.c_char_p\",\n        \"int\": \"ctypes.c_int\",\n        \"float\": \"ctypes.c_double\",\n        \"bool\": \"ctypes.c_bool\",\n        \"unit\": \"None\",\n    }\n\n    @staticmethod\n    def _sanitize_identifier(name: str) -&gt; str:\n        \"\"\"Sanitize a name to be a valid Python identifier.\"\"\"\n        # Replace hyphens and other non-identifier chars with underscores\n        sanitized = name.replace(\"-\", \"_\").replace(\".\", \"_\")\n        # Ensure it starts with a letter or underscore\n        if sanitized and not (sanitized[0].isalpha() or sanitized[0] == \"_\"):\n            sanitized = \"_\" + sanitized\n        return sanitized\n\n    def generate(self, module: IRModule, module_name: str) -&gt; str:\n        \"\"\"Generate Python wrapper module.\"\"\"\n        # Sanitize module name for Python identifiers and filenames\n        safe_name = sanitize_module_name(module_name)\n        error_class = safe_name.capitalize() + \"Error\"\n\n        lines = [\n            \"# Generated by polyglot-ffi\",\n            f\"# {safe_name}_py.py\",\n            \"\",\n            \"import ctypes\",\n            \"from pathlib import Path\",\n            \"from typing import Optional, List, Tuple, Any\",\n            \"\",\n            \"# Load the shared library\",\n            f'_lib_path = Path(__file__).parent / \"lib{safe_name}.so\"',\n            \"_lib = ctypes.CDLL(str(_lib_path))\",\n            \"\",\n            f\"class {error_class}(Exception):\",\n            f'    \"\"\"Raised when {module_name} operations fail\"\"\"',\n            \"    pass\",\n            \"\",\n        ]\n\n        # Configure ctypes for each function\n        for func in module.functions:\n            lines.append(f\"# Configure {func.name}\")\n\n            # Set argtypes\n            if func.params:\n                argtypes = [self._get_ctypes(p.type) for p in func.params]\n                lines.append(f\"_lib.ml_{func.name}.argtypes = [{', '.join(argtypes)}]\")\n\n            # Set restype\n            restype = self._get_ctypes(func.return_type)\n            lines.append(f\"_lib.ml_{func.name}.restype = {restype}\")\n            lines.append(\"\")\n\n        # Generate wrapper functions\n        for func in module.functions:\n            lines.extend(self._generate_function_wrapper(func, module_name, error_class))\n            lines.append(\"\")\n\n        return \"\\n\".join(lines)\n\n    def _generate_function_wrapper(\n        self, func: IRFunction, module_name: str, error_class: str\n    ) -&gt; list:\n        \"\"\"Generate Python wrapper for a single function.\"\"\"\n        lines = []\n\n        # Function signature\n        params = [f\"{p.name}: {self._get_py_type(p.type)}\" for p in func.params]\n        params_str = \", \".join(params) if params else \"\"\n        return_type = self._get_py_type(func.return_type)\n\n        lines.append(f\"def {func.name}({params_str}) -&gt; {return_type}:\")\n\n        # Docstring\n        if func.doc:\n            lines.append(f'    \"\"\"{func.doc}\"\"\"')\n        else:\n            lines.append(f'    \"\"\"Call OCaml {func.name} function\"\"\"')\n\n        lines.append(\"    try:\")\n\n        # Convert arguments\n        call_args = []\n        for param in func.params:\n            if param.type.name == \"string\":\n                call_args.append(f\"{param.name}.encode('utf-8')\")\n            else:\n                call_args.append(param.name)\n\n        # Make the call\n        call_str = \", \".join(call_args) if call_args else \"\"\n        lines.append(f\"        result = _lib.ml_{func.name}({call_str})\")\n\n        # Handle return value\n        if func.return_type.name == \"string\":\n            lines.append(\"        if result is None:\")\n            lines.append(f'            raise {error_class}(\"{func.name} returned NULL\")')\n            lines.append(\"        return result.decode('utf-8')\")\n        elif func.return_type.name == \"unit\":\n            lines.append(\"        return None\")\n        else:\n            lines.append(\"        return result\")\n\n        # Error handling\n        lines.append(\"    except Exception as e:\")\n        lines.append(f'        raise {error_class}(f\"{func.name} failed: {{e}}\")')\n\n        return lines\n\n    def _get_py_type(self, ir_type: IRType) -&gt; str:\n        \"\"\"\n        Convert IR type to Python type hint.\n\n        Handles:\n        - Primitives: str, int, float, bool, None\n        - Options: Optional[T]\n        - Lists: List[T]\n        - Tuples: Tuple[T1, T2, ...]\n        - Custom types: Class names\n        \"\"\"\n        if ir_type.is_primitive():\n            return self.PY_TYPE_MAP.get(ir_type.name, \"str\")\n\n        # Handle option types\n        if ir_type.kind == TypeKind.OPTION:\n            if ir_type.params:\n                inner_type = self._get_py_type(ir_type.params[0])\n                return f\"Optional[{inner_type}]\"\n            return \"Optional[Any]\"\n\n        # Handle list types\n        if ir_type.kind == TypeKind.LIST:\n            if ir_type.params:\n                inner_type = self._get_py_type(ir_type.params[0])\n                return f\"List[{inner_type}]\"\n            return \"List[Any]\"\n\n        # Handle tuple types\n        if ir_type.kind == TypeKind.TUPLE:\n            if ir_type.params:\n                tuple_types = [self._get_py_type(p) for p in ir_type.params]\n                return f\"Tuple[{', '.join(tuple_types)}]\"\n            return \"Tuple[Any, ...]\"\n\n        # Handle custom types (records, variants)\n        if ir_type.kind in (TypeKind.CUSTOM, TypeKind.RECORD, TypeKind.VARIANT):\n            # Use the type name as a class name (with capitalization)\n            return ir_type.name.capitalize()\n\n        raise ValueError(f\"Unsupported type for Python generation: {ir_type}\")\n\n    def _get_ctypes(self, ir_type: IRType) -&gt; str:\n        \"\"\"\n        Convert IR type to ctypes type.\n\n        For complex types (options, lists, tuples, custom types),\n        we use c_void_p as they're opaque pointers from C's perspective.\n        \"\"\"\n        if ir_type.is_primitive():\n            return self.CTYPES_MAP.get(ir_type.name, \"ctypes.c_char_p\")\n\n        # Complex types are passed as opaque pointers (v0.2.0+)\n        if ir_type.kind in (\n            TypeKind.OPTION,\n            TypeKind.LIST,\n            TypeKind.TUPLE,\n            TypeKind.CUSTOM,\n            TypeKind.RECORD,\n            TypeKind.VARIANT,\n        ):\n            return \"ctypes.c_void_p\"\n\n        raise ValueError(f\"Unsupported type for ctypes: {ir_type}\")\n</code></pre>"},{"location":"api/generators/#polyglot_ffi.generators.python_gen.PythonGenerator-functions","title":"Functions","text":""},{"location":"api/generators/#polyglot_ffi.generators.python_gen.PythonGenerator.generate","title":"<code>generate(module, module_name)</code>","text":"<p>Generate Python wrapper module.</p> Source code in <code>src/polyglot_ffi/generators/python_gen.py</code> <pre><code>def generate(self, module: IRModule, module_name: str) -&gt; str:\n    \"\"\"Generate Python wrapper module.\"\"\"\n    # Sanitize module name for Python identifiers and filenames\n    safe_name = sanitize_module_name(module_name)\n    error_class = safe_name.capitalize() + \"Error\"\n\n    lines = [\n        \"# Generated by polyglot-ffi\",\n        f\"# {safe_name}_py.py\",\n        \"\",\n        \"import ctypes\",\n        \"from pathlib import Path\",\n        \"from typing import Optional, List, Tuple, Any\",\n        \"\",\n        \"# Load the shared library\",\n        f'_lib_path = Path(__file__).parent / \"lib{safe_name}.so\"',\n        \"_lib = ctypes.CDLL(str(_lib_path))\",\n        \"\",\n        f\"class {error_class}(Exception):\",\n        f'    \"\"\"Raised when {module_name} operations fail\"\"\"',\n        \"    pass\",\n        \"\",\n    ]\n\n    # Configure ctypes for each function\n    for func in module.functions:\n        lines.append(f\"# Configure {func.name}\")\n\n        # Set argtypes\n        if func.params:\n            argtypes = [self._get_ctypes(p.type) for p in func.params]\n            lines.append(f\"_lib.ml_{func.name}.argtypes = [{', '.join(argtypes)}]\")\n\n        # Set restype\n        restype = self._get_ctypes(func.return_type)\n        lines.append(f\"_lib.ml_{func.name}.restype = {restype}\")\n        lines.append(\"\")\n\n    # Generate wrapper functions\n    for func in module.functions:\n        lines.extend(self._generate_function_wrapper(func, module_name, error_class))\n        lines.append(\"\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/generators/#usage-example_2","title":"Usage Example","text":"<pre><code>from polyglot_ffi.generators.python_gen import PythonGenerator\n\ngenerator = PythonGenerator()\nwrapper = generator.generate(module, \"crypto\")\n\nPath(\"crypto_py.py\").write_text(wrapper)\n</code></pre>"},{"location":"api/generators/#generated-output_2","title":"Generated Output","text":"<p>For <code>val encrypt : string -&gt; string</code>:</p> <pre><code>\"\"\"\nAuto-generated Python bindings for crypto.\nGenerated by Polyglot FFI.\n\"\"\"\n\nimport ctypes\nfrom pathlib import Path\nfrom typing import Optional\n\n# Load shared library\n_lib_path = Path(__file__).parent / \"libcrypto.so\"\n_lib = ctypes.CDLL(str(_lib_path))\n\n# Configure function signatures\n_lib.ml_encrypt.argtypes = [ctypes.c_char_p]\n_lib.ml_encrypt.restype = ctypes.c_char_p\n\ndef encrypt(input: str) -&gt; str:\n    \"\"\"Encrypt a string.\"\"\"\n    result = _lib.ml_encrypt(input.encode('utf-8'))\n    if result is None:\n        raise RuntimeError(\"encrypt returned NULL\")\n    return result.decode('utf-8')\n</code></pre>"},{"location":"api/generators/#dune-generator","title":"Dune Generator","text":"<p>Generates Dune build system configuration.</p>"},{"location":"api/generators/#polyglot_ffi.generators.dune_gen.DuneGenerator","title":"<code>polyglot_ffi.generators.dune_gen.DuneGenerator</code>","text":"<p>Generate Dune build configuration files.</p> Source code in <code>src/polyglot_ffi/generators/dune_gen.py</code> <pre><code>class DuneGenerator:\n    \"\"\"Generate Dune build configuration files.\"\"\"\n\n    def generate_dune(self, module_name: str) -&gt; str:\n        \"\"\"Generate dune file for the bindings library.\"\"\"\n        safe_name = sanitize_module_name(module_name)\n        return f\"\"\"; Generated by polyglot-ffi\n(library\n (name {safe_name}_bindings)\n (public_name {safe_name}_bindings)\n (libraries ctypes ctypes.foreign)\n (ctypes\n  (external_library_name {safe_name})\n  (build_flags_resolver\n   (vendored (c_flags :standard) (c_library_flags :standard)))\n  (headers (preamble \"#include \\\\\"{safe_name}_stubs.h\\\\\"\"))\n  (type_description\n   (instance Type)\n   (functor Type_description))\n  (function_description\n   (concurrency sequential)\n   (instance Function)\n   (functor Function_description))\n  (generated_types Types_generated)\n  (generated_entry_point C)))\n\"\"\"\n\n    def generate_dune_project(self, module_name: str) -&gt; str:\n        \"\"\"Generate dune-project file.\"\"\"\n        safe_name = sanitize_module_name(module_name)\n        return f\"\"\"(lang dune 3.16)\n(using ctypes 0.3)\n\n; Generated by polyglot-ffi\n\n(name {safe_name}_bindings)\n\n(generate_opam_files true)\n\n(package\n (name {safe_name}_bindings)\n (synopsis \"OCaml-Python bindings for {module_name}\")\n (description \"Auto-generated FFI bindings by polyglot-ffi\")\n (depends\n  (ocaml (&gt;= 4.14))\n  (dune (&gt;= 3.16))\n  (ctypes (&gt;= 0.20.0))\n  (ctypes-foreign (&gt;= 0.20.0))))\n\"\"\"\n</code></pre>"},{"location":"api/generators/#polyglot_ffi.generators.dune_gen.DuneGenerator-functions","title":"Functions","text":""},{"location":"api/generators/#polyglot_ffi.generators.dune_gen.DuneGenerator.generate_dune","title":"<code>generate_dune(module_name)</code>","text":"<p>Generate dune file for the bindings library.</p> Source code in <code>src/polyglot_ffi/generators/dune_gen.py</code> <pre><code>    def generate_dune(self, module_name: str) -&gt; str:\n        \"\"\"Generate dune file for the bindings library.\"\"\"\n        safe_name = sanitize_module_name(module_name)\n        return f\"\"\"; Generated by polyglot-ffi\n(library\n (name {safe_name}_bindings)\n (public_name {safe_name}_bindings)\n (libraries ctypes ctypes.foreign)\n (ctypes\n  (external_library_name {safe_name})\n  (build_flags_resolver\n   (vendored (c_flags :standard) (c_library_flags :standard)))\n  (headers (preamble \"#include \\\\\"{safe_name}_stubs.h\\\\\"\"))\n  (type_description\n   (instance Type)\n   (functor Type_description))\n  (function_description\n   (concurrency sequential)\n   (instance Function)\n   (functor Function_description))\n  (generated_types Types_generated)\n  (generated_entry_point C)))\n\"\"\"\n</code></pre>"},{"location":"api/generators/#polyglot_ffi.generators.dune_gen.DuneGenerator.generate_dune_project","title":"<code>generate_dune_project(module_name)</code>","text":"<p>Generate dune-project file.</p> Source code in <code>src/polyglot_ffi/generators/dune_gen.py</code> <pre><code>    def generate_dune_project(self, module_name: str) -&gt; str:\n        \"\"\"Generate dune-project file.\"\"\"\n        safe_name = sanitize_module_name(module_name)\n        return f\"\"\"(lang dune 3.16)\n(using ctypes 0.3)\n\n; Generated by polyglot-ffi\n\n(name {safe_name}_bindings)\n\n(generate_opam_files true)\n\n(package\n (name {safe_name}_bindings)\n (synopsis \"OCaml-Python bindings for {module_name}\")\n (description \"Auto-generated FFI bindings by polyglot-ffi\")\n (depends\n  (ocaml (&gt;= 4.14))\n  (dune (&gt;= 3.16))\n  (ctypes (&gt;= 0.20.0))\n  (ctypes-foreign (&gt;= 0.20.0))))\n\"\"\"\n</code></pre>"},{"location":"api/generators/#usage-example_3","title":"Usage Example","text":"<pre><code>from polyglot_ffi.generators.dune_gen import DuneGenerator\n\ngenerator = DuneGenerator()\ndune = generator.generate_dune(\"crypto\")\ndune_project = generator.generate_dune_project(\"crypto\")\n\nPath(\"dune\").write_text(dune)\nPath(\"dune-project\").write_text(dune_project)\n</code></pre>"},{"location":"api/generators/#generated-output_3","title":"Generated Output","text":"<pre><code>; dune\n(library\n (name crypto)\n (libraries ctypes ctypes.foreign)\n (foreign_stubs\n  (language c)\n  (names stubs)))\n\n; dune-project\n(lang dune 3.0)\n(name crypto)\n</code></pre>"},{"location":"api/generators/#complete-generation-workflow","title":"Complete Generation Workflow","text":"<pre><code>from pathlib import Path\nfrom polyglot_ffi.parsers.ocaml import parse_mli_file\nfrom polyglot_ffi.generators.ctypes_gen import CtypesGenerator\nfrom polyglot_ffi.generators.c_stubs_gen import CStubGenerator\nfrom polyglot_ffi.generators.python_gen import PythonGenerator\nfrom polyglot_ffi.generators.dune_gen import DuneGenerator\n\n# Parse\nmodule = parse_mli_file(Path(\"crypto.mli\"))\n\n# Generate all artifacts\noutput_dir = Path(\"generated\")\noutput_dir.mkdir(exist_ok=True)\n\n# OCaml ctypes\nctypes_gen = CtypesGenerator()\n(output_dir / \"type_description.ml\").write_text(\n    ctypes_gen.generate_type_description(module)\n)\n(output_dir / \"function_description.ml\").write_text(\n    ctypes_gen.generate_function_description(module)\n)\n\n# C stubs\nc_gen = CStubGenerator()\n(output_dir / \"stubs.c\").write_text(\n    c_gen.generate_stubs(module, \"crypto\")\n)\n(output_dir / \"stubs.h\").write_text(\n    c_gen.generate_header(module, \"crypto\")\n)\n\n# Python wrapper\npy_gen = PythonGenerator()\n(output_dir / \"crypto_py.py\").write_text(\n    py_gen.generate(module, \"crypto\")\n)\n\n# Build system\ndune_gen = DuneGenerator()\n(output_dir / \"dune\").write_text(\n    dune_gen.generate_dune(\"crypto\")\n)\n(output_dir / \"dune-project\").write_text(\n    dune_gen.generate_dune_project(\"crypto\")\n)\n\nprint(f\"Generated {len(module.functions)} function bindings\")\n</code></pre>"},{"location":"api/generators/#type-mapping","title":"Type Mapping","text":"<p>All generators use the type registry for consistent type mappings:</p> <pre><code>from polyglot_ffi.type_system.registry import get_default_registry\nfrom polyglot_ffi.ir.types import STRING, INT, ir_option\n\nregistry = get_default_registry()\n\n# Primitive types\nregistry.get_mapping(STRING, \"python\")  # \"str\"\nregistry.get_mapping(INT, \"python\")     # \"int\"\n\n# Complex types\nopt_string = ir_option(STRING)\nregistry.get_mapping(opt_string, \"python\")  # \"Optional[str]\"\n</code></pre>"},{"location":"api/generators/#adding-custom-generators","title":"Adding Custom Generators","text":"<p>To add support for a new target language:</p> <pre><code>from polyglot_ffi.ir.types import IRModule\n\nclass RustGenerator:\n    \"\"\"Generate Rust FFI bindings.\"\"\"\n\n    def generate(self, module: IRModule, module_name: str) -&gt; str:\n        \"\"\"Generate Rust code from IR.\"\"\"\n        lines = [\n            f\"// Auto-generated Rust bindings for {module_name}\",\n            \"\",\n            \"use std::ffi::CString;\",\n            \"use std::os::raw::c_char;\",\n            \"\",\n        ]\n\n        for func in module.functions:\n            # Generate extern declaration\n            lines.append(f\"extern \\\"C\\\" {{\")\n            lines.append(f\"    fn ml_{func.name}(...) -&gt; ...;\")\n            lines.append(\"}\")\n\n            # Generate safe wrapper\n            lines.append(f\"pub fn {func.name}(...) -&gt; ... {{\")\n            lines.append(f\"    unsafe {{ ml_{func.name}(...) }}\")\n            lines.append(\"}\")\n            lines.append(\"\")\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/generators/#performance","title":"Performance","text":"<p>Generators are highly optimized:</p> <ul> <li>Ctypes: ~0.0001ms per generation (extremely fast)</li> <li>C Stubs: ~0.009ms per generation</li> <li>Python: ~0.008ms per generation</li> <li>Complete workflow: ~0.07ms for 6 functions</li> </ul> <p>All generators can be run in parallel for additional speedup.</p>"},{"location":"api/generators/#see-also","title":"See Also","text":"<ul> <li>Parser API - Parsing OCaml files</li> <li>IR Types - Intermediate representation</li> <li>Type System - Type mappings</li> </ul>"},{"location":"api/ir-types/","title":"IR Types API","text":"<p>The IR (Intermediate Representation) types provide a language-agnostic representation of functions and types. This abstraction allows parsers and generators to work independently.</p>"},{"location":"api/ir-types/#overview","title":"Overview","text":"<p>The IR layer is the heart of Polyglot FFI's extensibility:</p> <ul> <li>Parsers convert source language \u2192 IR</li> <li>Generators convert IR \u2192 target language</li> <li>Adding new languages only requires implementing one side</li> </ul>"},{"location":"api/ir-types/#core-types","title":"Core Types","text":""},{"location":"api/ir-types/#irtype","title":"IRType","text":"<p>Represents a type in the intermediate representation.</p>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRType","title":"<code>polyglot_ffi.ir.types.IRType</code>  <code>dataclass</code>","text":"<p>Language-agnostic type representation.</p> <p>Examples:</p> <ul> <li>Primitive: IRType(kind=PRIMITIVE, name=\"string\")</li> <li>Option: IRType(kind=OPTION, name=\"option\", params=[IRType(...)])</li> <li>List: IRType(kind=LIST, name=\"list\", params=[IRType(...)])</li> <li>Record: IRType(kind=RECORD, name=\"user\", fields={\"name\": IRType(...), ...})</li> </ul> Source code in <code>src/polyglot_ffi/ir/types.py</code> <pre><code>@dataclass\nclass IRType:\n    \"\"\"\n    Language-agnostic type representation.\n\n    Examples:\n        - Primitive: IRType(kind=PRIMITIVE, name=\"string\")\n        - Option: IRType(kind=OPTION, name=\"option\", params=[IRType(...)])\n        - List: IRType(kind=LIST, name=\"list\", params=[IRType(...)])\n        - Record: IRType(kind=RECORD, name=\"user\", fields={\"name\": IRType(...), ...})\n    \"\"\"\n\n    kind: TypeKind\n    name: str\n    params: List[\"IRType\"] = field(default_factory=list)\n    fields: Dict[str, \"IRType\"] = field(default_factory=dict)\n    variants: Dict[str, Optional[\"IRType\"]] = field(default_factory=dict)\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation for debugging.\"\"\"\n        if self.kind == TypeKind.PRIMITIVE:\n            return self.name\n        elif self.kind == TypeKind.OPTION:\n            return f\"{self.params[0]} option\"\n        elif self.kind == TypeKind.LIST:\n            return f\"{self.params[0]} list\"\n        elif self.kind == TypeKind.TUPLE:\n            types = \" * \".join(str(p) for p in self.params)\n            return f\"({types})\"\n        elif self.kind == TypeKind.RECORD:\n            return f\"record {self.name}\"\n        elif self.kind == TypeKind.VARIANT:\n            return f\"variant {self.name}\"\n        return self.name\n\n    def is_primitive(self) -&gt; bool:\n        \"\"\"Check if this is a primitive type.\"\"\"\n        return self.kind == TypeKind.PRIMITIVE\n\n    def is_container(self) -&gt; bool:\n        \"\"\"Check if this is a container type (option, list, etc.).\"\"\"\n        return self.kind in (TypeKind.OPTION, TypeKind.LIST, TypeKind.TUPLE)\n\n    def is_composite(self) -&gt; bool:\n        \"\"\"Check if this is a composite type (record, variant).\"\"\"\n        return self.kind in (TypeKind.RECORD, TypeKind.VARIANT)\n</code></pre>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRType-functions","title":"Functions","text":""},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRType.__str__","title":"<code>__str__()</code>","text":"<p>String representation for debugging.</p> Source code in <code>src/polyglot_ffi/ir/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation for debugging.\"\"\"\n    if self.kind == TypeKind.PRIMITIVE:\n        return self.name\n    elif self.kind == TypeKind.OPTION:\n        return f\"{self.params[0]} option\"\n    elif self.kind == TypeKind.LIST:\n        return f\"{self.params[0]} list\"\n    elif self.kind == TypeKind.TUPLE:\n        types = \" * \".join(str(p) for p in self.params)\n        return f\"({types})\"\n    elif self.kind == TypeKind.RECORD:\n        return f\"record {self.name}\"\n    elif self.kind == TypeKind.VARIANT:\n        return f\"variant {self.name}\"\n    return self.name\n</code></pre>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRType.is_composite","title":"<code>is_composite()</code>","text":"<p>Check if this is a composite type (record, variant).</p> Source code in <code>src/polyglot_ffi/ir/types.py</code> <pre><code>def is_composite(self) -&gt; bool:\n    \"\"\"Check if this is a composite type (record, variant).\"\"\"\n    return self.kind in (TypeKind.RECORD, TypeKind.VARIANT)\n</code></pre>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRType.is_container","title":"<code>is_container()</code>","text":"<p>Check if this is a container type (option, list, etc.).</p> Source code in <code>src/polyglot_ffi/ir/types.py</code> <pre><code>def is_container(self) -&gt; bool:\n    \"\"\"Check if this is a container type (option, list, etc.).\"\"\"\n    return self.kind in (TypeKind.OPTION, TypeKind.LIST, TypeKind.TUPLE)\n</code></pre>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRType.is_primitive","title":"<code>is_primitive()</code>","text":"<p>Check if this is a primitive type.</p> Source code in <code>src/polyglot_ffi/ir/types.py</code> <pre><code>def is_primitive(self) -&gt; bool:\n    \"\"\"Check if this is a primitive type.\"\"\"\n    return self.kind == TypeKind.PRIMITIVE\n</code></pre>"},{"location":"api/ir-types/#typekind","title":"TypeKind","text":"<p>Enumeration of all supported type kinds.</p>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.TypeKind","title":"<code>polyglot_ffi.ir.types.TypeKind</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Categories of types in the IR.</p>"},{"location":"api/ir-types/#irparameter","title":"IRParameter","text":"<p>Represents a function parameter.</p>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRParameter","title":"<code>polyglot_ffi.ir.types.IRParameter</code>  <code>dataclass</code>","text":"<p>Function parameter representation.</p> Source code in <code>src/polyglot_ffi/ir/types.py</code> <pre><code>@dataclass\nclass IRParameter:\n    \"\"\"Function parameter representation.\"\"\"\n\n    name: str\n    type: IRType\n\n    def __str__(self) -&gt; str:\n        return f\"{self.name}: {self.type}\"\n</code></pre>"},{"location":"api/ir-types/#irfunction","title":"IRFunction","text":"<p>Represents a function signature.</p>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRFunction","title":"<code>polyglot_ffi.ir.types.IRFunction</code>  <code>dataclass</code>","text":"<p>Language-agnostic function representation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Function name</p> <code>params</code> <code>List[IRParameter]</code> <p>List of parameters</p> <code>return_type</code> <code>IRType</code> <p>Return type</p> <code>doc</code> <code>str</code> <p>Documentation string</p> <code>is_async</code> <code>bool</code> <p>Whether function is async/concurrent</p> Source code in <code>src/polyglot_ffi/ir/types.py</code> <pre><code>@dataclass\nclass IRFunction:\n    \"\"\"\n    Language-agnostic function representation.\n\n    Attributes:\n        name: Function name\n        params: List of parameters\n        return_type: Return type\n        doc: Documentation string\n        is_async: Whether function is async/concurrent\n    \"\"\"\n\n    name: str\n    params: List[IRParameter]\n    return_type: IRType\n    doc: str = \"\"\n    is_async: bool = False\n\n    def __str__(self) -&gt; str:\n        params_str = \", \".join(str(p) for p in self.params)\n        return f\"{self.name}({params_str}) -&gt; {self.return_type}\"\n\n    @property\n    def arity(self) -&gt; int:\n        \"\"\"Number of parameters.\"\"\"\n        return len(self.params)\n</code></pre>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRFunction-attributes","title":"Attributes","text":""},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRFunction.arity","title":"<code>arity</code>  <code>property</code>","text":"<p>Number of parameters.</p>"},{"location":"api/ir-types/#irmodule","title":"IRModule","text":"<p>Represents a complete module with functions and types.</p>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRModule","title":"<code>polyglot_ffi.ir.types.IRModule</code>  <code>dataclass</code>","text":"<p>Top-level module representation.</p> <p>Contains all functions and type definitions from a source file.</p> Source code in <code>src/polyglot_ffi/ir/types.py</code> <pre><code>@dataclass\nclass IRModule:\n    \"\"\"\n    Top-level module representation.\n\n    Contains all functions and type definitions from a source file.\n    \"\"\"\n\n    name: str\n    functions: List[IRFunction] = field(default_factory=list)\n    type_definitions: List[IRTypeDefinition] = field(default_factory=list)\n    doc: str = \"\"\n\n    def __str__(self) -&gt; str:\n        return f\"Module {self.name} ({len(self.functions)} functions, {len(self.type_definitions)} types)\"\n\n    def get_function(self, name: str) -&gt; Optional[IRFunction]:\n        \"\"\"Get function by name.\"\"\"\n        for func in self.functions:\n            if func.name == name:\n                return func\n        return None\n\n    def get_type(self, name: str) -&gt; Optional[IRTypeDefinition]:\n        \"\"\"Get type definition by name.\"\"\"\n        for typedef in self.type_definitions:\n            if typedef.name == name:\n                return typedef\n        return None\n</code></pre>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRModule-functions","title":"Functions","text":""},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRModule.get_function","title":"<code>get_function(name)</code>","text":"<p>Get function by name.</p> Source code in <code>src/polyglot_ffi/ir/types.py</code> <pre><code>def get_function(self, name: str) -&gt; Optional[IRFunction]:\n    \"\"\"Get function by name.\"\"\"\n    for func in self.functions:\n        if func.name == name:\n            return func\n    return None\n</code></pre>"},{"location":"api/ir-types/#polyglot_ffi.ir.types.IRModule.get_type","title":"<code>get_type(name)</code>","text":"<p>Get type definition by name.</p> Source code in <code>src/polyglot_ffi/ir/types.py</code> <pre><code>def get_type(self, name: str) -&gt; Optional[IRTypeDefinition]:\n    \"\"\"Get type definition by name.\"\"\"\n    for typedef in self.type_definitions:\n        if typedef.name == name:\n            return typedef\n    return None\n</code></pre>"},{"location":"api/ir-types/#type-construction","title":"Type Construction","text":""},{"location":"api/ir-types/#primitive-types","title":"Primitive Types","text":"<p>Pre-defined primitive type constants:</p> <pre><code>from polyglot_ffi.ir.types import STRING, INT, FLOAT, BOOL, UNIT\n\n# Use directly\nstring_type = STRING  # IRType(kind=TypeKind.PRIMITIVE, name=\"string\")\nint_type = INT        # IRType(kind=TypeKind.PRIMITIVE, name=\"int\")\n</code></pre>"},{"location":"api/ir-types/#custom-primitive","title":"Custom Primitive","text":"<pre><code>from polyglot_ffi.ir.types import ir_primitive\n\ncustom_type = ir_primitive(\"bytes\")\n# IRType(kind=TypeKind.PRIMITIVE, name=\"bytes\")\n</code></pre>"},{"location":"api/ir-types/#option-types","title":"Option Types","text":"<pre><code>from polyglot_ffi.ir.types import ir_option, STRING\n\nopt_string = ir_option(STRING)\n# IRType(kind=TypeKind.OPTION, name=\"option\", params=[STRING])\n\n# Nested options\nopt_opt_int = ir_option(ir_option(INT))\n</code></pre>"},{"location":"api/ir-types/#list-types","title":"List Types","text":"<pre><code>from polyglot_ffi.ir.types import ir_list, STRING\n\nstring_list = ir_list(STRING)\n# IRType(kind=TypeKind.LIST, name=\"list\", params=[STRING])\n\n# List of options\nlist_of_opts = ir_list(ir_option(STRING))\n</code></pre>"},{"location":"api/ir-types/#tuple-types","title":"Tuple Types","text":"<pre><code>from polyglot_ffi.ir.types import ir_tuple, STRING, INT\n\npair = ir_tuple(STRING, INT)\n# IRType(kind=TypeKind.TUPLE, name=\"tuple\", params=[STRING, INT])\n\n# Triple\ntriple = ir_tuple(STRING, INT, BOOL)\n</code></pre>"},{"location":"api/ir-types/#record-types","title":"Record Types","text":"<pre><code>from polyglot_ffi.ir.types import IRType, TypeKind\n\nperson_record = IRType(\n    kind=TypeKind.RECORD,\n    name=\"person\",\n    fields={\n        \"name\": STRING,\n        \"age\": INT,\n        \"email\": ir_option(STRING)\n    }\n)\n</code></pre>"},{"location":"api/ir-types/#variant-types","title":"Variant Types","text":"<pre><code>result_variant = IRType(\n    kind=TypeKind.VARIANT,\n    name=\"result\",\n    fields={\n        \"Ok\": STRING,      # Success case with string payload\n        \"Error\": STRING    # Error case with string payload\n    }\n)\n</code></pre>"},{"location":"api/ir-types/#function-construction","title":"Function Construction","text":""},{"location":"api/ir-types/#simple-function","title":"Simple Function","text":"<pre><code>from polyglot_ffi.ir.types import IRFunction, IRParameter, STRING\n\nencrypt_func = IRFunction(\n    name=\"encrypt\",\n    parameters=[\n        IRParameter(name=\"input\", type=STRING)\n    ],\n    return_type=STRING,\n    doc=\"Encrypt a string using AES-256\"\n)\n</code></pre>"},{"location":"api/ir-types/#multiple-parameters","title":"Multiple Parameters","text":"<pre><code>add_func = IRFunction(\n    name=\"add\",\n    parameters=[\n        IRParameter(name=\"x\", type=INT),\n        IRParameter(name=\"y\", type=INT)\n    ],\n    return_type=INT\n)\n</code></pre>"},{"location":"api/ir-types/#no-parameters","title":"No Parameters","text":"<pre><code>get_version = IRFunction(\n    name=\"get_version\",\n    parameters=[],\n    return_type=STRING\n)\n</code></pre>"},{"location":"api/ir-types/#complex-types","title":"Complex Types","text":"<pre><code>from polyglot_ffi.ir.types import ir_option, ir_list\n\nfind_func = IRFunction(\n    name=\"find\",\n    parameters=[\n        IRParameter(name=\"query\", type=STRING)\n    ],\n    return_type=ir_option(STRING),\n    doc=\"Find a value, returns None if not found\"\n)\n\nmap_func = IRFunction(\n    name=\"map\",\n    parameters=[\n        IRParameter(name=\"items\", type=ir_list(STRING))\n    ],\n    return_type=ir_list(INT)\n)\n</code></pre>"},{"location":"api/ir-types/#module-construction","title":"Module Construction","text":"<pre><code>from polyglot_ffi.ir.types import IRModule, IRFunction, IRTypeDefinition\n\nmodule = IRModule(\n    name=\"crypto\",\n    functions=[\n        IRFunction(\n            name=\"encrypt\",\n            parameters=[IRParameter(name=\"data\", type=STRING)],\n            return_type=STRING\n        ),\n        IRFunction(\n            name=\"decrypt\",\n            parameters=[IRParameter(name=\"data\", type=STRING)],\n            return_type=STRING\n        )\n    ],\n    type_definitions=[\n        IRTypeDefinition(\n            name=\"cipher\",\n            definition=IRType(kind=TypeKind.VARIANT, name=\"cipher\", fields={\n                \"AES\": UNIT,\n                \"DES\": UNIT\n            })\n        )\n    ],\n    doc=\"Cryptography functions\"\n)\n</code></pre>"},{"location":"api/ir-types/#type-checking-methods","title":"Type Checking Methods","text":"<p>IRType provides convenient type checking methods:</p> <pre><code>from polyglot_ffi.ir.types import STRING, ir_option, ir_list, ir_tuple\n\n# Check if primitive\nSTRING.is_primitive()  # True\nir_option(STRING).is_primitive()  # False\n\n# Check if container (option, list, tuple)\nir_option(STRING).is_container()  # True\nir_list(INT).is_container()  # True\nSTRING.is_container()  # False\n\n# Check if composite (record, variant)\nperson_record.is_composite()  # True\nSTRING.is_composite()  # False\n</code></pre>"},{"location":"api/ir-types/#string-representation","title":"String Representation","text":"<p>All IR types have human-readable string representations:</p> <pre><code>str(STRING)  # \"string\"\nstr(ir_option(STRING))  # \"string option\"\nstr(ir_list(INT))  # \"int list\"\nstr(ir_tuple(STRING, INT))  # \"(string, int)\"\n\nfunc = IRFunction(\n    name=\"encrypt\",\n    parameters=[IRParameter(name=\"data\", type=STRING)],\n    return_type=STRING\n)\nstr(func)  # \"encrypt(data: string) -&gt; string\"\n</code></pre>"},{"location":"api/ir-types/#usage-in-generators","title":"Usage in Generators","text":"<p>Generators work with IR types to produce target code:</p> <pre><code>from polyglot_ffi.ir.types import IRType, TypeKind\nfrom polyglot_ffi.type_system.registry import get_default_registry\n\ndef generate_python_type(ir_type: IRType) -&gt; str:\n    \"\"\"Convert IR type to Python type hint.\"\"\"\n    registry = get_default_registry()\n\n    if ir_type.kind == TypeKind.PRIMITIVE:\n        return registry.get_mapping(ir_type, \"python\")\n\n    elif ir_type.kind == TypeKind.OPTION:\n        inner = generate_python_type(ir_type.params[0])\n        return f\"Optional[{inner}]\"\n\n    elif ir_type.kind == TypeKind.LIST:\n        inner = generate_python_type(ir_type.params[0])\n        return f\"List[{inner}]\"\n\n    # ... handle other types\n</code></pre>"},{"location":"api/ir-types/#complete-example","title":"Complete Example","text":"<pre><code>from polyglot_ffi.ir.types import (\n    IRModule, IRFunction, IRParameter, IRTypeDefinition,\n    STRING, INT, BOOL, ir_option, ir_list, ir_tuple\n)\n\n# Define a complete module\napi_module = IRModule(\n    name=\"api\",\n    functions=[\n        # Simple function\n        IRFunction(\n            name=\"get_version\",\n            parameters=[],\n            return_type=STRING,\n            doc=\"Get API version\"\n        ),\n\n        # Function with optional return\n        IRFunction(\n            name=\"find_user\",\n            parameters=[IRParameter(name=\"id\", type=INT)],\n            return_type=ir_option(STRING),\n            doc=\"Find user by ID, returns None if not found\"\n        ),\n\n        # Function with list parameters\n        IRFunction(\n            name=\"filter_active\",\n            parameters=[IRParameter(name=\"users\", type=ir_list(STRING))],\n            return_type=ir_list(STRING),\n            doc=\"Filter active users\"\n        ),\n\n        # Function with tuple\n        IRFunction(\n            name=\"split_name\",\n            parameters=[IRParameter(name=\"full_name\", type=STRING)],\n            return_type=ir_tuple(STRING, STRING),\n            doc=\"Split full name into (first, last)\"\n        )\n    ],\n    doc=\"User API module\"\n)\n\n# Use the module\nprint(f\"Module: {api_module.name}\")\nprint(f\"Functions: {len(api_module.functions)}\")\n\nfor func in api_module.functions:\n    print(f\"  {func.name}: {func.signature}\")\n</code></pre>"},{"location":"api/ir-types/#see-also","title":"See Also","text":"<ul> <li>Parser API - Parsing to IR</li> <li>Generators API - Generating from IR</li> <li>Type System - Type mappings</li> </ul>"},{"location":"api/parser/","title":"Parser API","text":"<p>The parser module is responsible for converting OCaml interface files (.mli) into the intermediate representation (IR).</p>"},{"location":"api/parser/#overview","title":"Overview","text":"<p>The parser takes OCaml <code>.mli</code> files as input and produces language-agnostic IR that can be used by any generator. This abstraction allows adding support for new source languages (Rust, Python, etc.) without changing generators.</p>"},{"location":"api/parser/#ocaml-parser","title":"OCaml Parser","text":""},{"location":"api/parser/#polyglot_ffi.parsers.ocaml.OCamlParser","title":"<code>polyglot_ffi.parsers.ocaml.OCamlParser</code>","text":"<p>Parse OCaml .mli interface files into IR.</p> <p>Supports: - Primitive types (string, int, float, bool, unit) - Complex types (option, list, tuple, record, variant) - Type variables ('a, 'b, etc.)</p> Source code in <code>src/polyglot_ffi/parsers/ocaml.py</code> <pre><code>class OCamlParser:\n    \"\"\"\n    Parse OCaml .mli interface files into IR.\n\n    Supports:\n    - Primitive types (string, int, float, bool, unit)\n    - Complex types (option, list, tuple, record, variant)\n    - Type variables ('a, 'b, etc.)\n    \"\"\"\n\n    # Primitive type mappings\n    PRIMITIVE_TYPES = {\n        \"string\": STRING,\n        \"int\": INT,\n        \"float\": FLOAT,\n        \"bool\": BOOL,\n        \"unit\": UNIT,\n    }\n\n    # Pre-compiled regex patterns for performance\n    OPTION_PATTERN = re.compile(r\"(.+?)\\s+option$\")\n    LIST_PATTERN = re.compile(r\"(.+?)\\s+list$\")\n    TYPE_VAR_PATTERN = re.compile(r\"^'[a-z]$\")\n    CUSTOM_TYPE_PATTERN = re.compile(r\"^[a-z_][a-z0-9_]*$\")\n\n    def __init__(self, content: str, filename: str = \"&lt;unknown&gt;\"):\n        self.content = content\n        self.filename = filename\n        self.lines = content.split(\"\\n\")\n\n    def parse(self) -&gt; IRModule:\n        \"\"\"Parse the content and return an IR module.\"\"\"\n        module_name = Path(self.filename).stem\n        functions = self._extract_functions()\n        type_definitions = self._extract_type_definitions()\n\n        return IRModule(\n            name=module_name,\n            functions=functions,\n            type_definitions=type_definitions,\n            doc=\"\",\n        )\n\n    def _extract_functions(self) -&gt; List[IRFunction]:\n        \"\"\"Extract all function signatures from the file.\"\"\"\n        functions = []\n        i = 0\n\n        while i &lt; len(self.lines):\n            line = self.lines[i].strip()\n\n            # Look for function declarations starting with 'val'\n            if line.startswith(\"val \"):\n                func, doc, lines_consumed = self._parse_function(self.lines[i:], i + 1)\n                if func:\n                    functions.append(func)\n                i += lines_consumed\n            else:\n                i += 1\n\n        return functions\n\n    def _extract_type_definitions(self) -&gt; List[IRTypeDefinition]:\n        \"\"\"Extract all type definitions (records and variants) from the file.\"\"\"\n        type_defs = []\n        i = 0\n\n        while i &lt; len(self.lines):\n            line = self.lines[i].strip()\n\n            # Look for type definitions starting with 'type'\n            if line.startswith(\"type \") and \"=\" in line:\n                typedef, lines_consumed = self._parse_type_definition(self.lines[i:], i + 1)\n                if typedef:\n                    type_defs.append(typedef)\n                i += lines_consumed\n            else:\n                i += 1\n\n        return type_defs\n\n    def _parse_type_definition(\n        self, lines: List[str], start_line: int\n    ) -&gt; Tuple[Optional[IRTypeDefinition], int]:\n        \"\"\"\n        Parse a type definition (record or variant).\n\n        Examples:\n            type user = { name: string; age: int }\n            type result = Ok of string | Error of string\n            type status = Success | Failure | Pending\n        \"\"\"\n        # Combine lines until we have the complete definition\n        full_def = \"\"\n        lines_consumed = 0\n\n        for j, line in enumerate(lines):\n            stripped = line.strip()\n            full_def += \" \" + stripped\n            lines_consumed += 1\n\n            # Check if definition is complete\n            # A simple heuristic: ends with a closing brace or doesn't have '|' at end\n            if stripped.endswith(\"}\") or (\"|\" not in stripped and j &gt; 0):\n                break\n            # Also stop if next line doesn't continue the definition\n            if j + 1 &lt; len(lines):\n                next_line = lines[j + 1].strip()\n                if next_line and not next_line.startswith(\"|\") and \"{\" not in full_def:\n                    break\n\n        full_def = full_def.strip()\n\n        try:\n            # Match: type name = definition\n            match = re.match(r\"type\\s+(\\w+)\\s*=\\s*(.+)\", full_def)\n            if not match:\n                raise ParseError(f\"Invalid type definition: {full_def}\", start_line)\n\n            type_name = match.group(1)\n            type_body = match.group(2).strip()\n\n            # Determine if it's a record or variant\n            if type_body.startswith(\"{\") and type_body.endswith(\"}\"):\n                # Record type\n                return self._parse_record_type(type_name, type_body, start_line), lines_consumed\n            elif \"|\" in type_body or (type_body[0].isupper() and \" of \" in type_body):\n                # Variant type\n                return self._parse_variant_type(type_name, type_body, start_line), lines_consumed\n            else:\n                # Type alias - treat as custom named type\n                aliased_type = self._parse_type(type_body, start_line)\n                # For now, we'll skip pure type aliases as they don't need special handling\n                return None, lines_consumed\n\n        except ParseError as e:\n            raise ParseError(f\"Error parsing type definition: {e}\", start_line)\n\n    def _parse_record_type(self, type_name: str, type_body: str, line_num: int) -&gt; IRTypeDefinition:\n        \"\"\"\n        Parse a record type definition.\n\n        Example: { name: string; age: int; email: string }\n        \"\"\"\n        # Remove braces\n        inner = type_body[1:-1].strip()\n\n        # Split by semicolon\n        field_strs = [f.strip() for f in inner.split(\";\") if f.strip()]\n\n        fields = {}\n        for field_str in field_strs:\n            # Match: field_name : type\n            match = re.match(r\"(\\w+)\\s*:\\s*(.+)\", field_str)\n            if not match:\n                raise ParseError(\n                    f\"Invalid record field: '{field_str}' in type '{type_name}'\", line_num\n                )\n\n            field_name = match.group(1)\n            field_type_str = match.group(2).strip()\n            field_type = self._parse_type(field_type_str, line_num)\n            fields[field_name] = field_type\n\n        return IRTypeDefinition(name=type_name, kind=TypeKind.RECORD, fields=fields, doc=\"\")\n\n    def _parse_variant_type(\n        self, type_name: str, type_body: str, line_num: int\n    ) -&gt; IRTypeDefinition:\n        \"\"\"\n        Parse a variant (sum) type definition.\n\n        Examples:\n            Ok of string | Error of string\n            Success | Failure | Pending\n        \"\"\"\n        # Split by pipe\n        variant_strs = [v.strip() for v in type_body.split(\"|\")]\n\n        variants = {}\n        for variant_str in variant_strs:\n            # Match: Constructor or Constructor of type\n            match = re.match(r\"(\\w+)(?:\\s+of\\s+(.+))?\", variant_str)\n            if not match:\n                raise ParseError(\n                    f\"Invalid variant: '{variant_str}' in type '{type_name}'\", line_num\n                )\n\n            constructor = match.group(1)\n            type_str = match.group(2)\n\n            if type_str:\n                variant_type = self._parse_type(type_str.strip(), line_num)\n                variants[constructor] = variant_type\n            else:\n                # Constructor without payload\n                variants[constructor] = None\n\n        return IRTypeDefinition(name=type_name, kind=TypeKind.VARIANT, variants=variants, doc=\"\")\n\n    def _parse_function(\n        self, lines: List[str], start_line: int\n    ) -&gt; Tuple[Optional[IRFunction], str, int]:\n        \"\"\"\n        Parse a single function signature.\n\n        Returns:\n            (IRFunction, documentation, lines_consumed)\n        \"\"\"\n        # Combine lines until we have the complete signature\n        full_sig = \"\"\n        doc = \"\"\n        lines_consumed = 0\n\n        for j, line in enumerate(lines):\n            stripped = line.strip()\n            full_sig += \" \" + stripped\n            lines_consumed += 1\n\n            # Extract documentation\n            doc_match = re.search(r\"\\(\\*\\*\\s*(.*?)\\s*\\*\\)\", stripped)\n            if doc_match:\n                doc = doc_match.group(1)\n                # Remove doc from signature\n                full_sig = re.sub(r\"\\(\\*\\*.*?\\*\\)\", \"\", full_sig)\n\n            # Check if signature is complete\n            # A signature is complete when it doesn't end with '-&gt;' and has no unclosed parens\n            if not stripped.endswith(\"-&gt;\"):\n                # Check for balanced parentheses\n                open_count = full_sig.count(\"(\") - full_sig.count(\")\")\n                if open_count == 0:\n                    break\n\n        # Parse the complete signature\n        try:\n            func = self._parse_signature(full_sig.strip(), start_line)\n            return func, doc, lines_consumed\n        except ParseError as e:\n            # Re-raise with line info\n            raise ParseError(str(e), start_line)\n\n    def _parse_signature(self, sig: str, line_num: int) -&gt; IRFunction:\n        \"\"\"\n        Parse a complete function signature.\n\n        Format: val name : type1 -&gt; type2 -&gt; ... -&gt; return_type\n        \"\"\"\n        # Match: val function_name : type_signature\n        match = re.match(r\"val\\s+(\\w+)\\s*:\\s*(.+)\", sig)\n        if not match:\n            raise ParseError(f\"Invalid function signature: {sig}\", line_num)\n\n        name = match.group(1)\n        type_sig = match.group(2).strip()\n\n        # Split by '-&gt;' to get parameter types and return type\n        parts = [p.strip() for p in type_sig.split(\"-&gt;\")]\n\n        if len(parts) &lt; 2:\n            raise ParseError(\n                f\"Function '{name}' must have at least one parameter and return type\", line_num\n            )\n\n        # All parts except the last are parameters\n        param_types = parts[:-1]\n        return_type_str = parts[-1]\n\n        # Parse parameter types\n        params = []\n        for i, param_type_str in enumerate(param_types):\n            try:\n                param_type = self._parse_type(param_type_str, line_num)\n                # Generate parameter name\n                param_name = f\"arg{i}\" if len(params) &gt; 0 else \"input\"\n                params.append(IRParameter(name=param_name, type=param_type))\n            except ParseError as e:\n                raise ParseError(\n                    f\"Error parsing parameter {i+1} of function '{name}': {e}\", line_num\n                )\n\n        # Parse return type\n        try:\n            return_type = self._parse_type(return_type_str, line_num)\n        except ParseError as e:\n            raise ParseError(f\"Error parsing return type of function '{name}': {e}\", line_num)\n\n        return IRFunction(name=name, params=params, return_type=return_type, doc=\"\")\n\n    def _parse_type(self, type_str: str, line_num: int) -&gt; IRType:\n        \"\"\"\n        Parse a type string into an IRType.\n\n        Supports:\n        - Primitives: string, int, float, bool, unit\n        - Options: 'a option, int option, string option, etc.\n        - Lists: 'a list, int list, string list, etc.\n        - Tuples: 'a * 'b, int * string, etc.\n        - Records and Variants: (complex type definitions)\n        \"\"\"\n        type_str = type_str.strip()\n\n        # Check for primitive types\n        if type_str in self.PRIMITIVE_TYPES:\n            return self.PRIMITIVE_TYPES[type_str]\n\n        # Check for option types: \"X option\"\n        option_match = self.OPTION_PATTERN.match(type_str)\n        if option_match:\n            inner_type_str = option_match.group(1).strip()\n            inner_type = self._parse_type(inner_type_str, line_num)\n            return ir_option(inner_type)\n\n        # Check for list types: \"X list\"\n        list_match = self.LIST_PATTERN.match(type_str)\n        if list_match:\n            inner_type_str = list_match.group(1).strip()\n            inner_type = self._parse_type(inner_type_str, line_num)\n            return ir_list(inner_type)\n\n        # Check for tuple types: \"X * Y\" or \"X * Y * Z\"\n        if \" * \" in type_str:\n            # Handle parentheses around tuples\n            if type_str.startswith(\"(\") and type_str.endswith(\")\"):\n                type_str = type_str[1:-1].strip()\n\n            # Split by * and parse each component\n            parts = [p.strip() for p in type_str.split(\"*\")]\n            tuple_types = [self._parse_type(part, line_num) for part in parts]\n\n            from polyglot_ffi.ir.types import ir_tuple\n\n            return ir_tuple(*tuple_types)\n\n        # Check for type variables: 'a, 'b, etc.\n        if self.TYPE_VAR_PATTERN.match(type_str):\n            # Type variables represent generic/polymorphic types\n            # For now, treat them as a special primitive\n            return ir_primitive(type_str)\n\n        # Check for custom named types (records, variants, or type aliases)\n        # These are identifiers that don't match primitives\n        if self.CUSTOM_TYPE_PATTERN.match(type_str):\n            # This is a custom type reference\n            # We'll create it as a CUSTOM type kind\n            return IRType(kind=TypeKind.CUSTOM, name=type_str)\n\n        # If we reach here, it's an unsupported type\n        suggestions = suggest_type_fix(type_str)\n        raise ParseError(\n            message=f\"Unsupported type: '{type_str}'\",\n            file_path=Path(self.filename) if self.filename != \"&lt;unknown&gt;\" else None,\n            line=line_num,\n            suggestions=suggestions,\n        )\n\n    @classmethod\n    def parse_file(cls, path: Path) -&gt; IRModule:\n        \"\"\"Parse a .mli file.\"\"\"\n        content = path.read_text()\n        parser = cls(content, str(path))\n        return parser.parse()\n\n    @classmethod\n    def parse_string(cls, content: str, filename: str = \"&lt;string&gt;\") -&gt; IRModule:\n        \"\"\"Parse a string containing OCaml interface code.\"\"\"\n        parser = cls(content, filename)\n        return parser.parse()\n</code></pre>"},{"location":"api/parser/#polyglot_ffi.parsers.ocaml.OCamlParser-functions","title":"Functions","text":""},{"location":"api/parser/#polyglot_ffi.parsers.ocaml.OCamlParser.__init__","title":"<code>__init__(content, filename='&lt;unknown&gt;')</code>","text":"Source code in <code>src/polyglot_ffi/parsers/ocaml.py</code> <pre><code>def __init__(self, content: str, filename: str = \"&lt;unknown&gt;\"):\n    self.content = content\n    self.filename = filename\n    self.lines = content.split(\"\\n\")\n</code></pre>"},{"location":"api/parser/#polyglot_ffi.parsers.ocaml.OCamlParser.parse","title":"<code>parse()</code>","text":"<p>Parse the content and return an IR module.</p> Source code in <code>src/polyglot_ffi/parsers/ocaml.py</code> <pre><code>def parse(self) -&gt; IRModule:\n    \"\"\"Parse the content and return an IR module.\"\"\"\n    module_name = Path(self.filename).stem\n    functions = self._extract_functions()\n    type_definitions = self._extract_type_definitions()\n\n    return IRModule(\n        name=module_name,\n        functions=functions,\n        type_definitions=type_definitions,\n        doc=\"\",\n    )\n</code></pre>"},{"location":"api/parser/#polyglot_ffi.parsers.ocaml.OCamlParser.parse_file","title":"<code>parse_file(path)</code>  <code>classmethod</code>","text":"<p>Parse a .mli file.</p> Source code in <code>src/polyglot_ffi/parsers/ocaml.py</code> <pre><code>@classmethod\ndef parse_file(cls, path: Path) -&gt; IRModule:\n    \"\"\"Parse a .mli file.\"\"\"\n    content = path.read_text()\n    parser = cls(content, str(path))\n    return parser.parse()\n</code></pre>"},{"location":"api/parser/#polyglot_ffi.parsers.ocaml.OCamlParser.parse_string","title":"<code>parse_string(content, filename='&lt;string&gt;')</code>  <code>classmethod</code>","text":"<p>Parse a string containing OCaml interface code.</p> Source code in <code>src/polyglot_ffi/parsers/ocaml.py</code> <pre><code>@classmethod\ndef parse_string(cls, content: str, filename: str = \"&lt;string&gt;\") -&gt; IRModule:\n    \"\"\"Parse a string containing OCaml interface code.\"\"\"\n    parser = cls(content, filename)\n    return parser.parse()\n</code></pre>"},{"location":"api/parser/#convenience-functions","title":"Convenience Functions","text":""},{"location":"api/parser/#polyglot_ffi.parsers.ocaml.parse_mli_file","title":"<code>polyglot_ffi.parsers.ocaml.parse_mli_file(path)</code>","text":"<p>Convenience function to parse a .mli file.</p>"},{"location":"api/parser/#polyglot_ffi.parsers.ocaml.parse_mli_string","title":"<code>polyglot_ffi.parsers.ocaml.parse_mli_string(content)</code>","text":"<p>Convenience function to parse OCaml interface code from a string.</p>"},{"location":"api/parser/#usage-examples","title":"Usage Examples","text":""},{"location":"api/parser/#parsing-from-file","title":"Parsing from File","text":"<pre><code>from pathlib import Path\nfrom polyglot_ffi.parsers.ocaml import OCamlParser\n\n# Method 1: Using class method\nmodule = OCamlParser.parse_file(Path(\"crypto.mli\"))\n\n# Method 2: Using convenience function\nfrom polyglot_ffi.parsers.ocaml import parse_mli_file\nmodule = parse_mli_file(Path(\"crypto.mli\"))\n\nprint(f\"Module: {module.name}\")\nprint(f\"Functions: {len(module.functions)}\")\n</code></pre>"},{"location":"api/parser/#parsing-from-string","title":"Parsing from String","text":"<pre><code>from polyglot_ffi.parsers.ocaml import parse_mli_string\n\nmli_code = \"\"\"\nval encrypt : string -&gt; string\nval decrypt : string -&gt; string\n\"\"\"\n\nmodule = parse_mli_string(mli_code)\n\nfor func in module.functions:\n    print(f\"Function: {func.name}\")\n    print(f\"  Parameters: {[p.name for p in func.parameters]}\")\n    print(f\"  Return type: {func.return_type}\")\n</code></pre>"},{"location":"api/parser/#custom-parser-instance","title":"Custom Parser Instance","text":"<pre><code>from polyglot_ffi.parsers.ocaml import OCamlParser\n\ncontent = Path(\"api.mli\").read_text()\nparser = OCamlParser(content, filename=\"api.mli\")\nmodule = parser.parse()\n\n# Access parsed data\nfor func in module.functions:\n    print(f\"{func.name}: {func.signature}\")\n</code></pre>"},{"location":"api/parser/#supported-ocaml-syntax","title":"Supported OCaml Syntax","text":""},{"location":"api/parser/#primitive-types","title":"Primitive Types","text":"<ul> <li><code>string</code> - String type</li> <li><code>int</code> - Integer type</li> <li><code>float</code> - Floating point type</li> <li><code>bool</code> - Boolean type</li> <li><code>unit</code> - Unit/void type</li> </ul>"},{"location":"api/parser/#complex-types","title":"Complex Types","text":"<ul> <li>Option types: <code>'a option</code>, <code>string option</code>, <code>int option</code></li> <li>List types: <code>'a list</code>, <code>string list</code>, <code>int list</code></li> <li>Tuple types: <code>'a * 'b</code>, <code>string * int</code>, <code>int * string * bool</code></li> <li>Record types: Named field records</li> <li>Variant types: Sum types with constructors</li> <li>Type variables: <code>'a</code>, <code>'b</code>, etc. (polymorphic types)</li> <li>Custom types: User-defined type names</li> </ul>"},{"location":"api/parser/#function-signatures","title":"Function Signatures","text":"<pre><code>(* Simple function *)\nval process : string -&gt; string\n\n(* Multiple parameters *)\nval add : int -&gt; int -&gt; int\n\n(* No parameters *)\nval get_version : unit -&gt; string\n\n(* Complex types *)\nval find : string -&gt; string option\nval map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list\n\n(* With documentation *)\n(** Encrypt a string using AES-256 *)\nval encrypt : string -&gt; string\n</code></pre>"},{"location":"api/parser/#error-handling","title":"Error Handling","text":"<p>The parser raises <code>ParseError</code> exceptions with detailed information:</p> <pre><code>from polyglot_ffi.parsers.ocaml import parse_mli_string\nfrom polyglot_ffi.utils.errors import ParseError\n\ntry:\n    module = parse_mli_string(\"val invalid : unknown_type -&gt; string\")\nexcept ParseError as e:\n    print(f\"Parse error: {e.message}\")\n    print(f\"Line: {e.context.line}\")\n    print(f\"File: {e.context.file_path}\")\n    if e.suggestions:\n        print(f\"Suggestions: {', '.join(e.suggestions)}\")\n</code></pre>"},{"location":"api/parser/#common-parse-errors","title":"Common Parse Errors","text":"Error Cause Suggestion Unsupported type Unknown type name Check type name spelling, use supported types Invalid signature Malformed function signature Check syntax: <code>val name : type -&gt; type</code> Invalid record Record syntax error Use <code>type t = { field : type }</code> Invalid variant Variant syntax error Use <code>type t = Constructor \\| Other</code>"},{"location":"api/parser/#performance","title":"Performance","text":"<p>The parser is optimized for speed:</p> <ul> <li>Regex pre-compilation: Patterns compiled once at class level</li> <li>Single-pass parsing: Each line read once</li> <li>Lazy evaluation: Only parses when needed</li> </ul> <p>Typical performance: - Small files (&lt; 10 functions): ~0.01ms - Medium files (10-50 functions): ~0.05ms - Large files (100+ functions): ~0.3ms</p>"},{"location":"api/parser/#see-also","title":"See Also","text":"<ul> <li>IR Types - Intermediate representation</li> <li>Type System - Type mappings</li> <li>Generators - Code generation</li> </ul>"},{"location":"api/type-system/","title":"Type System API","text":"<p>The type system manages mappings between IR types and target language types, ensuring consistent type translation across all generators.</p>"},{"location":"api/type-system/#overview","title":"Overview","text":"<p>The type system provides:</p> <ul> <li>Type Registry: Central repository for type mappings</li> <li>Built-in Types: Standard primitive type mappings</li> <li>Custom Types: User-defined type mappings</li> <li>Type Validation: Ensure types are supported</li> <li>Caching: O(1) lookup performance</li> </ul>"},{"location":"api/type-system/#type-registry","title":"Type Registry","text":""},{"location":"api/type-system/#polyglot_ffi.type_system.registry.TypeRegistry","title":"<code>polyglot_ffi.type_system.registry.TypeRegistry</code>","text":"<p>Registry for type mappings between IR types and target language types.</p> Example usage <p>registry = TypeRegistry() registry.register_primitive(\"string\", {     \"ocaml\": \"string\",     \"python\": \"str\",     \"c\": \"char*\" })</p> <p>python_type = registry.get_mapping(\"string\", \"python\")  # Returns \"str\"</p> Source code in <code>src/polyglot_ffi/type_system/registry.py</code> <pre><code>class TypeRegistry:\n    \"\"\"\n    Registry for type mappings between IR types and target language types.\n\n    Example usage:\n        registry = TypeRegistry()\n        registry.register_primitive(\"string\", {\n            \"ocaml\": \"string\",\n            \"python\": \"str\",\n            \"c\": \"char*\"\n        })\n\n        python_type = registry.get_mapping(\"string\", \"python\")  # Returns \"str\"\n    \"\"\"\n\n    def __init__(self):\n        self._primitive_mappings: Dict[str, Dict[str, str]] = {}\n        self._custom_converters: Dict[str, Dict[str, Callable]] = {}\n        # Cache for type mappings (cleared when registry is modified)\n        self._mapping_cache: Dict[tuple, str] = {}\n\n    def register_primitive(self, ir_type_name: str, mappings: Dict[str, str]) -&gt; None:\n        \"\"\"\n        Register a primitive type mapping.\n\n        Args:\n            ir_type_name: Name of the IR type (e.g., \"string\", \"int\")\n            mappings: Dictionary of language -&gt; type_name mappings\n        \"\"\"\n        self._primitive_mappings[ir_type_name] = mappings\n        self._mapping_cache.clear()  # Clear cache when registry is modified\n\n    def register_converter(\n        self, ir_type_name: str, target_lang: str, converter: Callable[[IRType], str]\n    ) -&gt; None:\n        \"\"\"\n        Register a custom type converter function.\n\n        Args:\n            ir_type_name: Name of the IR type\n            target_lang: Target language\n            converter: Function that takes IRType and returns type string\n        \"\"\"\n        if ir_type_name not in self._custom_converters:\n            self._custom_converters[ir_type_name] = {}\n        self._custom_converters[ir_type_name][target_lang] = converter\n        self._mapping_cache.clear()  # Clear cache when registry is modified\n\n    def _type_to_cache_key(self, ir_type: IRType) -&gt; tuple:\n        \"\"\"Convert IRType to a hashable cache key.\"\"\"\n        params_key = (\n            tuple(self._type_to_cache_key(p) for p in ir_type.params) if ir_type.params else ()\n        )\n        return (ir_type.kind.value, ir_type.name, params_key)\n\n    def get_mapping(self, ir_type: IRType, target_lang: str) -&gt; str:\n        \"\"\"\n        Get the type mapping for a target language.\n\n        Args:\n            ir_type: The IR type to map\n            target_lang: Target language (e.g., \"python\", \"c\", \"rust\")\n\n        Returns:\n            Type string in the target language\n\n        Raises:\n            TypeMappingError: If no mapping exists\n        \"\"\"\n        # Check cache first\n        cache_key = (self._type_to_cache_key(ir_type), target_lang)\n        if cache_key in self._mapping_cache:\n            return self._mapping_cache[cache_key]\n\n        # Compute the mapping\n        result = self._compute_mapping(ir_type, target_lang)\n\n        # Store in cache\n        self._mapping_cache[cache_key] = result\n        return result\n\n    def _compute_mapping(self, ir_type: IRType, target_lang: str) -&gt; str:\n        \"\"\"\n        Compute the type mapping for a target language (internal, uncached).\n\n        Args:\n            ir_type: The IR type to map\n            target_lang: Target language\n\n        Returns:\n            Type string in the target language\n\n        Raises:\n            TypeMappingError: If no mapping exists\n        \"\"\"\n        # Handle primitive types\n        if ir_type.kind == TypeKind.PRIMITIVE:\n            if ir_type.name in self._primitive_mappings:\n                mappings = self._primitive_mappings[ir_type.name]\n                if target_lang in mappings:\n                    return mappings[target_lang]\n                raise TypeMappingError(\n                    f\"No {target_lang} mapping for primitive type '{ir_type.name}'\"\n                )\n            raise TypeMappingError(f\"Unknown primitive type '{ir_type.name}'\")\n\n        # Handle option types\n        elif ir_type.kind == TypeKind.OPTION:\n            if not ir_type.params:\n                raise TypeMappingError(\"Option type must have a parameter\")\n\n            inner_type = self.get_mapping(ir_type.params[0], target_lang)\n\n            if target_lang == \"python\":\n                return f\"Optional[{inner_type}]\"\n            elif target_lang == \"c\":\n                # In C, we can use a struct with a flag\n                return f\"{inner_type}*\"  # Nullable pointer\n            elif target_lang == \"ocaml\":\n                return f\"{inner_type} option\"\n            elif target_lang == \"rust\":\n                return f\"Option&lt;{inner_type}&gt;\"\n            else:\n                raise TypeMappingError(f\"No option type support for {target_lang}\")\n\n        # Handle list types\n        elif ir_type.kind == TypeKind.LIST:\n            if not ir_type.params:\n                raise TypeMappingError(\"List type must have a parameter\")\n\n            inner_type = self.get_mapping(ir_type.params[0], target_lang)\n\n            if target_lang == \"python\":\n                return f\"List[{inner_type}]\"\n            elif target_lang == \"c\":\n                # In C, lists need special handling with structs\n                return f\"{inner_type}*\"  # Array pointer\n            elif target_lang == \"ocaml\":\n                return f\"{inner_type} list\"\n            elif target_lang == \"rust\":\n                return f\"Vec&lt;{inner_type}&gt;\"\n            else:\n                raise TypeMappingError(f\"No list type support for {target_lang}\")\n\n        # Handle tuple types\n        elif ir_type.kind == TypeKind.TUPLE:\n            if not ir_type.params:\n                raise TypeMappingError(\"Tuple type must have parameters\")\n\n            tuple_types = [self.get_mapping(p, target_lang) for p in ir_type.params]\n\n            if target_lang == \"python\":\n                types_str = \", \".join(tuple_types)\n                return f\"Tuple[{types_str}]\"\n            elif target_lang == \"c\":\n                # In C, tuples need struct definitions\n                return \"tuple_t\"  # Placeholder - needs actual struct\n            elif target_lang == \"ocaml\":\n                types_str = \" * \".join(tuple_types)\n                return f\"({types_str})\"\n            elif target_lang == \"rust\":\n                types_str = \", \".join(tuple_types)\n                return f\"({types_str})\"\n            else:\n                raise TypeMappingError(f\"No tuple type support for {target_lang}\")\n\n        # Handle custom types (records, variants)\n        elif ir_type.kind in (TypeKind.CUSTOM, TypeKind.RECORD, TypeKind.VARIANT):\n            # For custom types, check if there's a converter registered\n            if ir_type.name in self._custom_converters:\n                if target_lang in self._custom_converters[ir_type.name]:\n                    converter = self._custom_converters[ir_type.name][target_lang]\n                    return converter(ir_type)\n\n            # Default: use the type name as-is (with some conventions)\n            if target_lang == \"python\":\n                # Python: CamelCase for classes\n                return ir_type.name.title()\n            elif target_lang == \"c\":\n                # C: lowercase with _t suffix\n                return f\"{ir_type.name}_t\"\n            elif target_lang == \"ocaml\":\n                # OCaml: lowercase\n                return ir_type.name\n            elif target_lang == \"rust\":\n                # Rust: CamelCase\n                return ir_type.name.title()\n            else:\n                return ir_type.name\n\n        else:\n            raise TypeMappingError(f\"Unsupported type kind: {ir_type.kind}\")\n\n    def validate(self, ir_type: IRType, target_lang: str) -&gt; bool:\n        \"\"\"\n        Check if a type can be mapped to the target language.\n\n        Args:\n            ir_type: The IR type to validate\n            target_lang: Target language\n\n        Returns:\n            True if mapping exists, False otherwise\n        \"\"\"\n        try:\n            self.get_mapping(ir_type, target_lang)\n            return True\n        except TypeMappingError:\n            return False\n</code></pre>"},{"location":"api/type-system/#polyglot_ffi.type_system.registry.TypeRegistry-functions","title":"Functions","text":""},{"location":"api/type-system/#polyglot_ffi.type_system.registry.TypeRegistry.register_primitive","title":"<code>register_primitive(ir_type_name, mappings)</code>","text":"<p>Register a primitive type mapping.</p> <p>Parameters:</p> Name Type Description Default <code>ir_type_name</code> <code>str</code> <p>Name of the IR type (e.g., \"string\", \"int\")</p> required <code>mappings</code> <code>Dict[str, str]</code> <p>Dictionary of language -&gt; type_name mappings</p> required Source code in <code>src/polyglot_ffi/type_system/registry.py</code> <pre><code>def register_primitive(self, ir_type_name: str, mappings: Dict[str, str]) -&gt; None:\n    \"\"\"\n    Register a primitive type mapping.\n\n    Args:\n        ir_type_name: Name of the IR type (e.g., \"string\", \"int\")\n        mappings: Dictionary of language -&gt; type_name mappings\n    \"\"\"\n    self._primitive_mappings[ir_type_name] = mappings\n    self._mapping_cache.clear()  # Clear cache when registry is modified\n</code></pre>"},{"location":"api/type-system/#polyglot_ffi.type_system.registry.TypeRegistry.register_converter","title":"<code>register_converter(ir_type_name, target_lang, converter)</code>","text":"<p>Register a custom type converter function.</p> <p>Parameters:</p> Name Type Description Default <code>ir_type_name</code> <code>str</code> <p>Name of the IR type</p> required <code>target_lang</code> <code>str</code> <p>Target language</p> required <code>converter</code> <code>Callable[[IRType], str]</code> <p>Function that takes IRType and returns type string</p> required Source code in <code>src/polyglot_ffi/type_system/registry.py</code> <pre><code>def register_converter(\n    self, ir_type_name: str, target_lang: str, converter: Callable[[IRType], str]\n) -&gt; None:\n    \"\"\"\n    Register a custom type converter function.\n\n    Args:\n        ir_type_name: Name of the IR type\n        target_lang: Target language\n        converter: Function that takes IRType and returns type string\n    \"\"\"\n    if ir_type_name not in self._custom_converters:\n        self._custom_converters[ir_type_name] = {}\n    self._custom_converters[ir_type_name][target_lang] = converter\n    self._mapping_cache.clear()  # Clear cache when registry is modified\n</code></pre>"},{"location":"api/type-system/#polyglot_ffi.type_system.registry.TypeRegistry.get_mapping","title":"<code>get_mapping(ir_type, target_lang)</code>","text":"<p>Get the type mapping for a target language.</p> <p>Parameters:</p> Name Type Description Default <code>ir_type</code> <code>IRType</code> <p>The IR type to map</p> required <code>target_lang</code> <code>str</code> <p>Target language (e.g., \"python\", \"c\", \"rust\")</p> required <p>Returns:</p> Type Description <code>str</code> <p>Type string in the target language</p> <p>Raises:</p> Type Description <code>TypeMappingError</code> <p>If no mapping exists</p> Source code in <code>src/polyglot_ffi/type_system/registry.py</code> <pre><code>def get_mapping(self, ir_type: IRType, target_lang: str) -&gt; str:\n    \"\"\"\n    Get the type mapping for a target language.\n\n    Args:\n        ir_type: The IR type to map\n        target_lang: Target language (e.g., \"python\", \"c\", \"rust\")\n\n    Returns:\n        Type string in the target language\n\n    Raises:\n        TypeMappingError: If no mapping exists\n    \"\"\"\n    # Check cache first\n    cache_key = (self._type_to_cache_key(ir_type), target_lang)\n    if cache_key in self._mapping_cache:\n        return self._mapping_cache[cache_key]\n\n    # Compute the mapping\n    result = self._compute_mapping(ir_type, target_lang)\n\n    # Store in cache\n    self._mapping_cache[cache_key] = result\n    return result\n</code></pre>"},{"location":"api/type-system/#polyglot_ffi.type_system.registry.TypeRegistry.validate","title":"<code>validate(ir_type, target_lang)</code>","text":"<p>Check if a type can be mapped to the target language.</p> <p>Parameters:</p> Name Type Description Default <code>ir_type</code> <code>IRType</code> <p>The IR type to validate</p> required <code>target_lang</code> <code>str</code> <p>Target language</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if mapping exists, False otherwise</p> Source code in <code>src/polyglot_ffi/type_system/registry.py</code> <pre><code>def validate(self, ir_type: IRType, target_lang: str) -&gt; bool:\n    \"\"\"\n    Check if a type can be mapped to the target language.\n\n    Args:\n        ir_type: The IR type to validate\n        target_lang: Target language\n\n    Returns:\n        True if mapping exists, False otherwise\n    \"\"\"\n    try:\n        self.get_mapping(ir_type, target_lang)\n        return True\n    except TypeMappingError:\n        return False\n</code></pre>"},{"location":"api/type-system/#getting-the-registry","title":"Getting the Registry","text":"<pre><code>from polyglot_ffi.type_system.registry import get_default_registry\n\n# Get the global registry (lazy-initialized)\nregistry = get_default_registry()\n</code></pre>"},{"location":"api/type-system/#basic-usage","title":"Basic Usage","text":"<pre><code>from polyglot_ffi.ir.types import STRING, INT, ir_option\nfrom polyglot_ffi.type_system.registry import get_default_registry\n\nregistry = get_default_registry()\n\n# Map primitive types\nregistry.get_mapping(STRING, \"python\")  # \"str\"\nregistry.get_mapping(INT, \"python\")     # \"int\"\nregistry.get_mapping(STRING, \"rust\")    # \"String\"\nregistry.get_mapping(INT, \"c\")          # \"int64_t\"\n\n# Map complex types\nopt_string = ir_option(STRING)\nregistry.get_mapping(opt_string, \"python\")  # \"Optional[str]\"\nregistry.get_mapping(opt_string, \"rust\")    # \"Option&lt;String&gt;\"\n</code></pre>"},{"location":"api/type-system/#built-in-type-mappings","title":"Built-in Type Mappings","text":"<p>The registry comes pre-loaded with standard type mappings:</p>"},{"location":"api/type-system/#string-types","title":"String Types","text":"IR Type Python Rust OCaml C <code>string</code> <code>str</code> <code>String</code> <code>string</code> <code>char*</code>"},{"location":"api/type-system/#integer-types","title":"Integer Types","text":"IR Type Python Rust OCaml C <code>int</code> <code>int</code> <code>i64</code> <code>int</code> <code>int64_t</code>"},{"location":"api/type-system/#float-types","title":"Float Types","text":"IR Type Python Rust OCaml C <code>float</code> <code>float</code> <code>f64</code> <code>float</code> <code>double</code>"},{"location":"api/type-system/#boolean-types","title":"Boolean Types","text":"IR Type Python Rust OCaml C <code>bool</code> <code>bool</code> <code>bool</code> <code>bool</code> <code>int</code>"},{"location":"api/type-system/#unit-types","title":"Unit Types","text":"IR Type Python Rust OCaml C <code>unit</code> <code>None</code> <code>()</code> <code>unit</code> <code>void</code>"},{"location":"api/type-system/#complex-type-mappings","title":"Complex Type Mappings","text":""},{"location":"api/type-system/#option-types","title":"Option Types","text":"<pre><code>from polyglot_ffi.ir.types import STRING, ir_option\n\nopt_string = ir_option(STRING)\n\nregistry.get_mapping(opt_string, \"python\")  # \"Optional[str]\"\nregistry.get_mapping(opt_string, \"rust\")    # \"Option&lt;String&gt;\"\nregistry.get_mapping(opt_string, \"ocaml\")   # \"string option\"\n</code></pre>"},{"location":"api/type-system/#list-types","title":"List Types","text":"<pre><code>from polyglot_ffi.ir.types import INT, ir_list\n\nint_list = ir_list(INT)\n\nregistry.get_mapping(int_list, \"python\")  # \"List[int]\"\nregistry.get_mapping(int_list, \"rust\")    # \"Vec&lt;i64&gt;\"\nregistry.get_mapping(int_list, \"ocaml\")   # \"int list\"\n</code></pre>"},{"location":"api/type-system/#tuple-types","title":"Tuple Types","text":"<pre><code>from polyglot_ffi.ir.types import STRING, INT, ir_tuple\n\npair = ir_tuple(STRING, INT)\n\nregistry.get_mapping(pair, \"python\")  # \"Tuple[str, int]\"\nregistry.get_mapping(pair, \"rust\")    # \"(String, i64)\"\nregistry.get_mapping(pair, \"ocaml\")   # \"(string * int)\"\n</code></pre>"},{"location":"api/type-system/#nested-types","title":"Nested Types","text":"<p>The type system handles arbitrarily nested types:</p> <pre><code>from polyglot_ffi.ir.types import STRING, INT, ir_option, ir_list, ir_tuple\n\n# option[list[tuple[str, int]]]\ncomplex = ir_option(ir_list(ir_tuple(STRING, INT)))\n\nregistry.get_mapping(complex, \"python\")\n# \"Optional[List[Tuple[str, int]]]\"\n\nregistry.get_mapping(complex, \"rust\")\n# \"Option&lt;Vec&lt;(String, i64)&gt;&gt;\"\n</code></pre>"},{"location":"api/type-system/#custom-type-mappings","title":"Custom Type Mappings","text":""},{"location":"api/type-system/#registering-primitive-types","title":"Registering Primitive Types","text":"<pre><code>from polyglot_ffi.type_system.registry import TypeRegistry\n\nregistry = TypeRegistry()\n\n# Register a custom primitive type\nregistry.register_primitive(\"bytes\", {\n    \"ocaml\": \"bytes\",\n    \"python\": \"bytes\",\n    \"rust\": \"Vec&lt;u8&gt;\",\n    \"c\": \"uint8_t*\"\n})\n\n# Use it\nfrom polyglot_ffi.ir.types import ir_primitive\nbytes_type = ir_primitive(\"bytes\")\nregistry.get_mapping(bytes_type, \"python\")  # \"bytes\"\n</code></pre>"},{"location":"api/type-system/#registering-type-converters","title":"Registering Type Converters","text":"<p>For complex custom types, register a converter function:</p> <pre><code>from polyglot_ffi.ir.types import IRType\n\ndef convert_timestamp(ir_type: IRType) -&gt; str:\n    \"\"\"Convert timestamp type to Python.\"\"\"\n    return \"datetime.datetime\"\n\nregistry.register_converter(\"timestamp\", \"python\", convert_timestamp)\n\n# Use it\ntimestamp = ir_primitive(\"timestamp\")\nregistry.get_mapping(timestamp, \"python\")  # \"datetime.datetime\"\n</code></pre>"},{"location":"api/type-system/#custom-types-in-configuration","title":"Custom Types in Configuration","text":"<p>Users can define custom types in <code>polyglot.toml</code>:</p> <pre><code>[types.binary_data]\nocaml = \"bytes\"\npython = \"bytes\"\nrust = \"Vec&lt;u8&gt;\"\nc = \"uint8_t*\"\n\n[types.timestamp]\nocaml = \"float\"\npython = \"datetime.datetime\"\nrust = \"SystemTime\"\nc = \"time_t\"\n</code></pre>"},{"location":"api/type-system/#type-validation","title":"Type Validation","text":"<p>Check if a type mapping exists before using it:</p> <pre><code>from polyglot_ffi.ir.types import STRING, ir_primitive\n\nregistry = get_default_registry()\n\n# Validate known type\nis_valid = registry.validate(STRING, \"python\")  # True\n\n# Validate unknown type\nunknown = ir_primitive(\"unknown_type\")\nis_valid = registry.validate(unknown, \"python\")  # False\n</code></pre>"},{"location":"api/type-system/#error-handling","title":"Error Handling","text":"<p>The registry raises <code>TypeMappingError</code> for invalid mappings:</p> <pre><code>from polyglot_ffi.type_system.registry import TypeMappingError\nfrom polyglot_ffi.ir.types import ir_primitive\n\ntry:\n    unknown = ir_primitive(\"unknown_type\")\n    registry.get_mapping(unknown, \"python\")\nexcept TypeMappingError as e:\n    print(f\"Type mapping error: {e}\")\n    # \"Unknown primitive type 'unknown_type'\"\n</code></pre>"},{"location":"api/type-system/#performance","title":"Performance","text":"<p>The type registry is optimized for speed:</p> <ul> <li>O(1) primitive lookups: Direct dictionary access</li> <li>Caching: Computed mappings cached automatically</li> <li>Pre-compilation: No runtime regex compilation</li> </ul> <p>Typical performance: - Primitive lookup: ~0.0003ms - Option lookup: ~0.0007ms (with cache hit) - Complex nested type: ~0.0019ms (with cache hit)</p>"},{"location":"api/type-system/#cache-behavior","title":"Cache Behavior","text":"<p>The registry automatically caches computed type mappings:</p> <pre><code># First call: computes and caches\nresult1 = registry.get_mapping(ir_option(STRING), \"python\")\n\n# Second call: returns cached result (faster)\nresult2 = registry.get_mapping(ir_option(STRING), \"python\")\n\n# Cache is cleared when registry is modified\nregistry.register_primitive(\"newtype\", {...})\n# Cache cleared automatically\n</code></pre>"},{"location":"api/type-system/#usage-in-generators","title":"Usage in Generators","text":"<p>Generators use the registry to produce consistent type mappings:</p> <pre><code>from polyglot_ffi.ir.types import IRFunction, IRParameter\nfrom polyglot_ffi.type_system.registry import get_default_registry\n\ndef generate_python_signature(func: IRFunction) -&gt; str:\n    \"\"\"Generate Python function signature.\"\"\"\n    registry = get_default_registry()\n\n    # Map parameter types\n    params = []\n    for param in func.parameters:\n        py_type = registry.get_mapping(param.type, \"python\")\n        params.append(f\"{param.name}: {py_type}\")\n\n    # Map return type\n    return_type = registry.get_mapping(func.return_type, \"python\")\n\n    # Build signature\n    params_str = \", \".join(params)\n    return f\"def {func.name}({params_str}) -&gt; {return_type}:\"\n</code></pre>"},{"location":"api/type-system/#complete-example","title":"Complete Example","text":"<pre><code>from polyglot_ffi.ir.types import (\n    STRING, INT, BOOL, ir_option, ir_list, ir_tuple, ir_primitive\n)\nfrom polyglot_ffi.type_system.registry import (\n    TypeRegistry, get_default_registry\n)\n\n# Get default registry with built-in types\nregistry = get_default_registry()\n\n# Test primitive mappings\nprint(\"Primitives:\")\nfor lang in [\"python\", \"rust\", \"ocaml\", \"c\"]:\n    print(f\"  {lang}: string -&gt; {registry.get_mapping(STRING, lang)}\")\n\n# Test complex types\nprint(\"\\nComplex types:\")\nopt_int = ir_option(INT)\nprint(f\"  option[int] -&gt; {registry.get_mapping(opt_int, 'python')}\")\n\nlist_str = ir_list(STRING)\nprint(f\"  list[str] -&gt; {registry.get_mapping(list_str, 'rust')}\")\n\npair = ir_tuple(STRING, INT)\nprint(f\"  tuple[str,int] -&gt; {registry.get_mapping(pair, 'python')}\")\n\n# Test nested types\nnested = ir_option(ir_list(ir_tuple(STRING, INT)))\nprint(f\"\\nNested type:\")\nprint(f\"  Python: {registry.get_mapping(nested, 'python')}\")\nprint(f\"  Rust: {registry.get_mapping(nested, 'rust')}\")\n\n# Register custom type\nregistry.register_primitive(\"uuid\", {\n    \"python\": \"uuid.UUID\",\n    \"rust\": \"Uuid\",\n    \"ocaml\": \"string\",\n    \"c\": \"char*\"\n})\n\nuuid_type = ir_primitive(\"uuid\")\nprint(f\"\\nCustom type:\")\nprint(f\"  uuid -&gt; {registry.get_mapping(uuid_type, 'python')}\")\n\n# Validate types\nprint(f\"\\nValidation:\")\nprint(f\"  STRING valid? {registry.validate(STRING, 'python')}\")\nprint(f\"  unknown valid? {registry.validate(ir_primitive('unknown'), 'python')}\")\n</code></pre>"},{"location":"api/type-system/#see-also","title":"See Also","text":"<ul> <li>IR Types - Type definitions</li> <li>Generators - Using type mappings</li> <li>Configuration - Custom type config</li> </ul>"},{"location":"man/","title":"Polyglot FFI Man Pages","text":"<p>This directory contains manual pages for the polyglot-ffi tool.</p>"},{"location":"man/#available-man-pages","title":"Available Man Pages","text":""},{"location":"man/#section-1-user-commands","title":"Section 1: User Commands","text":"<ul> <li>polyglot-ffi(1) - Main command overview</li> <li>polyglot-ffi-init(1) - Initialize new projects</li> <li>polyglot-ffi-generate(1) - Generate FFI bindings</li> <li>polyglot-ffi-check(1) - Validate configuration and dependencies</li> <li>polyglot-ffi-clean(1) - Remove generated files</li> <li>polyglot-ffi-watch(1) - Watch mode for auto-regeneration</li> </ul>"},{"location":"man/#section-5-file-formats","title":"Section 5: File Formats","text":"<ul> <li>polyglot-ffi-config(5) - Configuration file format (polyglot.toml)</li> </ul>"},{"location":"man/#installation","title":"Installation","text":""},{"location":"man/#system-wide-installation","title":"System-wide Installation","text":"<p>To install man pages system-wide (requires sudo):</p> <pre><code># Copy man pages to system location\nsudo cp docs/man/*.1 /usr/local/share/man/man1/\nsudo cp docs/man/*.5 /usr/local/share/man/man5/\n\n# Update man database\nsudo mandb  # Linux\nsudo /usr/libexec/makewhatis /usr/local/share/man  # macOS\n</code></pre>"},{"location":"man/#user-installation","title":"User Installation","text":"<p>To install for current user only:</p> <pre><code># Create user man directory\nmkdir -p ~/.local/share/man/man1\nmkdir -p ~/.local/share/man/man5\n\n# Copy man pages\ncp docs/man/*.1 ~/.local/share/man/man1/\ncp docs/man/*.5 ~/.local/share/man/man5/\n\n# Add to MANPATH (add to ~/.bashrc or ~/.zshrc)\nexport MANPATH=\"$HOME/.local/share/man:$MANPATH\"\n</code></pre>"},{"location":"man/#developmentlocal-use","title":"Development/Local Use","text":"<p>View man pages directly without installation:</p> <pre><code># View a specific man page\nman docs/man/polyglot-ffi.1\n\n# Or use less\nless docs/man/polyglot-ffi.1\n</code></pre>"},{"location":"man/#usage","title":"Usage","text":"<p>After installation, access man pages with:</p> <pre><code># Main overview\nman polyglot-ffi\n\n# Specific commands\nman polyglot-ffi-init\nman polyglot-ffi-generate\nman polyglot-ffi-check\nman polyglot-ffi-clean\nman polyglot-ffi-watch\n\n# Configuration format\nman polyglot-ffi-config\nman 5 polyglot-ffi-config  # Explicit section 5\n</code></pre>"},{"location":"man/#viewing-man-pages","title":"Viewing Man Pages","text":""},{"location":"man/#plain-text","title":"Plain Text","text":"<pre><code>man polyglot-ffi | col -b &gt; polyglot-ffi.txt\n</code></pre>"},{"location":"man/#html","title":"HTML","text":"<pre><code>man -H polyglot-ffi  # Opens in browser (if configured)\n\n# Or use groff\ngroff -mandoc -Thtml docs/man/polyglot-ffi.1 &gt; polyglot-ffi.html\n</code></pre>"},{"location":"man/#pdf","title":"PDF","text":"<pre><code>groff -mandoc -Tpdf docs/man/polyglot-ffi.1 &gt; polyglot-ffi.pdf\n</code></pre>"},{"location":"man/#format","title":"Format","text":"<p>Man pages are written in troff/groff format using the man macro package.</p>"},{"location":"man/#common-formatting","title":"Common Formatting","text":"<ul> <li><code>.TH</code> - Title header</li> <li><code>.SH</code> - Section header</li> <li><code>.TP</code> - Tagged paragraph</li> <li><code>.B</code> - Bold text</li> <li><code>.I</code> - Italic text</li> <li><code>.EX/.EE</code> - Example blocks</li> </ul>"},{"location":"man/#contributing","title":"Contributing","text":"<p>When adding or modifying man pages:</p> <ol> <li>Follow existing structure and formatting</li> <li>Use consistent terminology</li> <li>Include practical examples</li> <li>Test rendering: <code>man ./docs/man/yourpage.1</code></li> <li>Validate with: <code>groff -man -z docs/man/yourpage.1</code></li> </ol>"},{"location":"man/#resources","title":"Resources","text":"<ul> <li>Man Page Guide</li> <li>Groff Manual</li> <li>Man Page Best Practices</li> </ul>"},{"location":"man/#license","title":"License","text":"<p>Man pages are part of the Polyglot FFI project and are licensed under the MIT License.</p>"}]}