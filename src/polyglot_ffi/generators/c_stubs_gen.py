"""
C stub code generator.
"""

from typing import Dict

from polyglot_ffi.ir.types import IRModule, IRType, IRFunction


class CStubGenerator:
    """Generate C wrapper code for OCaml functions."""

    # Map IR types to C types
    C_TYPE_MAP: Dict[str, str] = {
        "string": "char*",
        "int": "int",
        "float": "double",
        "bool": "int",
        "unit": "void",
    }

    def generate_stubs(self, module: IRModule, module_name: str) -> str:
        """Generate C stub implementation file."""
        lines = [
            f"/* Generated by polyglot-ffi */",
            f"/* {module_name}_stubs.c */",
            "",
            "#include <string.h>",
            "#include <caml/mlvalues.h>",
            "#include <caml/memory.h>",
            "#include <caml/alloc.h>",
            "#include <caml/callback.h>",
            "",
        ]

        for func in module.functions:
            lines.extend(self._generate_function_stub(func))
            lines.append("")

        return "\n".join(lines)

    def generate_header(self, module: IRModule, module_name: str) -> str:
        """Generate C header file."""
        guard = f"{module_name.upper()}_STUBS_H"

        lines = [
            f"/* Generated by polyglot-ffi */",
            f"/* {module_name}_stubs.h */",
            "",
            f"#ifndef {guard}",
            f"#define {guard}",
            "",
        ]

        # Function declarations
        for func in module.functions:
            c_return = self._get_c_type(func.return_type)
            params = ", ".join(f"{self._get_c_type(p.type)} {p.name}" for p in func.params)
            lines.append(f"{c_return} ml_{func.name}({params});")

        lines.append("")
        lines.append(f"#endif /* {guard} */")

        return "\n".join(lines)

    def _generate_function_stub(self, func: IRFunction) -> list:
        """Generate C stub for a single function."""
        lines = []

        # Function signature
        c_return = self._get_c_type(func.return_type)
        params = ", ".join(f"{self._get_c_type(p.type)} {p.name}" for p in func.params)

        lines.append(f"/* Wrapper for OCaml {func.name} function */")
        lines.append(f"{c_return} ml_{func.name}({params}) {{")
        lines.append("    CAMLparam0();")

        # Declare local variables
        num_locals = len(func.params) + 1
        local_vars = ", ".join(f"ml_{p.name}" for p in func.params) + ", ml_result"
        lines.append(f"    CAMLlocal{num_locals}({local_vars});")
        lines.append("")

        # Convert C parameters to OCaml values
        for param in func.params:
            lines.extend(self._convert_c_to_ocaml(param.name, param.type))

        # Call OCaml function
        if len(func.params) == 1:
            # Single parameter
            lines.append(
                f'    ml_result = caml_callback(*caml_named_value("{func.name}"), ml_{func.params[0].name});'
            )
        elif len(func.params) > 1:
            # Multiple parameters
            param_names = ", ".join(f"ml_{p.name}" for p in func.params)
            lines.append(
                f'    ml_result = caml_callback{len(func.params)}(*caml_named_value("{func.name}"), {param_names});'
            )
        else:
            # No parameters
            lines.append(
                f'    ml_result = caml_callback(*caml_named_value("{func.name}"), Val_unit);'
            )

        lines.append("")

        # Convert result back to C
        lines.extend(self._convert_ocaml_to_c(func.return_type))

        lines.append("}")

        return lines

    def _convert_c_to_ocaml(self, param_name: str, param_type: IRType) -> list:
        """Generate code to convert C value to OCaml value."""
        lines = []

        if param_type.name == "string":
            lines.append(f"    ml_{param_name} = caml_copy_string({param_name});")
        elif param_type.name == "int":
            lines.append(f"    ml_{param_name} = Val_int({param_name});")
        elif param_type.name == "float":
            lines.append(f"    ml_{param_name} = caml_copy_double({param_name});")
        elif param_type.name == "bool":
            lines.append(f"    ml_{param_name} = Val_bool({param_name});")
        elif param_type.name == "unit":
            lines.append(f"    ml_{param_name} = Val_unit;")

        return lines

    def _convert_ocaml_to_c(self, return_type: IRType) -> list:
        """Generate code to convert OCaml return value to C."""
        lines = []
        c_type = self._get_c_type(return_type)

        if return_type.name == "string":
            lines.append(f"    {c_type} result = strdup(String_val(ml_result));")
            lines.append(f"    CAMLreturnT({c_type}, result);")
        elif return_type.name == "int":
            lines.append(f"    {c_type} result = Int_val(ml_result);")
            lines.append(f"    CAMLreturnT({c_type}, result);")
        elif return_type.name == "float":
            lines.append(f"    {c_type} result = Double_val(ml_result);")
            lines.append(f"    CAMLreturnT({c_type}, result);")
        elif return_type.name == "bool":
            lines.append(f"    {c_type} result = Bool_val(ml_result);")
            lines.append(f"    CAMLreturnT({c_type}, result);")
        elif return_type.name == "unit":
            lines.append("    CAMLreturn0;")

        return lines

    def _get_c_type(self, ir_type: IRType) -> str:
        """Convert IR type to C type string."""
        if ir_type.is_primitive():
            return self.C_TYPE_MAP.get(ir_type.name, "char*")

        raise ValueError(f"Unsupported type for C generation: {ir_type}")
