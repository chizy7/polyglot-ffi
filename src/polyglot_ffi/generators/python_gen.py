"""
Python wrapper generator.
"""

from typing import Dict

from polyglot_ffi.ir.types import IRModule, IRType, IRFunction


class PythonGenerator:
    """Generate Python wrapper code."""

    # Map IR types to Python type hints
    PY_TYPE_MAP: Dict[str, str] = {
        "string": "str",
        "int": "int",
        "float": "float",
        "bool": "bool",
        "unit": "None",
    }

    # Map IR types to ctypes
    CTYPES_MAP: Dict[str, str] = {
        "string": "ctypes.c_char_p",
        "int": "ctypes.c_int",
        "float": "ctypes.c_double",
        "bool": "ctypes.c_bool",
        "unit": "None",
    }

    def generate(self, module: IRModule, module_name: str) -> str:
        """Generate Python wrapper module."""
        lines = [
            f"# Generated by polyglot-ffi",
            f"# {module_name}_py.py",
            "",
            "import ctypes",
            "from pathlib import Path",
            "from typing import Optional",
            "",
            "# Load the shared library",
            f'_lib_path = Path(__file__).parent / "lib{module_name}.so"',
            "_lib = ctypes.CDLL(str(_lib_path))",
            "",
            f"class {module_name.capitalize()}Error(Exception):",
            f'    """Raised when {module_name} operations fail"""',
            "    pass",
            "",
        ]

        # Configure ctypes for each function
        for func in module.functions:
            lines.append(f"# Configure {func.name}")

            # Set argtypes
            if func.params:
                argtypes = [self._get_ctypes(p.type) for p in func.params]
                lines.append(f"_lib.ml_{func.name}.argtypes = [{', '.join(argtypes)}]")

            # Set restype
            restype = self._get_ctypes(func.return_type)
            lines.append(f"_lib.ml_{func.name}.restype = {restype}")
            lines.append("")

        # Generate wrapper functions
        for func in module.functions:
            lines.extend(self._generate_function_wrapper(func, module_name))
            lines.append("")

        return "\n".join(lines)

    def _generate_function_wrapper(self, func: IRFunction, module_name: str) -> list:
        """Generate Python wrapper for a single function."""
        lines = []

        # Function signature
        params = [f"{p.name}: {self._get_py_type(p.type)}" for p in func.params]
        params_str = ", ".join(params) if params else ""
        return_type = self._get_py_type(func.return_type)

        lines.append(f"def {func.name}({params_str}) -> {return_type}:")

        # Docstring
        if func.doc:
            lines.append(f'    """{func.doc}"""')
        else:
            lines.append(f'    """Call OCaml {func.name} function"""')

        lines.append("    try:")

        # Convert arguments
        call_args = []
        for param in func.params:
            if param.type.name == "string":
                call_args.append(f"{param.name}.encode('utf-8')")
            else:
                call_args.append(param.name)

        # Make the call
        call_str = ", ".join(call_args) if call_args else ""
        lines.append(f"        result = _lib.ml_{func.name}({call_str})")

        # Handle return value
        if func.return_type.name == "string":
            lines.append("        if result is None:")
            lines.append(
                f'            raise {module_name.capitalize()}Error("{func.name} returned NULL")'
            )
            lines.append("        return result.decode('utf-8')")
        elif func.return_type.name == "unit":
            lines.append("        return None")
        else:
            lines.append("        return result")

        # Error handling
        lines.append("    except Exception as e:")
        lines.append(f'        raise {module_name.capitalize()}Error(f"{func.name} failed: {{e}}")')

        return lines

    def _get_py_type(self, ir_type: IRType) -> str:
        """Convert IR type to Python type hint."""
        if ir_type.is_primitive():
            return self.PY_TYPE_MAP.get(ir_type.name, "str")

        raise ValueError(f"Unsupported type for Python generation: {ir_type}")

    def _get_ctypes(self, ir_type: IRType) -> str:
        """Convert IR type to ctypes type."""
        if ir_type.is_primitive():
            return self.CTYPES_MAP.get(ir_type.name, "ctypes.c_char_p")

        raise ValueError(f"Unsupported type for ctypes: {ir_type}")
