# Generators API

Generators convert the intermediate representation (IR) into target language code. Each generator is responsible for producing idiomatic code in its target language.

## Overview

The generator architecture allows extending Polyglot FFI to new target languages without modifying the parser or IR. Each generator implements the same interface but produces different output.

## Ctypes Generator

Generates OCaml ctypes type and function descriptions.

::: polyglot_ffi.generators.ctypes_gen.CtypesGenerator
    options:
      show_root_heading: true
      show_source: true
      heading_level: 3
      members:
        - generate_type_description
        - generate_function_description

### Usage Example

```python
from polyglot_ffi.parsers.ocaml import parse_mli_file
from polyglot_ffi.generators.ctypes_gen import CtypesGenerator

# Parse OCaml interface
module = parse_mli_file(Path("crypto.mli"))

# Generate ctypes bindings
generator = CtypesGenerator()
type_desc = generator.generate_type_description(module)
func_desc = generator.generate_function_description(module)

# Write to files
Path("type_description.ml").write_text(type_desc)
Path("function_description.ml").write_text(func_desc)
```

### Generated Output

For `val encrypt : string -> string`:

```ocaml
(* type_description.ml *)
open Ctypes

let string = Ctypes.string

(* function_description.ml *)
open Ctypes

let encrypt = foreign "ml_encrypt" (string @-> returning string)
```

## C Stubs Generator

Generates memory-safe C wrapper code with proper CAMLparam/CAMLreturn macros.

::: polyglot_ffi.generators.c_stubs_gen.CStubGenerator
    options:
      show_root_heading: true
      show_source: true
      heading_level: 3
      members:
        - generate_stubs
        - generate_header

### Usage Example

```python
from polyglot_ffi.generators.c_stubs_gen import CStubGenerator

generator = CStubGenerator()
stubs = generator.generate_stubs(module, "crypto")
header = generator.generate_header(module, "crypto")

Path("stubs.c").write_text(stubs)
Path("stubs.h").write_text(header)
```

### Generated Output

For `val encrypt : string -> string`:

```c
/* stubs.c */
#include <caml/mlvalues.h>
#include <caml/memory.h>
#include <caml/alloc.h>
#include "stubs.h"

CAMLprim value ml_encrypt(value input) {
    CAMLparam1(input);
    CAMLlocal1(result);

    char* c_input = String_val(input);
    char* c_result = encrypt(c_input);
    result = caml_copy_string(c_result);

    CAMLreturn(result);
}
```

```c
/* stubs.h */
#ifndef CRYPTO_STUBS_H
#define CRYPTO_STUBS_H

#include <caml/mlvalues.h>

CAMLprim value ml_encrypt(value input);

#endif
```

## Python Generator

Generates type-safe Python wrapper modules with type hints.

::: polyglot_ffi.generators.python_gen.PythonGenerator
    options:
      show_root_heading: true
      show_source: true
      heading_level: 3
      members:
        - generate

### Usage Example

```python
from polyglot_ffi.generators.python_gen import PythonGenerator

generator = PythonGenerator()
wrapper = generator.generate(module, "crypto")

Path("crypto_py.py").write_text(wrapper)
```

### Generated Output

For `val encrypt : string -> string`:

```python
"""
Auto-generated Python bindings for crypto.
Generated by Polyglot FFI.
"""

import ctypes
from pathlib import Path
from typing import Optional

# Load shared library
_lib_path = Path(__file__).parent / "libcrypto.so"
_lib = ctypes.CDLL(str(_lib_path))

# Configure function signatures
_lib.ml_encrypt.argtypes = [ctypes.c_char_p]
_lib.ml_encrypt.restype = ctypes.c_char_p

def encrypt(input: str) -> str:
    """Encrypt a string."""
    result = _lib.ml_encrypt(input.encode('utf-8'))
    if result is None:
        raise RuntimeError("encrypt returned NULL")
    return result.decode('utf-8')
```

## Dune Generator

Generates Dune build system configuration.

::: polyglot_ffi.generators.dune_gen.DuneGenerator
    options:
      show_root_heading: true
      show_source: true
      heading_level: 3
      members:
        - generate_dune
        - generate_dune_project

### Usage Example

```python
from polyglot_ffi.generators.dune_gen import DuneGenerator

generator = DuneGenerator()
dune = generator.generate_dune("crypto")
dune_project = generator.generate_dune_project("crypto")

Path("dune").write_text(dune)
Path("dune-project").write_text(dune_project)
```

### Generated Output

```lisp
; dune
(library
 (name crypto)
 (libraries ctypes ctypes.foreign)
 (foreign_stubs
  (language c)
  (names stubs)))

; dune-project
(lang dune 3.0)
(name crypto)
```

## Complete Generation Workflow

```python
from pathlib import Path
from polyglot_ffi.parsers.ocaml import parse_mli_file
from polyglot_ffi.generators.ctypes_gen import CtypesGenerator
from polyglot_ffi.generators.c_stubs_gen import CStubGenerator
from polyglot_ffi.generators.python_gen import PythonGenerator
from polyglot_ffi.generators.dune_gen import DuneGenerator

# Parse
module = parse_mli_file(Path("crypto.mli"))

# Generate all artifacts
output_dir = Path("generated")
output_dir.mkdir(exist_ok=True)

# OCaml ctypes
ctypes_gen = CtypesGenerator()
(output_dir / "type_description.ml").write_text(
    ctypes_gen.generate_type_description(module)
)
(output_dir / "function_description.ml").write_text(
    ctypes_gen.generate_function_description(module)
)

# C stubs
c_gen = CStubGenerator()
(output_dir / "stubs.c").write_text(
    c_gen.generate_stubs(module, "crypto")
)
(output_dir / "stubs.h").write_text(
    c_gen.generate_header(module, "crypto")
)

# Python wrapper
py_gen = PythonGenerator()
(output_dir / "crypto_py.py").write_text(
    py_gen.generate(module, "crypto")
)

# Build system
dune_gen = DuneGenerator()
(output_dir / "dune").write_text(
    dune_gen.generate_dune("crypto")
)
(output_dir / "dune-project").write_text(
    dune_gen.generate_dune_project("crypto")
)

print(f"Generated {len(module.functions)} function bindings")
```

## Type Mapping

All generators use the type registry for consistent type mappings:

```python
from polyglot_ffi.type_system.registry import get_default_registry
from polyglot_ffi.ir.types import STRING, INT, ir_option

registry = get_default_registry()

# Primitive types
registry.get_mapping(STRING, "python")  # "str"
registry.get_mapping(INT, "python")     # "int"

# Complex types
opt_string = ir_option(STRING)
registry.get_mapping(opt_string, "python")  # "Optional[str]"
```

## Adding Custom Generators

To add support for a new target language:

```python
from polyglot_ffi.ir.types import IRModule

class RustGenerator:
    """Generate Rust FFI bindings."""

    def generate(self, module: IRModule, module_name: str) -> str:
        """Generate Rust code from IR."""
        lines = [
            f"// Auto-generated Rust bindings for {module_name}",
            "",
            "use std::ffi::CString;",
            "use std::os::raw::c_char;",
            "",
        ]

        for func in module.functions:
            # Generate extern declaration
            lines.append(f"extern \"C\" {{")
            lines.append(f"    fn ml_{func.name}(...) -> ...;")
            lines.append("}")

            # Generate safe wrapper
            lines.append(f"pub fn {func.name}(...) -> ... {{")
            lines.append(f"    unsafe {{ ml_{func.name}(...) }}")
            lines.append("}")
            lines.append("")

        return "\n".join(lines)
```

## Performance

Generators are highly optimized:

- **Ctypes**: ~0.0001ms per generation (extremely fast)
- **C Stubs**: ~0.009ms per generation
- **Python**: ~0.008ms per generation
- **Complete workflow**: ~0.07ms for 6 functions

All generators can be run in parallel for additional speedup.

## See Also

- [Parser API](parser.md) - Parsing OCaml files
- [IR Types](ir-types.md) - Intermediate representation
- [Type System](type-system.md) - Type mappings
